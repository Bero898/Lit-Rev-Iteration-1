text,Document Title,Abstract,source,bool,processed_text
"RESTful API Automated Test Case Generation with EvoMaster RESTful APIs are widespread in industry, especially in enterprise applications developed with a microservice architecture. A RESTful web service will provide data via an API over the network using HTTP, possibly interacting with databases and other web services. Testing a RESTful API poses challenges, because inputs/outputs are sequences of HTTP requests/responses to a remote server. Many approaches in the literature do black-box testing, because often the tested API is a remote service whose code is not available. In this article, we consider testing from the point of view of the developers, who have full access to the code that they are writing. Therefore, we propose a fully automated white-box testing approach, where test cases are automatically generated using an evolutionary algorithm. Tests are rewarded based on code coverage and fault-finding metrics. However, REST is not a protocol but rather a set of guidelines on how to design resources accessed over HTTP endpoints. For example, there are guidelines on how related resources should be structured with hierarchical URIs and how the different HTTP verbs should be used to represent well-defined actions on those resources. Test-case generation for RESTful APIs that only rely on white-box information of the source code might not be able to identify how to create prerequisite resources needed before being able to test some of the REST endpoints. Smart sampling techniques that exploit the knowledge of best practices in RESTful API design are needed to generate tests with predefined structures to speed up the search. We implemented our technique in a tool called EvoMaster, which is open source. Experiments on five open-source, yet non-trivial, RESTful services show that our novel technique automatically found 80 real bugs in those applications. However, obtained code coverage is lower than the one achieved by the manually written test suites already existing in those services. Research directions on how to further improve such an approach are therefore discussed, such as the handling of SQL databases.",RESTful API Automated Test Case Generation with EvoMaster,"RESTful APIs are widespread in industry, especially in enterprise applications developed with a microservice architecture. A RESTful web service will provide data via an API over the network using HTTP, possibly interacting with databases and other web services. Testing a RESTful API poses challenges, because inputs/outputs are sequences of HTTP requests/responses to a remote server. Many approaches in the literature do black-box testing, because often the tested API is a remote service whose code is not available. In this article, we consider testing from the point of view of the developers, who have full access to the code that they are writing. Therefore, we propose a fully automated white-box testing approach, where test cases are automatically generated using an evolutionary algorithm. Tests are rewarded based on code coverage and fault-finding metrics. However, REST is not a protocol but rather a set of guidelines on how to design resources accessed over HTTP endpoints. For example, there are guidelines on how related resources should be structured with hierarchical URIs and how the different HTTP verbs should be used to represent well-defined actions on those resources. Test-case generation for RESTful APIs that only rely on white-box information of the source code might not be able to identify how to create prerequisite resources needed before being able to test some of the REST endpoints. Smart sampling techniques that exploit the knowledge of best practices in RESTful API design are needed to generate tests with predefined structures to speed up the search. We implemented our technique in a tool called EvoMaster, which is open source. Experiments on five open-source, yet non-trivial, RESTful services show that our novel technique automatically found 80 real bugs in those applications. However, obtained code coverage is lower than the one achieved by the manually written test suites already existing in those services. Research directions on how to further improve such an approach are therefore discussed, such as the handling of SQL databases.",ACM,no,"['restful', 'api', 'automated', 'test', 'case', 'generation', 'evomaster', 'restful', 'apis', 'widespread', 'industry', 'especially', 'enterprise', 'developed', 'restful', 'web', 'provide', 'via', 'api', 'network', 'using', 'http', 'possibly', 'interacting', 'database', 'web', 'testing', 'restful', 'api', 'pose', 'challenge', 'sequence', 'http', 'remote', 'server', 'many', 'literature', 'testing', 'often', 'tested', 'api', 'remote', 'whose', 'code', 'available', 'article', 'consider', 'testing', 'point', 'view', 'developer', 'full', 'access', 'code', 'writing', 'therefore', 'propose', 'fully', 'automated', 'testing', 'test', 'case', 'automatically', 'generated', 'using', 'evolutionary', 'algorithm', 'test', 'based', 'code', 'coverage', 'metric', 'however', 'rest', 'protocol', 'rather', 'set', 'guideline', 'design', 'resource', 'accessed', 'http', 'endpoint', 'example', 'guideline', 'related', 'resource', 'structured', 'hierarchical', 'different', 'http', 'used', 'represent', 'action', 'resource', 'generation', 'restful', 'apis', 'rely', 'information', 'source', 'code', 'might', 'able', 'identify', 'create', 'resource', 'needed', 'able', 'test', 'rest', 'endpoint', 'smart', 'sampling', 'technique', 'exploit', 'knowledge', 'best', 'practice', 'restful', 'api', 'design', 'needed', 'generate', 'test', 'predefined', 'structure', 'speed', 'search', 'implemented', 'technique', 'tool', 'called', 'evomaster', 'open', 'source', 'experiment', 'five', 'yet', 'restful', 'show', 'novel', 'technique', 'automatically', 'found', 'real', 'bug', 'however', 'obtained', 'code', 'coverage', 'lower', 'one', 'achieved', 'manually', 'written', 'test', 'suite', 'already', 'existing', 'research', 'direction', 'improve', 'therefore', 'discussed', 'handling', 'database']"
"White-Box Fuzzing RPC-Based APIs with EvoMaster: An Industrial Case Study Remote Procedure Call (RPC) is a communication protocol to support client-server interactions among services over a network. RPC is widely applied in industry for building large-scale distributed systems, such as Microservices. Modern RPC frameworks include, for example, Thrift, gRPC, SOFARPC, and Dubbo. Testing such systems using RPC communications is very challenging, due to the complexity of distributed systems and various RPC frameworks the system could employ. To the best of our knowledge, there does not exist any tool or solution that could enable automated testing of modern RPC-based services. To fill this gap, in this article we propose the first approach in the literature, together with an open source tool, for fuzzing modern RPC-based APIs. The approach is in the context of white-box testing with search-based techniques. To tackle schema extraction of various RPC frameworks, we formulate a RPC schema specification along with a parser that allows the extraction from source code of any JVM RPC-based APIs. Then, with the extracted schema we employ a search to produce tests by maximizing white-box heuristics and newly defined heuristics specific to the RPC domain. We built our approach as an extension to an open source fuzzer (i.e., EvoMaster), and the approach has been integrated into a real industrial pipeline that could be applied to a real industrial development process for fuzzing RPC-based APIs. To assess our novel approach, we conducted an empirical study with two artificial and four industrial web services selected by our industrial partner. In addition, to further demonstrate its effectiveness and application in industrial settings, we report results of employing our tool for fuzzing another 50 industrial APIs autonomously conducted by our industrial partner in their testing processes. Results show that our novel approach is capable of enabling automated test case generation for industrial RPC-based APIs (i.e., 2 artificial and 54 industrial). We also compared with a simple gray-box technique and existing manually written tests. Our white-box solution achieves significant improvements on code coverage. Regarding fault detection, by conducting a careful review with our industrial partner of the tests generated by our novel approach in the selected four industrial APIs, a total of 41 real faults were identified, which have now been fixed. Another 8,377 detected faults are currently under investigation.",White-Box Fuzzing RPC-Based APIs with EvoMaster: An Industrial Case Study,"Remote Procedure Call (RPC) is a communication protocol to support client-server interactions among services over a network. RPC is widely applied in industry for building large-scale distributed systems, such as Microservices. Modern RPC frameworks include, for example, Thrift, gRPC, SOFARPC, and Dubbo. Testing such systems using RPC communications is very challenging, due to the complexity of distributed systems and various RPC frameworks the system could employ. To the best of our knowledge, there does not exist any tool or solution that could enable automated testing of modern RPC-based services. To fill this gap, in this article we propose the first approach in the literature, together with an open source tool, for fuzzing modern RPC-based APIs. The approach is in the context of white-box testing with search-based techniques. To tackle schema extraction of various RPC frameworks, we formulate a RPC schema specification along with a parser that allows the extraction from source code of any JVM RPC-based APIs. Then, with the extracted schema we employ a search to produce tests by maximizing white-box heuristics and newly defined heuristics specific to the RPC domain. We built our approach as an extension to an open source fuzzer (i.e., EvoMaster), and the approach has been integrated into a real industrial pipeline that could be applied to a real industrial development process for fuzzing RPC-based APIs. To assess our novel approach, we conducted an empirical study with two artificial and four industrial web services selected by our industrial partner. In addition, to further demonstrate its effectiveness and application in industrial settings, we report results of employing our tool for fuzzing another 50 industrial APIs autonomously conducted by our industrial partner in their testing processes. Results show that our novel approach is capable of enabling automated test case generation for industrial RPC-based APIs (i.e., 2 artificial and 54 industrial). We also compared with a simple gray-box technique and existing manually written tests. Our white-box solution achieves significant improvements on code coverage. Regarding fault detection, by conducting a careful review with our industrial partner of the tests generated by our novel approach in the selected four industrial APIs, a total of 41 real faults were identified, which have now been fixed. Another 8,377 detected faults are currently under investigation.",ACM,no,"['fuzzing', 'apis', 'evomaster', 'industrial', 'case', 'study', 'remote', 'procedure', 'call', 'rpc', 'communication', 'protocol', 'support', 'interaction', 'among', 'network', 'rpc', 'widely', 'applied', 'industry', 'building', 'distributed', 'modern', 'rpc', 'framework', 'include', 'example', 'grpc', 'dubbo', 'testing', 'using', 'rpc', 'communication', 'challenging', 'due', 'complexity', 'distributed', 'various', 'rpc', 'framework', 'could', 'employ', 'best', 'knowledge', 'exist', 'tool', 'solution', 'could', 'enable', 'automated', 'testing', 'modern', 'fill', 'gap', 'article', 'propose', 'first', 'literature', 'together', 'open', 'source', 'tool', 'fuzzing', 'modern', 'apis', 'context', 'testing', 'technique', 'tackle', 'schema', 'extraction', 'various', 'rpc', 'framework', 'formulate', 'rpc', 'schema', 'specification', 'along', 'allows', 'extraction', 'source', 'code', 'apis', 'extracted', 'schema', 'employ', 'search', 'produce', 'test', 'maximizing', 'heuristic', 'newly', 'defined', 'heuristic', 'specific', 'rpc', 'domain', 'built', 'extension', 'open', 'source', 'evomaster', 'integrated', 'real', 'industrial', 'pipeline', 'could', 'applied', 'real', 'industrial', 'development', 'process', 'fuzzing', 'apis', 'assess', 'novel', 'conducted', 'empirical', 'study', 'two', 'artificial', 'four', 'industrial', 'web', 'selected', 'industrial', 'partner', 'addition', 'demonstrate', 'effectiveness', 'industrial', 'setting', 'report', 'result', 'employing', 'tool', 'fuzzing', 'another', 'industrial', 'apis', 'autonomously', 'conducted', 'industrial', 'partner', 'testing', 'process', 'result', 'show', 'novel', 'capable', 'enabling', 'automated', 'test', 'case', 'generation', 'industrial', 'apis', 'artificial', 'industrial', 'also', 'compared', 'simple', 'technique', 'existing', 'manually', 'written', 'test', 'solution', 'achieves', 'significant', 'improvement', 'code', 'coverage', 'regarding', 'fault', 'detection', 'conducting', 'careful', 'review', 'industrial', 'partner', 'test', 'generated', 'novel', 'selected', 'four', 'industrial', 'apis', 'total', 'real', 'fault', 'identified', 'fixed', 'another', 'detected', 'fault', 'currently', 'investigation']"
"IMAGE: An Open-Source, Extensible Framework for Deploying Accessible Audio and Haptic Renderings of Web Graphics For accessibility practitioners, creating and deploying novel multimedia interactions for people with disabilities is a nontrivial task. As a result, many projects aiming to support such accessibility needs come and go or never make it to a public release. To reduce the overhead involved in deploying and maintaining a system that transforms web content into multimodal renderings, we created an open source, modular microservices architecture as part of the IMAGE project. This project aims to design richer means of interacting with web graphics than is afforded by a screen reader and text descriptions alone. To benefit the community of accessibility software developers, we discuss this architecture and explain how it provides support for several multimodal processing pipelines. Beyond illustrating the initial use case that motivated this effort, we further describe two use cases outside the scope of our project to explain how a team could use the architecture to develop and deploy accessible solutions for their own work. We then discuss our team’s experience working with the IMAGE architecture, informed by discussions with six project members, and provide recommendations to other practitioners considering applying the framework to their own accessibility projects.","IMAGE: An Open-Source, Extensible Framework for Deploying Accessible Audio and Haptic Renderings of Web Graphics","For accessibility practitioners, creating and deploying novel multimedia interactions for people with disabilities is a nontrivial task. As a result, many projects aiming to support such accessibility needs come and go or never make it to a public release. To reduce the overhead involved in deploying and maintaining a system that transforms web content into multimodal renderings, we created an open source, modular microservices architecture as part of the IMAGE project. This project aims to design richer means of interacting with web graphics than is afforded by a screen reader and text descriptions alone. To benefit the community of accessibility software developers, we discuss this architecture and explain how it provides support for several multimodal processing pipelines. Beyond illustrating the initial use case that motivated this effort, we further describe two use cases outside the scope of our project to explain how a team could use the architecture to develop and deploy accessible solutions for their own work. We then discuss our team’s experience working with the IMAGE architecture, informed by discussions with six project members, and provide recommendations to other practitioners considering applying the framework to their own accessibility projects.",ACM,no,"['image', 'extensible', 'framework', 'deploying', 'accessible', 'rendering', 'web', 'graphic', 'accessibility', 'practitioner', 'creating', 'deploying', 'novel', 'interaction', 'people', 'task', 'result', 'many', 'project', 'aiming', 'support', 'accessibility', 'need', 'come', 'go', 'make', 'public', 'release', 'reduce', 'overhead', 'involved', 'deploying', 'maintaining', 'web', 'content', 'multimodal', 'rendering', 'created', 'open', 'source', 'modular', 'part', 'image', 'project', 'project', 'aim', 'design', 'mean', 'interacting', 'web', 'graphic', 'text', 'description', 'benefit', 'community', 'accessibility', 'developer', 'discus', 'explain', 'provides', 'support', 'several', 'multimodal', 'processing', 'pipeline', 'beyond', 'initial', 'use', 'case', 'motivated', 'effort', 'describe', 'two', 'use', 'case', 'outside', 'scope', 'project', 'explain', 'team', 'could', 'use', 'develop', 'deploy', 'accessible', 'solution', 'work', 'discus', 'team', 'experience', 'working', 'image', 'discussion', 'six', 'project', 'provide', 'recommendation', 'practitioner', 'considering', 'applying', 'framework', 'accessibility', 'project']"
"The Tale of Errors in Microservices Microservice architecture is the computing paradigm of choice for large, service-oriented software catering to real-time requests. Individual programs in such a system perform Remote Procedure Calls (RPCs) to other microservices to accomplish sub-tasks. Microservices are designed to be robust; top-level requests can succeed despite errors returned from RPC sub-tasks, referred to as non-fatal errors. Because of this design, the top-level microservices tend to ''live with'' non-fatal errors. Hence, a natural question to ask is ''how prevalent are non-fatal errors and what impact do they have on the exposed latency of top-level requests?''In this paper, we present a large-scale study of errors in microservices. We answer the aforementioned question by analyzing 11 Billion RPCs covering 1,900 user-facing endpoints at the Uber serving requests of hundreds of millions of active users. To assess the latency impact of non-fatal errors, we develop a methodology that projects potential latency savings for a given request as if the time spent on failing APIs were eliminated. This estimator allows ranking and bubbling up those APIs that are worthy of further investigations, where the non-fatal errors likely resulted in operational inefficiencies. Finally, we employ our error detection and impact estimation techniques to pinpoint operational inefficiencies, which a) result in a tail latency reduction of a critical endpoint by 30\% and b) offer insights into common inefficiency-introducing patterns.",The Tale of Errors in Microservices,"Microservice architecture is the computing paradigm of choice for large, service-oriented software catering to real-time requests. Individual programs in such a system perform Remote Procedure Calls (RPCs) to other microservices to accomplish sub-tasks. Microservices are designed to be robust; top-level requests can succeed despite errors returned from RPC sub-tasks, referred to as non-fatal errors. Because of this design, the top-level microservices tend to ''live with'' non-fatal errors. Hence, a natural question to ask is ''how prevalent are non-fatal errors and what impact do they have on the exposed latency of top-level requests?''In this paper, we present a large-scale study of errors in microservices. We answer the aforementioned question by analyzing 11 Billion RPCs covering 1,900 user-facing endpoints at the Uber serving requests of hundreds of millions of active users. To assess the latency impact of non-fatal errors, we develop a methodology that projects potential latency savings for a given request as if the time spent on failing APIs were eliminated. This estimator allows ranking and bubbling up those APIs that are worthy of further investigations, where the non-fatal errors likely resulted in operational inefficiencies. Finally, we employ our error detection and impact estimation techniques to pinpoint operational inefficiencies, which a) result in a tail latency reduction of a critical endpoint by 30\% and b) offer insights into common inefficiency-introducing patterns.",ACM,no,"['error', 'computing', 'paradigm', 'choice', 'large', 'request', 'individual', 'program', 'perform', 'remote', 'procedure', 'call', 'accomplish', 'designed', 'robust', 'request', 'despite', 'error', 'rpc', 'referred', 'error', 'design', 'tend', 'live', 'error', 'hence', 'natural', 'question', 'prevalent', 'error', 'impact', 'exposed', 'latency', 'request', 'paper', 'present', 'study', 'error', 'answer', 'aforementioned', 'question', 'analyzing', 'covering', 'endpoint', 'serving', 'request', 'hundred', 'million', 'active', 'user', 'assess', 'latency', 'impact', 'error', 'develop', 'methodology', 'project', 'potential', 'latency', 'saving', 'given', 'request', 'time', 'apis', 'eliminated', 'allows', 'ranking', 'apis', 'investigation', 'error', 'likely', 'operational', 'finally', 'employ', 'error', 'detection', 'impact', 'estimation', 'technique', 'pinpoint', 'operational', 'result', 'tail', 'latency', 'reduction', 'critical', 'endpoint', 'b', 'offer', 'insight', 'common', 'pattern']"
"Design and development of an open private educational cloud storage solution for application development CS, IT, and software engineering students need to learn and master web application development and cloud computing skills on an educational full-stack Cloud architecture. In this paper we provide the design of an educational full-stack architecture integrating a private storage cloud. The focus was on how to integrate, configure, secure and deploy web-software applications, microservices and private storage within a full-stack architecture. In this research study we determined the feasibility of designing and developing an open private-cloud storage solution for cloud software. We also share the results of the deployment and testing of phases 0 and 1 of the educational full-stack architecture.",Design and development of an open private educational cloud storage solution for application development,"CS, IT, and software engineering students need to learn and master web application development and cloud computing skills on an educational full-stack Cloud architecture. In this paper we provide the design of an educational full-stack architecture integrating a private storage cloud. The focus was on how to integrate, configure, secure and deploy web-software applications, microservices and private storage within a full-stack architecture. In this research study we determined the feasibility of designing and developing an open private-cloud storage solution for cloud software. We also share the results of the deployment and testing of phases 0 and 1 of the educational full-stack architecture.",ACM,no,"['design', 'development', 'open', 'private', 'educational', 'storage', 'solution', 'development', 'c', 'engineering', 'student', 'need', 'learn', 'master', 'web', 'development', 'computing', 'skill', 'educational', 'paper', 'provide', 'design', 'educational', 'integrating', 'private', 'storage', 'focus', 'integrate', 'configure', 'secure', 'deploy', 'private', 'storage', 'within', 'research', 'study', 'feasibility', 'designing', 'developing', 'open', 'storage', 'solution', 'also', 'share', 'result', 'deployment', 'testing', 'phase', 'educational']"
"Semi-automated Cross-Component Issue Management and Impact Analysis Despite microservices and other component-based architecture styles being state of the art in research for many years by now, issue management across the boundaries of a single component is still challenging. Components that were developed independently and can be used independently are joined together in the overall architecture, which results in dependencies between those components. Due to these dependencies, bugs can result that propagate along the call chains through the architecture. Other types of issues, such as the violation of non-functional quality properties, can also impact other components. However, traditional issue management systems end at the boundaries of a component, making tracking of issues across different components time-consuming and error-prone. Therefore, a need for automation arises for cross-component issue management, which automatically puts issues of the independent components in the correct mutual context, creating new cross-component issues and syncing cross-component issues between different components. This automation could enable developers to manage issues across components as efficiently as possible and increases the system’s quality. To solve this problem, we propose an initial approach for semi-automated cross-component issue management in conjunction with service-level objectives based on our Gropius system. For example, relationships between issues of the same or different components can be predicted using classification to identify dependencies of issues across component boundaries. In addition, we are developing a system to model, monitor and alert service-level objectives. Based on this, the impact of such quality violations on the overall system and the business process will be analysed and explained through cross-component issues.",Semi-automated Cross-Component Issue Management and Impact Analysis,"Despite microservices and other component-based architecture styles being state of the art in research for many years by now, issue management across the boundaries of a single component is still challenging. Components that were developed independently and can be used independently are joined together in the overall architecture, which results in dependencies between those components. Due to these dependencies, bugs can result that propagate along the call chains through the architecture. Other types of issues, such as the violation of non-functional quality properties, can also impact other components. However, traditional issue management systems end at the boundaries of a component, making tracking of issues across different components time-consuming and error-prone. Therefore, a need for automation arises for cross-component issue management, which automatically puts issues of the independent components in the correct mutual context, creating new cross-component issues and syncing cross-component issues between different components. This automation could enable developers to manage issues across components as efficiently as possible and increases the system’s quality. To solve this problem, we propose an initial approach for semi-automated cross-component issue management in conjunction with service-level objectives based on our Gropius system. For example, relationships between issues of the same or different components can be predicted using classification to identify dependencies of issues across component boundaries. In addition, we are developing a system to model, monitor and alert service-level objectives. Based on this, the impact of such quality violations on the overall system and the business process will be analysed and explained through cross-component issues.",IEEE conference,no,"['issue', 'management', 'impact', 'analysis', 'despite', 'style', 'state', 'art', 'research', 'many', 'year', 'issue', 'management', 'across', 'boundary', 'single', 'still', 'challenging', 'developed', 'independently', 'used', 'independently', 'together', 'overall', 'result', 'dependency', 'due', 'dependency', 'bug', 'result', 'propagate', 'along', 'call', 'chain', 'type', 'issue', 'violation', 'quality', 'property', 'also', 'impact', 'however', 'traditional', 'issue', 'management', 'end', 'boundary', 'making', 'tracking', 'issue', 'across', 'different', 'therefore', 'need', 'automation', 'arises', 'issue', 'management', 'automatically', 'put', 'issue', 'independent', 'correct', 'mutual', 'context', 'creating', 'new', 'issue', 'issue', 'different', 'automation', 'could', 'enable', 'developer', 'manage', 'issue', 'across', 'efficiently', 'possible', 'increase', 'quality', 'solve', 'problem', 'propose', 'initial', 'issue', 'management', 'objective', 'based', 'example', 'relationship', 'issue', 'different', 'predicted', 'using', 'classification', 'identify', 'dependency', 'issue', 'across', 'boundary', 'addition', 'developing', 'model', 'monitor', 'objective', 'based', 'impact', 'quality', 'violation', 'overall', 'business', 'process', 'analysed', 'explained', 'issue']"
"A Multi-Level Self-Adaptation Approach For Microservice Systems Microservice technology that emphasizes self-management and lightweight of software systems has received great interests in both academic and industry fields of software engineering. The highly self-contained components and the dynamic running instance of microservice architecture require more flexible and diverse self-adaptation at multiple levels, which poses challenges to existing self-adaptation technologies. This paper proposes a multi-level self-adaptation approach to enrich the self-adaptation capabilities of microservice architecture and technologies. In our approach, the self-adaptation of microservice system can occur at both microservice level and instance level to satisfy various self-adaptation requirements. Based on the abstract model of self-adaptive microservice systems, the operation primitives to accomplish self-adaptation at different levels are proposed. We also present a microservice self-adaptation description language MSDL to specify the self-adaptation logics at multiple levels and implement a supporting platform by extending Kubernetes. A case is developed to illustrate our approach and experiments are conducted to show its effectiveness and availability.",A Multi-Level Self-Adaptation Approach For Microservice Systems,"Microservice technology that emphasizes self-management and lightweight of software systems has received great interests in both academic and industry fields of software engineering. The highly self-contained components and the dynamic running instance of microservice architecture require more flexible and diverse self-adaptation at multiple levels, which poses challenges to existing self-adaptation technologies. This paper proposes a multi-level self-adaptation approach to enrich the self-adaptation capabilities of microservice architecture and technologies. In our approach, the self-adaptation of microservice system can occur at both microservice level and instance level to satisfy various self-adaptation requirements. Based on the abstract model of self-adaptive microservice systems, the operation primitives to accomplish self-adaptation at different levels are proposed. We also present a microservice self-adaptation description language MSDL to specify the self-adaptation logics at multiple levels and implement a supporting platform by extending Kubernetes. A case is developed to illustrate our approach and experiments are conducted to show its effectiveness and availability.",IEEE conference,no,"['technology', 'emphasizes', 'lightweight', 'great', 'interest', 'academic', 'industry', 'field', 'engineering', 'highly', 'dynamic', 'running', 'instance', 'require', 'flexible', 'diverse', 'multiple', 'level', 'pose', 'challenge', 'existing', 'technology', 'paper', 'proposes', 'capability', 'technology', 'occur', 'level', 'instance', 'level', 'satisfy', 'various', 'requirement', 'based', 'model', 'operation', 'accomplish', 'different', 'level', 'proposed', 'also', 'present', 'description', 'language', 'specify', 'logic', 'multiple', 'level', 'implement', 'supporting', 'platform', 'extending', 'kubernetes', 'case', 'developed', 'illustrate', 'experiment', 'conducted', 'show', 'effectiveness', 'availability']"
"A BlackBox Approach to Profile Runtime Execution Dependencies in Microservices Loosely-coupled and lightweight microservices running in containers are likely to form complex execution dependencies inside the system. The execution dependency arises when two execution paths partially share component microservices, resulting in potential runtime performance interference. In this paper, we present a blackbox approach that utilizes legitimate HTTP requests to accurately profile the internal pairwise dependencies of all supported execution paths in the target microservices application. Concretely, we profile the pairwise dependency of two execution paths through performance interference analysis by sending bursts of two types of requests simultaneously. By characterizing and grouping all the execution paths based on their pairwise dependencies, the black box approach can derive a clear dependency graph(s) of the entire backend of the microservices application. We validate the effectiveness of the blackbox approach through experiments of open-source microservices benchmark applications running on real clouds (e.g., EC2, Azure).",A BlackBox Approach to Profile Runtime Execution Dependencies in Microservices,"Loosely-coupled and lightweight microservices running in containers are likely to form complex execution dependencies inside the system. The execution dependency arises when two execution paths partially share component microservices, resulting in potential runtime performance interference. In this paper, we present a blackbox approach that utilizes legitimate HTTP requests to accurately profile the internal pairwise dependencies of all supported execution paths in the target microservices application. Concretely, we profile the pairwise dependency of two execution paths through performance interference analysis by sending bursts of two types of requests simultaneously. By characterizing and grouping all the execution paths based on their pairwise dependencies, the black box approach can derive a clear dependency graph(s) of the entire backend of the microservices application. We validate the effectiveness of the blackbox approach through experiments of open-source microservices benchmark applications running on real clouds (e.g., EC2, Azure).",IEEE conference,no,"['blackbox', 'profile', 'runtime', 'execution', 'dependency', 'lightweight', 'running', 'container', 'likely', 'form', 'complex', 'execution', 'dependency', 'inside', 'execution', 'dependency', 'arises', 'two', 'execution', 'path', 'partially', 'share', 'resulting', 'potential', 'runtime', 'performance', 'interference', 'paper', 'present', 'blackbox', 'utilizes', 'http', 'request', 'accurately', 'profile', 'internal', 'pairwise', 'dependency', 'supported', 'execution', 'path', 'target', 'profile', 'pairwise', 'dependency', 'two', 'execution', 'path', 'performance', 'interference', 'analysis', 'two', 'type', 'request', 'simultaneously', 'characterizing', 'grouping', 'execution', 'path', 'based', 'pairwise', 'dependency', 'box', 'derive', 'clear', 'dependency', 'graph', 'entire', 'backend', 'validate', 'effectiveness', 'blackbox', 'experiment', 'benchmark', 'running', 'real', 'azure']"
"Microservices Architecture for Improved Maintainability and Traceability in MVC-Based E-Learning Platforms: RoadMap for Future Developments E-learning platforms often struggle with maintainability and traceability due to the traditionally employed monolithic architecture. Such websites are faced with managing complex codebases and tracking user interactions and system behaviors efficiently. These challenges are met by migrating to microservices architecture which permits modularization as well as autonomy of components by developers. This paper demonstrates how microservices can improve maintainability by allowing independent deployment, scaling up or down, upgrading services, and fostering traceability via distributed monitoring and logging systems. This can be demonstrated by analyzing a case of transitioning an MVC-based e-learning platform to microservices and showing how this could offer practical insights for sustainable development practices that optimize user experiences.",Microservices Architecture for Improved Maintainability and Traceability in MVC-Based E-Learning Platforms: RoadMap for Future Developments,"E-learning platforms often struggle with maintainability and traceability due to the traditionally employed monolithic architecture. Such websites are faced with managing complex codebases and tracking user interactions and system behaviors efficiently. These challenges are met by migrating to microservices architecture which permits modularization as well as autonomy of components by developers. This paper demonstrates how microservices can improve maintainability by allowing independent deployment, scaling up or down, upgrading services, and fostering traceability via distributed monitoring and logging systems. This can be demonstrated by analyzing a case of transitioning an MVC-based e-learning platform to microservices and showing how this could offer practical insights for sustainable development practices that optimize user experiences.",IEEE conference,no,"['improved', 'maintainability', 'traceability', 'platform', 'future', 'development', 'platform', 'often', 'maintainability', 'traceability', 'due', 'traditionally', 'employed', 'monolithic', 'website', 'faced', 'managing', 'complex', 'tracking', 'user', 'interaction', 'behavior', 'efficiently', 'challenge', 'met', 'migrating', 'modularization', 'well', 'autonomy', 'developer', 'paper', 'demonstrates', 'improve', 'maintainability', 'allowing', 'independent', 'deployment', 'scaling', 'upgrading', 'fostering', 'traceability', 'via', 'distributed', 'monitoring', 'logging', 'demonstrated', 'analyzing', 'case', 'platform', 'showing', 'could', 'offer', 'practical', 'insight', 'sustainable', 'development', 'practice', 'optimize', 'user', 'experience']"
"Self-adaptation in Microservice Architectures: A Case Study Most software companies deploy microservices be-hind API Gateways or load balancers to separate their business logic while at the same time serving their customers according to their SLAs. Today, internet companies serve an average of 150–200 million users efficiently in rapidly changing conditions, where autonomic self-adaptation solutions are critical. At such a large scale, self-adaptation has to address challenges related to high availability and reliability, in a variety of scenarios. In this industry experience report, we present the implementation of a self-adaptation approach for microservice architectures that can operate at a large scale and address availability and reliability concerns. Our prototype builds on current industry standards of observability tools used to track the system's internal state. We implement a lightweight MAPE-K loop that reduces the time taken to add self-adaptability and the total cost of ownership. Our case study focuses on dynamic rate limiting, where the implementation of our architecture was able to trigger and execute self-adaptation in under 1 second. We present our architecture, an overview of our prototype implementation and suite of tools used, and discuss our empirical observations.",Self-adaptation in Microservice Architectures: A Case Study,"Most software companies deploy microservices be-hind API Gateways or load balancers to separate their business logic while at the same time serving their customers according to their SLAs. Today, internet companies serve an average of 150–200 million users efficiently in rapidly changing conditions, where autonomic self-adaptation solutions are critical. At such a large scale, self-adaptation has to address challenges related to high availability and reliability, in a variety of scenarios. In this industry experience report, we present the implementation of a self-adaptation approach for microservice architectures that can operate at a large scale and address availability and reliability concerns. Our prototype builds on current industry standards of observability tools used to track the system's internal state. We implement a lightweight MAPE-K loop that reduces the time taken to add self-adaptability and the total cost of ownership. Our case study focuses on dynamic rate limiting, where the implementation of our architecture was able to trigger and execute self-adaptation in under 1 second. We present our architecture, an overview of our prototype implementation and suite of tools used, and discuss our empirical observations.",IEEE conference,no,"['case', 'study', 'company', 'deploy', 'api', 'gateway', 'load', 'balancer', 'separate', 'business', 'logic', 'time', 'serving', 'customer', 'according', 'slas', 'today', 'internet', 'company', 'serve', 'average', 'million', 'user', 'efficiently', 'rapidly', 'changing', 'condition', 'autonomic', 'solution', 'critical', 'large', 'scale', 'address', 'challenge', 'related', 'high', 'availability', 'reliability', 'variety', 'scenario', 'industry', 'experience', 'report', 'present', 'implementation', 'operate', 'large', 'scale', 'address', 'availability', 'reliability', 'concern', 'prototype', 'build', 'current', 'industry', 'standard', 'observability', 'tool', 'used', 'track', 'internal', 'state', 'implement', 'lightweight', 'loop', 'reduces', 'time', 'taken', 'add', 'total', 'cost', 'ownership', 'case', 'study', 'focus', 'dynamic', 'rate', 'limiting', 'implementation', 'able', 'execute', 'second', 'present', 'overview', 'prototype', 'implementation', 'suite', 'tool', 'used', 'discus', 'empirical', 'observation']"
"Experiences on a Frameworkless Micro-Frontend Architecture in a Small Organization Micro-frontend (MFE) architecture for a web application aims at doing the same for a monolithic user interface (UI) that microservices do for a monolithic backend: it decomposes the UI into self-contained components that can be developed, deployed, and provisioned together with their associated backend service. This paper represents a small team’s experiences at the Visma company transforming its monolithic UI into a Micro-frontend solution. We describe the motivations, the key design decisions based on Web Component technologies, the design and implementation process including ATAM-based architectural assessment, and our learnings from the case. The key takeaways are that (1) the motivations for MFE concerned improving customer-specific configurability and lowering the related costs rather than enabling team independence, (2) the APIs provided by web standards — and the Web Components API based on them — offered a competitive alternative for JavaScript frameworks avoiding many framework-induced problems, and (3) small organizations without a large number of feature teams can benefit from Micro-frontend architectures.",Experiences on a Frameworkless Micro-Frontend Architecture in a Small Organization,"Micro-frontend (MFE) architecture for a web application aims at doing the same for a monolithic user interface (UI) that microservices do for a monolithic backend: it decomposes the UI into self-contained components that can be developed, deployed, and provisioned together with their associated backend service. This paper represents a small team’s experiences at the Visma company transforming its monolithic UI into a Micro-frontend solution. We describe the motivations, the key design decisions based on Web Component technologies, the design and implementation process including ATAM-based architectural assessment, and our learnings from the case. The key takeaways are that (1) the motivations for MFE concerned improving customer-specific configurability and lowering the related costs rather than enabling team independence, (2) the APIs provided by web standards — and the Web Components API based on them — offered a competitive alternative for JavaScript frameworks avoiding many framework-induced problems, and (3) small organizations without a large number of feature teams can benefit from Micro-frontend architectures.",IEEE conference,no,"['experience', 'small', 'organization', 'web', 'aim', 'monolithic', 'user', 'interface', 'ui', 'monolithic', 'backend', 'decomposes', 'ui', 'developed', 'deployed', 'provisioned', 'together', 'associated', 'backend', 'paper', 'represents', 'small', 'team', 'experience', 'company', 'transforming', 'monolithic', 'ui', 'solution', 'describe', 'motivation', 'key', 'design', 'decision', 'based', 'web', 'technology', 'design', 'implementation', 'process', 'including', 'architectural', 'assessment', 'learning', 'case', 'key', 'motivation', 'improving', 'lowering', 'related', 'cost', 'rather', 'enabling', 'team', 'independence', 'apis', 'provided', 'web', 'standard', 'web', 'api', 'based', 'offered', 'competitive', 'alternative', 'framework', 'avoiding', 'many', 'problem', 'small', 'organization', 'without', 'large', 'number', 'feature', 'team', 'benefit']"
"An Approach to Follow Microservices Principles in Frontend Software development practices have evolved rapidly, seeking more flexible and reusable architectures. Microservices technology is an example of this, with its principles of technological independence and heterogeneity. These principles can be extended to the concept of micro-frontends, which proposes to divide the interface, allowing each team to work independently. This article presents an architecture that uses components developed in multiple frontend frameworks, aiming to make the workflow more independent and modular. The proposed architecture was evaluated in a prototype developed at the Animal Health Defense Platform of Rio Grande do Sul, which successfully integrated components from different frameworks.",An Approach to Follow Microservices Principles in Frontend,"Software development practices have evolved rapidly, seeking more flexible and reusable architectures. Microservices technology is an example of this, with its principles of technological independence and heterogeneity. These principles can be extended to the concept of micro-frontends, which proposes to divide the interface, allowing each team to work independently. This article presents an architecture that uses components developed in multiple frontend frameworks, aiming to make the workflow more independent and modular. The proposed architecture was evaluated in a prototype developed at the Animal Health Defense Platform of Rio Grande do Sul, which successfully integrated components from different frameworks.",IEEE conference,no,"['follow', 'principle', 'frontend', 'development', 'practice', 'evolved', 'rapidly', 'seeking', 'flexible', 'reusable', 'technology', 'example', 'principle', 'technological', 'independence', 'heterogeneity', 'principle', 'extended', 'concept', 'proposes', 'divide', 'interface', 'allowing', 'team', 'work', 'independently', 'article', 'present', 'us', 'developed', 'multiple', 'frontend', 'framework', 'aiming', 'make', 'workflow', 'independent', 'modular', 'proposed', 'evaluated', 'prototype', 'developed', 'health', 'defense', 'platform', 'successfully', 'integrated', 'different', 'framework']"
"The advantages of Micro-Frontend architecture for developing web application Based on the fact that the use of web applications is growing strongly and witnessing the chaos in the development of the frontends of these applications, in recent years there has been a need for an innovation that will solve the issues addressed by this complexity. Large applications with scalability needs need modularity. Seeing the surprising results of applying microservices and the increased performance of backend development in general, the need for modularity in the frontend has been met with the introduction of microfrontends as their counterparts in the field of frontend development. Also in the case of performance, each microfrontend works as an independent unit and the components can be loaded and executed in parallel, thus simultaneously reducing the overall load time of the application.This paper presents the many benefits that the microfrontend architecture brings to the web application development process, highlighting the possibilities to promote modularity, scalability and team autonomy. Also through a description supplemented with use cases and industry trends, this paper presents the microfrontend architecture as a fundamental basis for the development of modern web applications.",The advantages of Micro-Frontend architecture for developing web application,"Based on the fact that the use of web applications is growing strongly and witnessing the chaos in the development of the frontends of these applications, in recent years there has been a need for an innovation that will solve the issues addressed by this complexity. Large applications with scalability needs need modularity. Seeing the surprising results of applying microservices and the increased performance of backend development in general, the need for modularity in the frontend has been met with the introduction of microfrontends as their counterparts in the field of frontend development. Also in the case of performance, each microfrontend works as an independent unit and the components can be loaded and executed in parallel, thus simultaneously reducing the overall load time of the application.This paper presents the many benefits that the microfrontend architecture brings to the web application development process, highlighting the possibilities to promote modularity, scalability and team autonomy. Also through a description supplemented with use cases and industry trends, this paper presents the microfrontend architecture as a fundamental basis for the development of modern web applications.",IEEE conference,no,"['advantage', 'developing', 'web', 'based', 'fact', 'use', 'web', 'growing', 'strongly', 'chaos', 'development', 'recent', 'year', 'need', 'solve', 'issue', 'addressed', 'complexity', 'large', 'scalability', 'need', 'need', 'modularity', 'result', 'applying', 'increased', 'performance', 'backend', 'development', 'general', 'need', 'modularity', 'frontend', 'met', 'introduction', 'counterpart', 'field', 'frontend', 'development', 'also', 'case', 'performance', 'microfrontend', 'work', 'independent', 'unit', 'executed', 'parallel', 'thus', 'simultaneously', 'reducing', 'overall', 'load', 'time', 'paper', 'present', 'many', 'benefit', 'microfrontend', 'brings', 'web', 'development', 'process', 'highlighting', 'possibility', 'promote', 'modularity', 'scalability', 'team', 'autonomy', 'also', 'description', 'use', 'case', 'industry', 'trend', 'paper', 'present', 'microfrontend', 'fundamental', 'basis', 'development', 'modern', 'web']"
"Design and research of University intelligent education cloud platform based on Dubbo microservice framework With the rapid development of mobile Internet, more and more people participate in online learning, online interaction and online communication. Online education has gradually become a new education model. Aiming at the cloud computing environment, this paper uses the hierarchical systematic design idea to deeply carry out the demand analysis and architecture design of smart education cloud in Colleges and universities. The system architecture design of the platform takes service and component as the core, and realizes the service encapsulation of each functional module of the platform through the micro service design of the single project architecture. At the same time, combining Dubbo microservice framework and distributed database technology, the platform's RPC communication, service discovery and traffic management capabilities are optimized, which effectively improves the intelligent management and application level of the platform.",Design and research of University intelligent education cloud platform based on Dubbo microservice framework,"With the rapid development of mobile Internet, more and more people participate in online learning, online interaction and online communication. Online education has gradually become a new education model. Aiming at the cloud computing environment, this paper uses the hierarchical systematic design idea to deeply carry out the demand analysis and architecture design of smart education cloud in Colleges and universities. The system architecture design of the platform takes service and component as the core, and realizes the service encapsulation of each functional module of the platform through the micro service design of the single project architecture. At the same time, combining Dubbo microservice framework and distributed database technology, the platform's RPC communication, service discovery and traffic management capabilities are optimized, which effectively improves the intelligent management and application level of the platform.",IEEE conference,no,"['design', 'research', 'university', 'intelligent', 'education', 'platform', 'based', 'dubbo', 'framework', 'rapid', 'development', 'mobile', 'internet', 'people', 'online', 'learning', 'online', 'interaction', 'online', 'communication', 'online', 'education', 'gradually', 'become', 'new', 'education', 'model', 'aiming', 'computing', 'environment', 'paper', 'us', 'hierarchical', 'systematic', 'design', 'idea', 'carry', 'demand', 'analysis', 'design', 'smart', 'education', 'university', 'design', 'platform', 'take', 'core', 'realizes', 'functional', 'module', 'platform', 'micro', 'design', 'single', 'project', 'time', 'combining', 'dubbo', 'framework', 'distributed', 'database', 'technology', 'platform', 'rpc', 'communication', 'discovery', 'traffic', 'management', 'capability', 'optimized', 'effectively', 'improves', 'intelligent', 'management', 'level', 'platform']"
"Microservices for Continuous Deployment, Monitoring and Validation in Cyber-Physical Systems: an Industrial Case Study for Elevators Systems Cyber-Physical Systems (CPSs) are systems that integrate digital cyber computations with physical processes. The software embedded in CPSs has a long life-cycle, requiring constant evolution to support new requirements, bug fixes, and deal with hardware obsolescence. To date, the development of software for CPSs is fragmented, which makes it extremely expensive. This could be substantially enhanced by tightly connecting the development and operation phases, as is done in other software engineering domains (e.g., web engineering through DevOps). Nevertheless, there are still complex issues that make it difficult to use DevOps techniques in the CPS domain, such as those related to hardware-software co-design. To pave the way towards DevOps in the CPS domain, in this paper we instantiate part of the reference architecture presented in the H2020 Adeptness project, which is based on microservices that allow for the continuous deployment, monitoring and validation of CPSs. To this end, we elaborate a systematic methodology that considers as input both domain expertise and a previously defined taxonomy for DevOps in the CPS domain. We obtain a generic microservice template that can be used in any kind of CPS. In addition, we instantiate this architecture in the context of an industrial case study from the elevation domain.","Microservices for Continuous Deployment, Monitoring and Validation in Cyber-Physical Systems: an Industrial Case Study for Elevators Systems","Cyber-Physical Systems (CPSs) are systems that integrate digital cyber computations with physical processes. The software embedded in CPSs has a long life-cycle, requiring constant evolution to support new requirements, bug fixes, and deal with hardware obsolescence. To date, the development of software for CPSs is fragmented, which makes it extremely expensive. This could be substantially enhanced by tightly connecting the development and operation phases, as is done in other software engineering domains (e.g., web engineering through DevOps). Nevertheless, there are still complex issues that make it difficult to use DevOps techniques in the CPS domain, such as those related to hardware-software co-design. To pave the way towards DevOps in the CPS domain, in this paper we instantiate part of the reference architecture presented in the H2020 Adeptness project, which is based on microservices that allow for the continuous deployment, monitoring and validation of CPSs. To this end, we elaborate a systematic methodology that considers as input both domain expertise and a previously defined taxonomy for DevOps in the CPS domain. We obtain a generic microservice template that can be used in any kind of CPS. In addition, we instantiate this architecture in the context of an industrial case study from the elevation domain.",IEEE conference,no,"['continuous', 'deployment', 'monitoring', 'validation', 'industrial', 'case', 'study', 'cps', 'integrate', 'digital', 'cyber', 'computation', 'physical', 'process', 'embedded', 'cps', 'long', 'requiring', 'constant', 'evolution', 'support', 'new', 'requirement', 'bug', 'deal', 'hardware', 'obsolescence', 'development', 'cps', 'make', 'extremely', 'expensive', 'could', 'enhanced', 'connecting', 'development', 'operation', 'phase', 'done', 'engineering', 'domain', 'web', 'engineering', 'devops', 'nevertheless', 'still', 'complex', 'issue', 'make', 'difficult', 'use', 'devops', 'technique', 'cps', 'domain', 'related', 'pave', 'way', 'towards', 'devops', 'cps', 'domain', 'paper', 'instantiate', 'part', 'reference', 'presented', 'project', 'based', 'allow', 'continuous', 'deployment', 'monitoring', 'validation', 'cps', 'end', 'elaborate', 'systematic', 'methodology', 'considers', 'input', 'domain', 'expertise', 'previously', 'defined', 'taxonomy', 'devops', 'cps', 'domain', 'obtain', 'generic', 'template', 'used', 'kind', 'cps', 'addition', 'instantiate', 'context', 'industrial', 'case', 'study', 'domain']"
"Runtime Microservice Self-distribution for Fine-grain Resource Allocation The development of systems using microservices as buildingblocks have gained! major popularity in the industry in the past few years. Widely used services, such as Netflix and Uber, have been built entirely as microservice architectures. Due to the modularity and self-containedness of microservices, coupled with the use of elastic deployment infrastructures, a number of tools to assist the scalability of such systems have been created. However, these tools are limited to act at a fixed granularity, being able to replicate, relocate and provide access to extra resources only at the level of the entire microservice, even when only one of its parts actually demands more resources. In this paper, we propose the use of the concepts of adaptive component models, emergent microservices, and self-distributing systems to explicitly define the internal micro-architecture of microservices. In this approach, a microservice is built as a dynamic configuration of components, which can be seamlessly adapted and distributed on top of an elastic cloud infrastructure by the underlying platform. We evaluate the benefits of the approach by exploring different scenarios that entail the use of dynamic adaptation and self-distribution to perform vertical and horizontal scaling of microservices at a fine granularity. We analyze the involved tradeoffs and discuss how the approach can be further explored.",Runtime Microservice Self-distribution for Fine-grain Resource Allocation,"The development of systems using microservices as buildingblocks have gained! major popularity in the industry in the past few years. Widely used services, such as Netflix and Uber, have been built entirely as microservice architectures. Due to the modularity and self-containedness of microservices, coupled with the use of elastic deployment infrastructures, a number of tools to assist the scalability of such systems have been created. However, these tools are limited to act at a fixed granularity, being able to replicate, relocate and provide access to extra resources only at the level of the entire microservice, even when only one of its parts actually demands more resources. In this paper, we propose the use of the concepts of adaptive component models, emergent microservices, and self-distributing systems to explicitly define the internal micro-architecture of microservices. In this approach, a microservice is built as a dynamic configuration of components, which can be seamlessly adapted and distributed on top of an elastic cloud infrastructure by the underlying platform. We evaluate the benefits of the approach by exploring different scenarios that entail the use of dynamic adaptation and self-distribution to perform vertical and horizontal scaling of microservices at a fine granularity. We analyze the involved tradeoffs and discuss how the approach can be further explored.",IEEE conference,no,"['runtime', 'resource', 'allocation', 'development', 'using', 'gained', 'major', 'popularity', 'industry', 'past', 'year', 'widely', 'used', 'netflix', 'built', 'due', 'modularity', 'coupled', 'use', 'elastic', 'deployment', 'infrastructure', 'number', 'tool', 'assist', 'scalability', 'created', 'however', 'tool', 'limited', 'act', 'fixed', 'granularity', 'able', 'provide', 'access', 'extra', 'resource', 'level', 'entire', 'even', 'one', 'part', 'actually', 'demand', 'resource', 'paper', 'propose', 'use', 'concept', 'adaptive', 'model', 'define', 'internal', 'built', 'dynamic', 'configuration', 'seamlessly', 'adapted', 'distributed', 'top', 'elastic', 'infrastructure', 'underlying', 'platform', 'evaluate', 'benefit', 'exploring', 'different', 'scenario', 'use', 'dynamic', 'adaptation', 'perform', 'vertical', 'horizontal', 'scaling', 'fine', 'granularity', 'analyze', 'involved', 'tradeoff', 'discus', 'explored']"
"Development of the Concept and Architecture of an Automated System for Updating Physical Knowledge for Information Support of Search Design For developing an automated system for updating physical knowledge for information support of search design, it is necessary to choose a technology stack that would meet the implementation requirements. In view of the sanctions currently imposed on the Russian Federation, it is worth considering mainly open projects and/or domestic developments. We will highlight the main criteria that it is desirable to take into account when designing the architecture of an automated system to support the synthesis of new technical systems and technologies: (a) ability to store and process large amounts of data; (b) unification access for all data analysis procedures; (c) maximum automation of all stages; (d) modularity of the structure, focus on the expansion of functionality; (e) focus on open source solutions and software of domestic manufacturers, excluding rigid binding to paid foreign solutions. As a result of the work done, various aspects of the implementation of the required automated system were analyzed. A review of various software systems and cloud products showed that the concept of building data lakes (Data Lake) in conjunction with the distributed processing tools of the Apache Hadoop ecosystem is used for big data processing. An architecture framework based on a centralized data warehouse and Hadoop components is proposed. It will be possible to increase the functionality of the platform by adding new microservices that connect to the storage and distributed processing tools via the API, as well as using a single web service for managing and displaying data analysis results from these microservices.",Development of the Concept and Architecture of an Automated System for Updating Physical Knowledge for Information Support of Search Design,"For developing an automated system for updating physical knowledge for information support of search design, it is necessary to choose a technology stack that would meet the implementation requirements. In view of the sanctions currently imposed on the Russian Federation, it is worth considering mainly open projects and/or domestic developments. We will highlight the main criteria that it is desirable to take into account when designing the architecture of an automated system to support the synthesis of new technical systems and technologies: (a) ability to store and process large amounts of data; (b) unification access for all data analysis procedures; (c) maximum automation of all stages; (d) modularity of the structure, focus on the expansion of functionality; (e) focus on open source solutions and software of domestic manufacturers, excluding rigid binding to paid foreign solutions. As a result of the work done, various aspects of the implementation of the required automated system were analyzed. A review of various software systems and cloud products showed that the concept of building data lakes (Data Lake) in conjunction with the distributed processing tools of the Apache Hadoop ecosystem is used for big data processing. An architecture framework based on a centralized data warehouse and Hadoop components is proposed. It will be possible to increase the functionality of the platform by adding new microservices that connect to the storage and distributed processing tools via the API, as well as using a single web service for managing and displaying data analysis results from these microservices.",IEEE conference,no,"['development', 'concept', 'automated', 'updating', 'physical', 'knowledge', 'information', 'support', 'search', 'design', 'developing', 'automated', 'updating', 'physical', 'knowledge', 'information', 'support', 'search', 'design', 'necessary', 'choose', 'technology', 'stack', 'would', 'meet', 'implementation', 'requirement', 'view', 'currently', 'considering', 'mainly', 'open', 'project', 'development', 'highlight', 'main', 'criterion', 'desirable', 'take', 'account', 'designing', 'automated', 'support', 'synthesis', 'new', 'technical', 'technology', 'ability', 'store', 'process', 'large', 'amount', 'b', 'access', 'analysis', 'procedure', 'c', 'maximum', 'automation', 'stage', 'modularity', 'structure', 'focus', 'expansion', 'functionality', 'focus', 'open', 'source', 'solution', 'solution', 'result', 'work', 'done', 'various', 'aspect', 'implementation', 'required', 'automated', 'analyzed', 'review', 'various', 'product', 'showed', 'concept', 'building', 'lake', 'lake', 'distributed', 'processing', 'tool', 'apache', 'ecosystem', 'used', 'big', 'processing', 'framework', 'based', 'centralized', 'proposed', 'possible', 'increase', 'functionality', 'platform', 'adding', 'new', 'connect', 'storage', 'distributed', 'processing', 'tool', 'via', 'api', 'well', 'using', 'single', 'web', 'managing', 'analysis', 'result']"
"RAMSES: an Artifact Exemplar for Engineering Self-Adaptive Microservice Applications This paper introduces RAMSES, an exemplar tailored for both practitioners and researchers working on self-adaptive microservice applications. By emphasizing a clear separation of concerns between the application and its adaptation logic, RAMSES realizes a reusable autonomic manager that implements a MAPE-K feedback loop whose components are microservices themselves. Its primary focus lies in addressing user-defined QoS attributes at runtime, like availability and performance. To illustrate its usage, we provide a practical example showing its mechanics in an e-food microservice application. Initial experiments indicate the advantages of utilizing RAMSES, as shown by a comparative analysis of the quality properties of a microservice application with and without self-adaptation.",RAMSES: an Artifact Exemplar for Engineering Self-Adaptive Microservice Applications,"This paper introduces RAMSES, an exemplar tailored for both practitioners and researchers working on self-adaptive microservice applications. By emphasizing a clear separation of concerns between the application and its adaptation logic, RAMSES realizes a reusable autonomic manager that implements a MAPE-K feedback loop whose components are microservices themselves. Its primary focus lies in addressing user-defined QoS attributes at runtime, like availability and performance. To illustrate its usage, we provide a practical example showing its mechanics in an e-food microservice application. Initial experiments indicate the advantages of utilizing RAMSES, as shown by a comparative analysis of the quality properties of a microservice application with and without self-adaptation.",IEEE conference,no,"['ramses', 'artifact', 'engineering', 'paper', 'introduces', 'ramses', 'tailored', 'practitioner', 'researcher', 'working', 'emphasizing', 'clear', 'separation', 'concern', 'adaptation', 'logic', 'ramses', 'realizes', 'reusable', 'autonomic', 'manager', 'implement', 'feedback', 'loop', 'whose', 'primary', 'focus', 'lie', 'addressing', 'qos', 'attribute', 'runtime', 'like', 'availability', 'performance', 'illustrate', 'usage', 'provide', 'practical', 'example', 'showing', 'initial', 'experiment', 'indicate', 'advantage', 'utilizing', 'ramses', 'shown', 'comparative', 'analysis', 'quality', 'property', 'without']"
"Dynamic Micro-Frontends Economic and business related demands of decreasing time to market and efficient production in an ever more efficient manner have manifested themselves in software development as well. They are most visible in the use of streamlined development approaches and production of aggressively reusable components, on both server and client sides of modern applications. On the server side, the modern development is dominated by tendency to use microservice based architectures, while on the client side, the same idea is realized through the use of micro-frontends. Micro-frontend applications represent a natural counterpart to numerous segmented and compartmentalized backend services. One of the issues related to micro-fronted approach is relatively low support for rapid deployment and evolution of individual components. In this paper we present a novel approach that enables fully dynamic use and deployment of micro-frontends, synchronized with their respective micro-services, both in development and in production stages. We also show possible use cases beyond classic scenarios present in existing practice of micro-frontend applications.",Dynamic Micro-Frontends,"Economic and business related demands of decreasing time to market and efficient production in an ever more efficient manner have manifested themselves in software development as well. They are most visible in the use of streamlined development approaches and production of aggressively reusable components, on both server and client sides of modern applications. On the server side, the modern development is dominated by tendency to use microservice based architectures, while on the client side, the same idea is realized through the use of micro-frontends. Micro-frontend applications represent a natural counterpart to numerous segmented and compartmentalized backend services. One of the issues related to micro-fronted approach is relatively low support for rapid deployment and evolution of individual components. In this paper we present a novel approach that enables fully dynamic use and deployment of micro-frontends, synchronized with their respective micro-services, both in development and in production stages. We also show possible use cases beyond classic scenarios present in existing practice of micro-frontend applications.",IEEE conference,no,"['dynamic', 'economic', 'business', 'related', 'demand', 'decreasing', 'time', 'market', 'efficient', 'production', 'ever', 'efficient', 'manner', 'development', 'well', 'use', 'streamlined', 'development', 'production', 'reusable', 'server', 'client', 'side', 'modern', 'server', 'side', 'modern', 'development', 'use', 'based', 'client', 'side', 'idea', 'realized', 'use', 'represent', 'natural', 'counterpart', 'numerous', 'backend', 'one', 'issue', 'related', 'relatively', 'low', 'support', 'rapid', 'deployment', 'evolution', 'individual', 'paper', 'present', 'novel', 'enables', 'fully', 'dynamic', 'use', 'deployment', 'synchronized', 'respective', 'development', 'production', 'stage', 'also', 'show', 'possible', 'use', 'case', 'beyond', 'classic', 'scenario', 'present', 'existing', 'practice']"
"Software-Defined Networking Integrated with Cloud Native and Proxy Mechanism: Detection and Mitigation System for TCP SYN Flooding Attack SDN is a new network architecture that still faces traditional network attacks. Among the attacks, Distributed-Denial-of-Service is one of the most severe attacks, especially the TCP SYN Flooding attack, which has a more significant impact. This paper is mainly to mitigate the impact of the SYN Flood attack and will combine Kubernetes and design a unique component: SDN Controller Manager, which exists in K8s as a microservices. The proxy mechanism is used to resist the SYN Flooding attack, and the K8s feature is further utilized. If the SDN Controller Manager is attacked and the service is terminated abnormally, K8s will automatically create a new SDN Controller Manager component to continue to provide services.",Software-Defined Networking Integrated with Cloud Native and Proxy Mechanism: Detection and Mitigation System for TCP SYN Flooding Attack,"SDN is a new network architecture that still faces traditional network attacks. Among the attacks, Distributed-Denial-of-Service is one of the most severe attacks, especially the TCP SYN Flooding attack, which has a more significant impact. This paper is mainly to mitigate the impact of the SYN Flood attack and will combine Kubernetes and design a unique component: SDN Controller Manager, which exists in K8s as a microservices. The proxy mechanism is used to resist the SYN Flooding attack, and the K8s feature is further utilized. If the SDN Controller Manager is attacked and the service is terminated abnormally, K8s will automatically create a new SDN Controller Manager component to continue to provide services.",IEEE conference,no,"['networking', 'integrated', 'native', 'proxy', 'mechanism', 'detection', 'mitigation', 'tcp', 'syn', 'flooding', 'attack', 'sdn', 'new', 'network', 'still', 'face', 'traditional', 'network', 'attack', 'among', 'attack', 'one', 'severe', 'attack', 'especially', 'tcp', 'syn', 'flooding', 'attack', 'significant', 'impact', 'paper', 'mainly', 'mitigate', 'impact', 'syn', 'attack', 'combine', 'kubernetes', 'design', 'unique', 'sdn', 'controller', 'manager', 'exists', 'proxy', 'mechanism', 'used', 'syn', 'flooding', 'attack', 'feature', 'utilized', 'sdn', 'controller', 'manager', 'automatically', 'create', 'new', 'sdn', 'controller', 'manager', 'continue', 'provide']"
"Automated Testing and Resilience of Microservice’s Network-link using Istio Service Mesh Microservices technology has gained considerable popularity in software design to deploy complex applications in the form of micro-modular microservice components. Each service is implemented as an autonomous system, and its internal constituent data can be accessed via a network interface. Such architecture increases the complexity of the network because each module is a separate entity for development and operations. A fault in any service affects the operation of another service and could completely break the application. It is, therefore, necessary to create a framework for the systematic testing and resilience of the network link in microservices, independent of the programming language and business logic. It helps the network administrator track the cause of the fault. In this paper, we have shown the use of the service mesh Istio to monitor communication between microservices and to develop automated testing and resilience. Istio provides various types of fault injectors for communication links between services. A Locust load testing tool is used to exert a microservice load. The faulty link is located via the Jaeger and Grafana dashboard within the Istio frame. For resilience or correction of the fault, a new connection is temporarily established between the affected microservice by deploying redundant services. In addition, microservices scaling and the implementation of the circuit breaker have been shown to remedy network congestion. The setup is demonstrated in the Kubernetes cluster with the Hipster shop e-commerce application.",Automated Testing and Resilience of Microservice’s Network-link using Istio Service Mesh,"Microservices technology has gained considerable popularity in software design to deploy complex applications in the form of micro-modular microservice components. Each service is implemented as an autonomous system, and its internal constituent data can be accessed via a network interface. Such architecture increases the complexity of the network because each module is a separate entity for development and operations. A fault in any service affects the operation of another service and could completely break the application. It is, therefore, necessary to create a framework for the systematic testing and resilience of the network link in microservices, independent of the programming language and business logic. It helps the network administrator track the cause of the fault. In this paper, we have shown the use of the service mesh Istio to monitor communication between microservices and to develop automated testing and resilience. Istio provides various types of fault injectors for communication links between services. A Locust load testing tool is used to exert a microservice load. The faulty link is located via the Jaeger and Grafana dashboard within the Istio frame. For resilience or correction of the fault, a new connection is temporarily established between the affected microservice by deploying redundant services. In addition, microservices scaling and the implementation of the circuit breaker have been shown to remedy network congestion. The setup is demonstrated in the Kubernetes cluster with the Hipster shop e-commerce application.",IEEE conference,no,"['automated', 'testing', 'resilience', 'using', 'istio', 'mesh', 'technology', 'gained', 'popularity', 'design', 'deploy', 'complex', 'form', 'implemented', 'autonomous', 'internal', 'constituent', 'accessed', 'via', 'network', 'interface', 'increase', 'complexity', 'network', 'module', 'separate', 'entity', 'development', 'operation', 'fault', 'affect', 'operation', 'another', 'could', 'completely', 'break', 'therefore', 'necessary', 'create', 'framework', 'systematic', 'testing', 'resilience', 'network', 'link', 'independent', 'programming', 'language', 'business', 'logic', 'help', 'network', 'administrator', 'track', 'cause', 'fault', 'paper', 'shown', 'use', 'mesh', 'istio', 'monitor', 'communication', 'develop', 'automated', 'testing', 'resilience', 'istio', 'provides', 'various', 'type', 'fault', 'communication', 'link', 'load', 'testing', 'tool', 'used', 'load', 'faulty', 'link', 'located', 'via', 'jaeger', 'grafana', 'dashboard', 'within', 'istio', 'frame', 'resilience', 'fault', 'new', 'connection', 'established', 'affected', 'deploying', 'redundant', 'addition', 'scaling', 'implementation', 'circuit', 'shown', 'network', 'congestion', 'setup', 'demonstrated', 'kubernetes', 'cluster', 'shop']"
"Microservices Upgrade in Clouds: Dynamic Management of Version Dependencies and User Load In today's cloud computing environments, where scalability, agility, and resiliency are paramount, microservices architecture stands out as a fundamental keystone of modern software development. While microservices are designed as independent components communicating through well-defined APIs, maintaining and upgrading them pose unique challenges, including version compatibility, dependency management, and service continuity. These challenges become intricate when multiple instances of a specific microservice are deployed, utilizing load balancing to distribute users and offering different functionalities simultaneously. This paper proposes a heuristic algorithm to address the microservices upgrading problem. The proposed algorithm migrates users gradually and effectively by managing version dependencies, user load, considering propagation impact, multiple instances, and resource constraints. The simulation results demonstrate the superiority of our algorithm over existing benchmarks in terms of resource usage cost and the number of new version instances.",Microservices Upgrade in Clouds: Dynamic Management of Version Dependencies and User Load,"In today's cloud computing environments, where scalability, agility, and resiliency are paramount, microservices architecture stands out as a fundamental keystone of modern software development. While microservices are designed as independent components communicating through well-defined APIs, maintaining and upgrading them pose unique challenges, including version compatibility, dependency management, and service continuity. These challenges become intricate when multiple instances of a specific microservice are deployed, utilizing load balancing to distribute users and offering different functionalities simultaneously. This paper proposes a heuristic algorithm to address the microservices upgrading problem. The proposed algorithm migrates users gradually and effectively by managing version dependencies, user load, considering propagation impact, multiple instances, and resource constraints. The simulation results demonstrate the superiority of our algorithm over existing benchmarks in terms of resource usage cost and the number of new version instances.",IEEE conference,no,"['upgrade', 'dynamic', 'management', 'version', 'dependency', 'user', 'load', 'today', 'computing', 'environment', 'scalability', 'agility', 'resiliency', 'paramount', 'stand', 'fundamental', 'modern', 'development', 'designed', 'independent', 'communicating', 'apis', 'maintaining', 'upgrading', 'pose', 'unique', 'challenge', 'including', 'version', 'compatibility', 'dependency', 'management', 'continuity', 'challenge', 'become', 'intricate', 'multiple', 'instance', 'specific', 'deployed', 'utilizing', 'load', 'balancing', 'distribute', 'user', 'offering', 'different', 'functionality', 'simultaneously', 'paper', 'proposes', 'heuristic', 'algorithm', 'address', 'upgrading', 'problem', 'proposed', 'algorithm', 'user', 'gradually', 'effectively', 'managing', 'version', 'dependency', 'user', 'load', 'considering', 'propagation', 'impact', 'multiple', 'instance', 'resource', 'constraint', 'simulation', 'result', 'demonstrate', 'algorithm', 'existing', 'benchmark', 'term', 'resource', 'usage', 'cost', 'number', 'new', 'version', 'instance']"
"Network Security Mechanism Optimization Strategy in Cloud Native Scenario Risk assessors and managers face many difficult challenges related to the new network system. These challenges include the continuous changes in the nature of network systems caused by technological progress, their distribution in the fields of physics, information and social cognition, and the complex network structure that usually includes thousands of nodes. Here, we review the probability and risk-based decision technology applied to network systems, and conclude that the existing methods can not solve all the components of the risk assessment triad (threat, vulnerability, consequence), and lack the ability to integrate across multiple areas of network systems, thus providing guidance for enhancing network security. We propose a cloud native security chain architecture and network topology reconstruction technology link based on the full link of microservices. The network security performance is quantified by multi-layer filtering mechanism and setting different fitness index functions. The method proposed in this paper solves the problems of packet loss, load balancing and distributed delay of network security mechanism in the global network to a certain extent.",Network Security Mechanism Optimization Strategy in Cloud Native Scenario,"Risk assessors and managers face many difficult challenges related to the new network system. These challenges include the continuous changes in the nature of network systems caused by technological progress, their distribution in the fields of physics, information and social cognition, and the complex network structure that usually includes thousands of nodes. Here, we review the probability and risk-based decision technology applied to network systems, and conclude that the existing methods can not solve all the components of the risk assessment triad (threat, vulnerability, consequence), and lack the ability to integrate across multiple areas of network systems, thus providing guidance for enhancing network security. We propose a cloud native security chain architecture and network topology reconstruction technology link based on the full link of microservices. The network security performance is quantified by multi-layer filtering mechanism and setting different fitness index functions. The method proposed in this paper solves the problems of packet loss, load balancing and distributed delay of network security mechanism in the global network to a certain extent.",IEEE conference,no,"['network', 'security', 'mechanism', 'optimization', 'strategy', 'native', 'scenario', 'risk', 'manager', 'face', 'many', 'difficult', 'challenge', 'related', 'new', 'network', 'challenge', 'include', 'continuous', 'change', 'nature', 'network', 'caused', 'technological', 'progress', 'distribution', 'field', 'information', 'social', 'cognition', 'complex', 'network', 'structure', 'usually', 'includes', 'thousand', 'node', 'review', 'probability', 'decision', 'technology', 'applied', 'network', 'conclude', 'existing', 'method', 'solve', 'risk', 'assessment', 'threat', 'vulnerability', 'lack', 'ability', 'integrate', 'across', 'multiple', 'area', 'network', 'thus', 'providing', 'guidance', 'enhancing', 'network', 'security', 'propose', 'native', 'security', 'chain', 'network', 'topology', 'technology', 'link', 'based', 'full', 'link', 'network', 'security', 'performance', 'mechanism', 'setting', 'different', 'function', 'method', 'proposed', 'paper', 'solves', 'problem', 'packet', 'loss', 'load', 'balancing', 'distributed', 'delay', 'network', 'security', 'mechanism', 'global', 'network', 'certain', 'extent']"
"A Retrospective Engineering Analysis of Human-AI Teams Using the Sidekick Principles The speed of development of Artificial Intelligence (AI) capabilities outpaces that of human systems engineering, particularly for the integration of human-AI teams (HAT) in production-level software. The emergence of frameworks for the principled design and development of hybrid systems offers opportunities to close this gap: They can help identify which common HAT components should be built and matured to accelerate the engineering of such hybrid systems. Leveraging the sidekick principles of human-AI teaming in a review of recent efforts, we identified a prioritized list of system requirements for reusable HAT components. We share these insights with a specific emphasis on the analytical microservices we believe are key to instantiating the sidekick principles.",A Retrospective Engineering Analysis of Human-AI Teams Using the Sidekick Principles,"The speed of development of Artificial Intelligence (AI) capabilities outpaces that of human systems engineering, particularly for the integration of human-AI teams (HAT) in production-level software. The emergence of frameworks for the principled design and development of hybrid systems offers opportunities to close this gap: They can help identify which common HAT components should be built and matured to accelerate the engineering of such hybrid systems. Leveraging the sidekick principles of human-AI teaming in a review of recent efforts, we identified a prioritized list of system requirements for reusable HAT components. We share these insights with a specific emphasis on the analytical microservices we believe are key to instantiating the sidekick principles.",IEEE conference,no,"['engineering', 'analysis', 'team', 'using', 'sidekick', 'principle', 'speed', 'development', 'artificial', 'intelligence', 'ai', 'capability', 'human', 'engineering', 'particularly', 'integration', 'team', 'hat', 'emergence', 'framework', 'design', 'development', 'hybrid', 'offer', 'opportunity', 'close', 'gap', 'help', 'identify', 'common', 'hat', 'built', 'accelerate', 'engineering', 'hybrid', 'leveraging', 'sidekick', 'principle', 'review', 'recent', 'effort', 'identified', 'list', 'requirement', 'reusable', 'hat', 'share', 'insight', 'specific', 'emphasis', 'analytical', 'believe', 'key', 'sidekick', 'principle']"
"A microservices architecture for collaborative document editing enhanced with face recognition Modern web applications can now provide rich and dynamic user experiences, such as allowing multiple users to collaboratively edit rich-text documents in real-time from multiple devices. Application architectures are evolving to support the development and deployment of such interactive functionality by decoupling software components into microservices. This paper introduces the architecture and the implementation of a collaborative rich-text editor that makes use of microservices to enable and enhance its scalable co-editing functionality. This includes microservices for synchronizing unstructured text using operational transformations, for chat functionality, and for detecting and recognizing faces in images added to the editor. The architecture makes use of Docker to allow for the development and testing of individual services as separate containers enabling seamless deployment across the available network of computers and other computing devices. The system will be demonstrated by showing how microservices make it possible for multiple users to co-edit a document where images containing faces are added and recognized as part of the document content, thereby supporting the document creation process.",A microservices architecture for collaborative document editing enhanced with face recognition,"Modern web applications can now provide rich and dynamic user experiences, such as allowing multiple users to collaboratively edit rich-text documents in real-time from multiple devices. Application architectures are evolving to support the development and deployment of such interactive functionality by decoupling software components into microservices. This paper introduces the architecture and the implementation of a collaborative rich-text editor that makes use of microservices to enable and enhance its scalable co-editing functionality. This includes microservices for synchronizing unstructured text using operational transformations, for chat functionality, and for detecting and recognizing faces in images added to the editor. The architecture makes use of Docker to allow for the development and testing of individual services as separate containers enabling seamless deployment across the available network of computers and other computing devices. The system will be demonstrated by showing how microservices make it possible for multiple users to co-edit a document where images containing faces are added and recognized as part of the document content, thereby supporting the document creation process.",IEEE conference,no,"['collaborative', 'document', 'enhanced', 'face', 'recognition', 'modern', 'web', 'provide', 'rich', 'dynamic', 'user', 'experience', 'allowing', 'multiple', 'user', 'document', 'multiple', 'device', 'evolving', 'support', 'development', 'deployment', 'interactive', 'functionality', 'decoupling', 'paper', 'introduces', 'implementation', 'collaborative', 'make', 'use', 'enable', 'enhance', 'scalable', 'functionality', 'includes', 'text', 'using', 'operational', 'transformation', 'functionality', 'detecting', 'face', 'image', 'added', 'make', 'use', 'docker', 'allow', 'development', 'testing', 'individual', 'separate', 'container', 'enabling', 'seamless', 'deployment', 'across', 'available', 'network', 'computer', 'computing', 'device', 'demonstrated', 'showing', 'make', 'possible', 'multiple', 'user', 'document', 'image', 'containing', 'face', 'added', 'recognized', 'part', 'document', 'content', 'thereby', 'supporting', 'document', 'creation', 'process']"
"Synthetic to Real-World: Insights on Microservices-Based Application Benchmarks This paper focuses on implementing a realis-tic microservice-based application from DeathStarBench into μBench and the challenges associated with it. Unlike traditional monolithic applications, microservice apps comprise multiple smaller components that are comparatively complex. This makes benchmarking essential. Benchmarking is a process of evaluating and comparing the performance of a system, such as efficiency, effectiveness, quality, or cost, to assess how well a particular entity is performing compared to a reference point, often referred to as a benchmark. A benchmarking tool that employs near real-world applications, extending beyond the capabilities of the existing tools. The inclusion of configuring the microservices from scratch allows for a more comprehensive understanding of application performance, which is crucial for today's complex cloud-based applications [1]. Through synthetic benchmarking, μBench simulates real-world conditions, offering a more com-plete performance analysis. In this paper, we expand the tool μBench to effectively demonstrate its proficiency in deploying and benchmarking a diverse range of microservice applications by mimicking real-world applications like DeathStarBench and Teastore, analysing the performance and resource utilisation through various tools like Kiali, Prometheus and Jaeger.",Synthetic to Real-World: Insights on Microservices-Based Application Benchmarks,"This paper focuses on implementing a realis-tic microservice-based application from DeathStarBench into μBench and the challenges associated with it. Unlike traditional monolithic applications, microservice apps comprise multiple smaller components that are comparatively complex. This makes benchmarking essential. Benchmarking is a process of evaluating and comparing the performance of a system, such as efficiency, effectiveness, quality, or cost, to assess how well a particular entity is performing compared to a reference point, often referred to as a benchmark. A benchmarking tool that employs near real-world applications, extending beyond the capabilities of the existing tools. The inclusion of configuring the microservices from scratch allows for a more comprehensive understanding of application performance, which is crucial for today's complex cloud-based applications [1]. Through synthetic benchmarking, μBench simulates real-world conditions, offering a more com-plete performance analysis. In this paper, we expand the tool μBench to effectively demonstrate its proficiency in deploying and benchmarking a diverse range of microservice applications by mimicking real-world applications like DeathStarBench and Teastore, analysing the performance and resource utilisation through various tools like Kiali, Prometheus and Jaeger.",IEEE conference,no,"['synthetic', 'insight', 'benchmark', 'paper', 'focus', 'implementing', 'μbench', 'challenge', 'associated', 'unlike', 'traditional', 'monolithic', 'apps', 'comprise', 'multiple', 'smaller', 'complex', 'make', 'benchmarking', 'essential', 'benchmarking', 'process', 'evaluating', 'comparing', 'performance', 'efficiency', 'effectiveness', 'quality', 'cost', 'assess', 'well', 'particular', 'entity', 'performing', 'compared', 'reference', 'point', 'often', 'referred', 'benchmark', 'benchmarking', 'tool', 'employ', 'near', 'extending', 'beyond', 'capability', 'existing', 'tool', 'inclusion', 'configuring', 'scratch', 'allows', 'comprehensive', 'understanding', 'performance', 'crucial', 'today', 'complex', 'synthetic', 'benchmarking', 'μbench', 'condition', 'offering', 'performance', 'analysis', 'paper', 'tool', 'μbench', 'effectively', 'demonstrate', 'deploying', 'benchmarking', 'diverse', 'range', 'like', 'performance', 'resource', 'various', 'tool', 'like', 'prometheus', 'jaeger']"
"MV4MS: A Spring Cloud based Framework for the Co-Deployment of Multi-Version Microservices Agile development and the loose coupling of microservices, make continuous delivery/deployment of large, complex service systems become much easier. The microservices are upgraded and released independently and have their own independent version trees. For compatibility, multiple versions of one microservice are to be deployed in the same system to offer slightly different functionalities to different users simultaneously. However, loosely-coupling does not mean multiple microservices keep absolutely independent but there are more or less dependencies among them, and such dependencies occur not only on functionalities but also on the version issue, too. Existing microservice frameworks have no enough capability for multi-version co-deployment and the corresponding version-oriented dependency management. In this paper, a Spring Cloud based framework called MV4MS is introduced for this challenge. It extracts version information from source codes of microservices, builds version dependencies, packs and deploys requisite versions of microservices, and routes user requests to desired versions at run-time. Architecture of MV4MS and detailed design of its components are elaborately introduced. Experiments are conducted in AWS cloud environment, and results show that our framework could reduce the complexity of multi-version microservice co-deployment and ensure the correctness of routing between multi-version microservice.",MV4MS: A Spring Cloud based Framework for the Co-Deployment of Multi-Version Microservices,"Agile development and the loose coupling of microservices, make continuous delivery/deployment of large, complex service systems become much easier. The microservices are upgraded and released independently and have their own independent version trees. For compatibility, multiple versions of one microservice are to be deployed in the same system to offer slightly different functionalities to different users simultaneously. However, loosely-coupling does not mean multiple microservices keep absolutely independent but there are more or less dependencies among them, and such dependencies occur not only on functionalities but also on the version issue, too. Existing microservice frameworks have no enough capability for multi-version co-deployment and the corresponding version-oriented dependency management. In this paper, a Spring Cloud based framework called MV4MS is introduced for this challenge. It extracts version information from source codes of microservices, builds version dependencies, packs and deploys requisite versions of microservices, and routes user requests to desired versions at run-time. Architecture of MV4MS and detailed design of its components are elaborately introduced. Experiments are conducted in AWS cloud environment, and results show that our framework could reduce the complexity of multi-version microservice co-deployment and ensure the correctness of routing between multi-version microservice.",IEEE conference,no,"['spring', 'based', 'framework', 'agile', 'development', 'coupling', 'make', 'continuous', 'large', 'complex', 'become', 'much', 'easier', 'upgraded', 'released', 'independently', 'independent', 'version', 'tree', 'compatibility', 'multiple', 'version', 'one', 'deployed', 'offer', 'different', 'functionality', 'different', 'user', 'simultaneously', 'however', 'mean', 'multiple', 'keep', 'independent', 'less', 'dependency', 'among', 'dependency', 'occur', 'functionality', 'also', 'version', 'issue', 'existing', 'framework', 'enough', 'capability', 'corresponding', 'dependency', 'management', 'paper', 'spring', 'based', 'framework', 'called', 'introduced', 'challenge', 'extract', 'version', 'information', 'source', 'code', 'build', 'version', 'dependency', 'deploys', 'version', 'route', 'user', 'request', 'desired', 'version', 'detailed', 'design', 'introduced', 'experiment', 'conducted', 'aws', 'environment', 'result', 'show', 'framework', 'could', 'reduce', 'complexity', 'ensure', 'correctness', 'routing']"
"A Framework for Monitoring Microservice-Oriented Cloud Applications in Heterogeneous Virtualization Environments Microservices have emerged as a new approach for developing and deploying cloud applications that require higher levels of agility, scale, and reliability. To this end, a microservice-based cloud application architecture advocates decomposition of monolithic application components into independent software components called ""microservices"". As the independent microservices can be developed, deployed, and updated independently of each other, it leads to complex run-time performance monitoring and management challenges. To solve this problem, we propose a generic monitoring framework, Multi-microservices Multi-virtualization Multi-cloud (M3) that monitors the performance of microservices deployed across heterogeneous virtualization platforms in a multi-cloud environment. We validated the efficacy and efficiency of M3 using a Book-Shop application executing across AWS and Azure.",A Framework for Monitoring Microservice-Oriented Cloud Applications in Heterogeneous Virtualization Environments,"Microservices have emerged as a new approach for developing and deploying cloud applications that require higher levels of agility, scale, and reliability. To this end, a microservice-based cloud application architecture advocates decomposition of monolithic application components into independent software components called ""microservices"". As the independent microservices can be developed, deployed, and updated independently of each other, it leads to complex run-time performance monitoring and management challenges. To solve this problem, we propose a generic monitoring framework, Multi-microservices Multi-virtualization Multi-cloud (M3) that monitors the performance of microservices deployed across heterogeneous virtualization platforms in a multi-cloud environment. We validated the efficacy and efficiency of M3 using a Book-Shop application executing across AWS and Azure.",IEEE conference,no,"['framework', 'monitoring', 'heterogeneous', 'virtualization', 'environment', 'emerged', 'new', 'developing', 'deploying', 'require', 'higher', 'level', 'agility', 'scale', 'reliability', 'end', 'decomposition', 'monolithic', 'independent', 'called', 'independent', 'developed', 'deployed', 'updated', 'independently', 'lead', 'complex', 'performance', 'monitoring', 'management', 'challenge', 'solve', 'problem', 'propose', 'generic', 'monitoring', 'framework', 'monitor', 'performance', 'deployed', 'across', 'heterogeneous', 'virtualization', 'platform', 'environment', 'validated', 'efficacy', 'efficiency', 'using', 'executing', 'across', 'aws', 'azure']"
"Infrastructure-as-Code for Data-Intensive Architectures: A Model-Driven Development Approach As part of the DevOps tactics, Infrastructure-as-Code (IaC) provides the ability to create, configure, and manage complex infrastructures by means of executable code. Writing IaC, however, is not an easy task, since it requires blending different infrastructure programming languages and abstractions, each specialized on a particular aspect of infrastructure creation, configuration, and management. Moreover, the more the architectures become large and complex (e.g. Data-Intensive or Microservice-based architectures), the more dire the need of IaC becomes. The goal of this paper is to exploit Model-Driven Engineering (MDE) to create language-agnostic models that are then automatically transformed into IaC. We focus on the domain of Data-Intensive Applications as these typically exploit complex infrastructures which demand sophisticated and fine-grained configuration and re-configuration - we show that, through our approach, called DICER, it is possible to create complex IaC with significant amounts of time savings, both in IaC design as well as deployment and re-deployment times.",Infrastructure-as-Code for Data-Intensive Architectures: A Model-Driven Development Approach,"As part of the DevOps tactics, Infrastructure-as-Code (IaC) provides the ability to create, configure, and manage complex infrastructures by means of executable code. Writing IaC, however, is not an easy task, since it requires blending different infrastructure programming languages and abstractions, each specialized on a particular aspect of infrastructure creation, configuration, and management. Moreover, the more the architectures become large and complex (e.g. Data-Intensive or Microservice-based architectures), the more dire the need of IaC becomes. The goal of this paper is to exploit Model-Driven Engineering (MDE) to create language-agnostic models that are then automatically transformed into IaC. We focus on the domain of Data-Intensive Applications as these typically exploit complex infrastructures which demand sophisticated and fine-grained configuration and re-configuration - we show that, through our approach, called DICER, it is possible to create complex IaC with significant amounts of time savings, both in IaC design as well as deployment and re-deployment times.",IEEE conference,no,"['development', 'part', 'devops', 'tactic', 'iac', 'provides', 'ability', 'create', 'configure', 'manage', 'complex', 'infrastructure', 'mean', 'executable', 'code', 'writing', 'iac', 'however', 'easy', 'task', 'since', 'requires', 'different', 'infrastructure', 'programming', 'language', 'abstraction', 'specialized', 'particular', 'aspect', 'infrastructure', 'creation', 'configuration', 'management', 'moreover', 'become', 'large', 'complex', 'need', 'iac', 'becomes', 'goal', 'paper', 'exploit', 'engineering', 'create', 'model', 'automatically', 'transformed', 'iac', 'focus', 'domain', 'typically', 'exploit', 'complex', 'infrastructure', 'demand', 'sophisticated', 'configuration', 'show', 'called', 'possible', 'create', 'complex', 'iac', 'significant', 'amount', 'time', 'saving', 'iac', 'design', 'well', 'deployment', 'time']"
"Easily Designing and Deploying AI enabled Network and Telecom services Currently, there do not exist any open-source systems that offer streamlined and easy development and productionalization of AI/ML enabled Intelligent Network and Telecom services. This is a big problem the Network operators/Service providers face today even though Network Function Virtualization (NFV) and Software Defined Networking (SDN) have become ubiquitous and the Next Generation networks aim to be more softwarized and AI-driven. This paper aims to show how to quickly and easily design Network, Telecom and Network Security services and deploy them into a containerized cloud environment. This paper also shows how to make the Network/Telecom services AI/ML enabled and deploy them in the same way into the containerized cloud environment. We will show using ONAP (an open-source whitebox Network Operating System and management platform) and Acumos (open-source AI platform for creation, sharing and management of AI models and solutions), and specifically using their DCAEMOD and Acumos Adapter components, that this is very easy to do. To serve as an example, we will create a Network service to analyze and classify malicious network traffic. Using the same framework and tools, we will deploy the created service as a set of communicating, containerized microservices into a Network Operating system and Management platform like ONAP which is cloud-agnostic and can be run on any cloud. The same created service can also be deployed directly into any other OSS or on any other cloud platform.",Easily Designing and Deploying AI enabled Network and Telecom services,"Currently, there do not exist any open-source systems that offer streamlined and easy development and productionalization of AI/ML enabled Intelligent Network and Telecom services. This is a big problem the Network operators/Service providers face today even though Network Function Virtualization (NFV) and Software Defined Networking (SDN) have become ubiquitous and the Next Generation networks aim to be more softwarized and AI-driven. This paper aims to show how to quickly and easily design Network, Telecom and Network Security services and deploy them into a containerized cloud environment. This paper also shows how to make the Network/Telecom services AI/ML enabled and deploy them in the same way into the containerized cloud environment. We will show using ONAP (an open-source whitebox Network Operating System and management platform) and Acumos (open-source AI platform for creation, sharing and management of AI models and solutions), and specifically using their DCAEMOD and Acumos Adapter components, that this is very easy to do. To serve as an example, we will create a Network service to analyze and classify malicious network traffic. Using the same framework and tools, we will deploy the created service as a set of communicating, containerized microservices into a Network Operating system and Management platform like ONAP which is cloud-agnostic and can be run on any cloud. The same created service can also be deployed directly into any other OSS or on any other cloud platform.",IEEE conference,no,"['easily', 'designing', 'deploying', 'ai', 'enabled', 'network', 'telecom', 'currently', 'exist', 'offer', 'streamlined', 'easy', 'development', 'enabled', 'intelligent', 'network', 'telecom', 'big', 'problem', 'network', 'provider', 'face', 'today', 'even', 'though', 'network', 'function', 'virtualization', 'nfv', 'defined', 'networking', 'sdn', 'become', 'ubiquitous', 'next', 'generation', 'network', 'aim', 'paper', 'aim', 'show', 'quickly', 'easily', 'design', 'network', 'telecom', 'network', 'security', 'deploy', 'containerized', 'environment', 'paper', 'also', 'show', 'make', 'enabled', 'deploy', 'way', 'containerized', 'environment', 'show', 'using', 'network', 'operating', 'management', 'platform', 'acumos', 'ai', 'platform', 'creation', 'sharing', 'management', 'ai', 'model', 'solution', 'specifically', 'using', 'acumos', 'adapter', 'easy', 'serve', 'example', 'create', 'network', 'analyze', 'classify', 'network', 'traffic', 'using', 'framework', 'tool', 'deploy', 'created', 'set', 'communicating', 'containerized', 'network', 'operating', 'management', 'platform', 'like', 'run', 'created', 'also', 'deployed', 'directly', 'os', 'platform']"
"Dynamic Analysis Pipeline in Real Time Monitoring Scenario Social networks offer researchers a unique opportunity to study human communication and social phenomena on an unprecedented scale. However, the variability in the amount of data generated at different times poses a challenge to research in this area. This paper presents an analysis pipeline that uses Twitter data to efficiently process and analyze social media posts in real time. It does not require resources to be designed for maximum load. The approach is based on three key components: implementing analysis processes as independent microservices, using a publish-subscribe communication system, and implementing automatic scaling mechanisms. These factors enable a flexible, robust, and scalable analysis pipeline. It can dynamically adapt to changing workloads and ensure optimal resource utilization.",Dynamic Analysis Pipeline in Real Time Monitoring Scenario,"Social networks offer researchers a unique opportunity to study human communication and social phenomena on an unprecedented scale. However, the variability in the amount of data generated at different times poses a challenge to research in this area. This paper presents an analysis pipeline that uses Twitter data to efficiently process and analyze social media posts in real time. It does not require resources to be designed for maximum load. The approach is based on three key components: implementing analysis processes as independent microservices, using a publish-subscribe communication system, and implementing automatic scaling mechanisms. These factors enable a flexible, robust, and scalable analysis pipeline. It can dynamically adapt to changing workloads and ensure optimal resource utilization.",IEEE conference,no,"['dynamic', 'analysis', 'pipeline', 'real', 'time', 'monitoring', 'scenario', 'social', 'network', 'offer', 'researcher', 'unique', 'opportunity', 'study', 'human', 'communication', 'social', 'phenomenon', 'unprecedented', 'scale', 'however', 'variability', 'amount', 'generated', 'different', 'time', 'pose', 'challenge', 'research', 'area', 'paper', 'present', 'analysis', 'pipeline', 'us', 'twitter', 'efficiently', 'process', 'analyze', 'social', 'medium', 'post', 'real', 'time', 'require', 'resource', 'designed', 'maximum', 'load', 'based', 'three', 'key', 'implementing', 'analysis', 'process', 'independent', 'using', 'communication', 'implementing', 'automatic', 'scaling', 'mechanism', 'factor', 'enable', 'flexible', 'robust', 'scalable', 'analysis', 'pipeline', 'dynamically', 'adapt', 'changing', 'workload', 'ensure', 'optimal', 'resource', 'utilization']"
"CHESS: A Framework for Evaluation of Self-Adaptive Systems Based on Chaos Engineering There is an increasing need to assess the correct behavior of self-adaptive and self-healing systems due to their adoption in critical and highly dynamic environments. However, there is a lack of systematic evaluation methods for self-adaptive and self-healing systems. We proposed CHESS, a novel approach to address this gap by evaluating self-adaptive and self-healing systems through fault injection based on chaos engineering (CE).The artifact presented in this paper provides an extensive overview of the use of CHESS through two microservice-based case studies: a smart office case study and an existing demo application called Yelb. It comes with a managing system service, a self-monitoring service, as well as five fault injection scenarios covering infrastructure faults and functional faults. Each of these components can be easily extended or replaced to adopt the CHESS approach to a new case study, help explore its promises and limitations, and identify directions for future research.",CHESS: A Framework for Evaluation of Self-Adaptive Systems Based on Chaos Engineering,"There is an increasing need to assess the correct behavior of self-adaptive and self-healing systems due to their adoption in critical and highly dynamic environments. However, there is a lack of systematic evaluation methods for self-adaptive and self-healing systems. We proposed CHESS, a novel approach to address this gap by evaluating self-adaptive and self-healing systems through fault injection based on chaos engineering (CE).The artifact presented in this paper provides an extensive overview of the use of CHESS through two microservice-based case studies: a smart office case study and an existing demo application called Yelb. It comes with a managing system service, a self-monitoring service, as well as five fault injection scenarios covering infrastructure faults and functional faults. Each of these components can be easily extended or replaced to adopt the CHESS approach to a new case study, help explore its promises and limitations, and identify directions for future research.",IEEE conference,no,"['chess', 'framework', 'evaluation', 'based', 'chaos', 'engineering', 'increasing', 'need', 'assess', 'correct', 'behavior', 'due', 'adoption', 'critical', 'highly', 'dynamic', 'environment', 'however', 'lack', 'systematic', 'evaluation', 'method', 'proposed', 'chess', 'novel', 'address', 'gap', 'evaluating', 'fault', 'injection', 'based', 'chaos', 'engineering', 'artifact', 'presented', 'paper', 'provides', 'extensive', 'overview', 'use', 'chess', 'two', 'case', 'study', 'smart', 'office', 'case', 'study', 'existing', 'demo', 'called', 'come', 'managing', 'well', 'five', 'fault', 'injection', 'scenario', 'covering', 'infrastructure', 'fault', 'functional', 'fault', 'easily', 'extended', 'replaced', 'adopt', 'chess', 'new', 'case', 'study', 'help', 'explore', 'promise', 'limitation', 'identify', 'direction', 'future', 'research']"
"ViCE Registry: An Image Registry for Virtual Collaborative Environments The paper presents a concept and an implementation for an image registry for virtual collaborative environments (ViCE). This cross-platform and cross-organizational image registry bridges gaps between execution environment platforms and user communities. The presented concept consists of a conceptual architecture and a sophisticated set of metadata fields to describe images as virtual environments. The main challenge is the wide spread definition of an image. The terminology defines execution environments, which consist of runtime technologies (virtual machines, containers, applications) and a management layer (basic management, cloud computing, container clusters, job schedulers). An execution environment runs a deployable implicit or declarative image to build a virtual environment. With this abstraction the image registry can share virtual environment across Cloud computing, HPC, classroom setups, with any of KVM, Docker, Singularity, etc. in use. The open source implementation is written in Go and presented with a scalable microservice architecture, using Couchbase as metadata store and RabbitMQ as communication hub between software components.",ViCE Registry: An Image Registry for Virtual Collaborative Environments,"The paper presents a concept and an implementation for an image registry for virtual collaborative environments (ViCE). This cross-platform and cross-organizational image registry bridges gaps between execution environment platforms and user communities. The presented concept consists of a conceptual architecture and a sophisticated set of metadata fields to describe images as virtual environments. The main challenge is the wide spread definition of an image. The terminology defines execution environments, which consist of runtime technologies (virtual machines, containers, applications) and a management layer (basic management, cloud computing, container clusters, job schedulers). An execution environment runs a deployable implicit or declarative image to build a virtual environment. With this abstraction the image registry can share virtual environment across Cloud computing, HPC, classroom setups, with any of KVM, Docker, Singularity, etc. in use. The open source implementation is written in Go and presented with a scalable microservice architecture, using Couchbase as metadata store and RabbitMQ as communication hub between software components.",IEEE conference,no,"['registry', 'image', 'registry', 'virtual', 'collaborative', 'environment', 'paper', 'present', 'concept', 'implementation', 'image', 'registry', 'virtual', 'collaborative', 'environment', 'image', 'registry', 'bridge', 'gap', 'execution', 'environment', 'platform', 'user', 'community', 'presented', 'concept', 'consists', 'conceptual', 'sophisticated', 'set', 'metadata', 'field', 'describe', 'image', 'virtual', 'environment', 'main', 'challenge', 'wide', 'spread', 'definition', 'image', 'defines', 'execution', 'environment', 'consist', 'runtime', 'technology', 'virtual', 'machine', 'container', 'management', 'layer', 'basic', 'management', 'computing', 'container', 'cluster', 'job', 'scheduler', 'execution', 'environment', 'run', 'deployable', 'declarative', 'image', 'build', 'virtual', 'environment', 'abstraction', 'image', 'registry', 'share', 'virtual', 'environment', 'across', 'computing', 'hpc', 'setup', 'docker', 'etc', 'use', 'open', 'source', 'implementation', 'written', 'go', 'presented', 'scalable', 'using', 'metadata', 'store', 'rabbitmq', 'communication', 'hub']"
"On Black-Box Monitoring Techniques for Multi-Component Services Despite the advantages of microservice and function-oriented architectures, there is an increase in complexity to monitor such highly dynamic systems. In this paper, we analyze two distinct methods to tackle the monitoring problem in a system with reduced instrumentation. Our goal is to understand the feasibility of such approach with one specific driver: simplicity. We aim to determine the extent to which it is possible to characterize the state of two generic tandem processes, using as little information as possible. To answer this question, we resorted to a simulation approach. Using a queue system, we simulated two services, that we could manipulate with distinct operation sets for each module. We used the total response time seen upstream of the system. Having this setup and metric, we applied two distinct methods to analyze the results. First, we used supervised machine learning algorithms to identify where the bottleneck is happening. Secondly, we used an exponential decomposition to identify the occupation in the two components in a more black-box fashion. Results show that both methodologies have their advantages and limitations. The separation of the signal more accurately identifies occupation in low occupied resources, but when a service is totally dominating the overall time, it lacks precision. The machine learning has a more stable error, but needs the training set. This study suggest that a black-box occupation approach with both techniques is possible and very useful.",On Black-Box Monitoring Techniques for Multi-Component Services,"Despite the advantages of microservice and function-oriented architectures, there is an increase in complexity to monitor such highly dynamic systems. In this paper, we analyze two distinct methods to tackle the monitoring problem in a system with reduced instrumentation. Our goal is to understand the feasibility of such approach with one specific driver: simplicity. We aim to determine the extent to which it is possible to characterize the state of two generic tandem processes, using as little information as possible. To answer this question, we resorted to a simulation approach. Using a queue system, we simulated two services, that we could manipulate with distinct operation sets for each module. We used the total response time seen upstream of the system. Having this setup and metric, we applied two distinct methods to analyze the results. First, we used supervised machine learning algorithms to identify where the bottleneck is happening. Secondly, we used an exponential decomposition to identify the occupation in the two components in a more black-box fashion. Results show that both methodologies have their advantages and limitations. The separation of the signal more accurately identifies occupation in low occupied resources, but when a service is totally dominating the overall time, it lacks precision. The machine learning has a more stable error, but needs the training set. This study suggest that a black-box occupation approach with both techniques is possible and very useful.",IEEE conference,no,"['monitoring', 'technique', 'despite', 'advantage', 'increase', 'complexity', 'monitor', 'highly', 'dynamic', 'paper', 'analyze', 'two', 'distinct', 'method', 'tackle', 'monitoring', 'problem', 'reduced', 'goal', 'understand', 'feasibility', 'one', 'specific', 'driver', 'simplicity', 'aim', 'determine', 'extent', 'possible', 'characterize', 'state', 'two', 'generic', 'tandem', 'process', 'using', 'little', 'information', 'possible', 'answer', 'question', 'simulation', 'using', 'queue', 'simulated', 'two', 'could', 'distinct', 'operation', 'set', 'module', 'used', 'total', 'response', 'time', 'seen', 'upstream', 'setup', 'metric', 'applied', 'two', 'distinct', 'method', 'analyze', 'result', 'first', 'used', 'supervised', 'machine', 'learning', 'algorithm', 'identify', 'bottleneck', 'happening', 'secondly', 'used', 'decomposition', 'identify', 'occupation', 'two', 'fashion', 'result', 'show', 'methodology', 'advantage', 'limitation', 'separation', 'signal', 'accurately', 'identifies', 'occupation', 'low', 'resource', 'overall', 'time', 'lack', 'precision', 'machine', 'learning', 'stable', 'error', 'need', 'training', 'set', 'study', 'suggest', 'occupation', 'technique', 'possible', 'useful']"
"The Jaseci Programming Paradigm and Runtime Stack: Building Scale-Out Production Applications Easy and Fast Today's production scale-out applications include many sub-application components, such as storage backends, logging infrastructure and AI models. These components have drastically different characteristics, are required to work in collaboration, and interface with each other as microservices. This leads to increasingly high complexity in developing, optimizing, configuring, and deploying scale-out applications, raising the barrier to entry for most individuals and small teams. We developed a novel co-designed runtime system, Jaseci, and programming language, Jac, which aims to reduce this complexity. The key design principle throughout Jaseci's design is to raise the level of abstraction by moving as much of the scale-out data management, microservice componentization, and live update complexity into the runtime stack to be automated and optimized automatically. We use real-world AI applications to demonstrate Jaseci's benefit for application performance and developer productivity.",The Jaseci Programming Paradigm and Runtime Stack: Building Scale-Out Production Applications Easy and Fast,"Today's production scale-out applications include many sub-application components, such as storage backends, logging infrastructure and AI models. These components have drastically different characteristics, are required to work in collaboration, and interface with each other as microservices. This leads to increasingly high complexity in developing, optimizing, configuring, and deploying scale-out applications, raising the barrier to entry for most individuals and small teams. We developed a novel co-designed runtime system, Jaseci, and programming language, Jac, which aims to reduce this complexity. The key design principle throughout Jaseci's design is to raise the level of abstraction by moving as much of the scale-out data management, microservice componentization, and live update complexity into the runtime stack to be automated and optimized automatically. We use real-world AI applications to demonstrate Jaseci's benefit for application performance and developer productivity.",IEEE journal,no,"['jaseci', 'programming', 'paradigm', 'runtime', 'stack', 'building', 'production', 'easy', 'fast', 'today', 'production', 'include', 'many', 'storage', 'logging', 'infrastructure', 'ai', 'model', 'drastically', 'different', 'characteristic', 'required', 'work', 'collaboration', 'interface', 'lead', 'increasingly', 'high', 'complexity', 'developing', 'optimizing', 'configuring', 'deploying', 'barrier', 'entry', 'individual', 'small', 'team', 'developed', 'novel', 'runtime', 'jaseci', 'programming', 'language', 'aim', 'reduce', 'complexity', 'key', 'design', 'principle', 'throughout', 'jaseci', 'design', 'raise', 'level', 'abstraction', 'moving', 'much', 'management', 'componentization', 'live', 'update', 'complexity', 'runtime', 'stack', 'automated', 'optimized', 'automatically', 'use', 'ai', 'demonstrate', 'jaseci', 'benefit', 'performance', 'developer']"
"A Study on the Aging and Fault Tolerance of Microservices in Kubernetes Microservice-based applications are increasingly being adopted along with cloud service models, and nowadays serve millions of customers daily. They are supported by container-based architectures which are managed by orchestration platforms, such as Kubernetes, that monitor, manage, and automate most of the tasks. Although these tools provide failover capabilities, it is not yet studied how effective they are in dealing with diverse types of faults. Fault injection is an effective methodology for validating components that are supposed to detect the malfunctions and report/correct them. This paper studies the effectiveness of Kubernetes in dealing with faults and aging in microservices, and on the possibility of using faults to accelerate aging effects for testing purposes. For this, we conducted an analysis of the implementation and tuning of Kubernetes probes, followed by experiments with varying load and fault injection into two distinct and representative microservice testbeds to analyze the capacity of probes in detecting issues in applications. The goal is to improve the knowledge of researchers and developers on whether Kubernetes can detect different faults and aging issues. Also, even though some services tend to accumulate aging effects, with increasing resource consumption, Kubernetes does not detect them nor acts on them, indicating that probes may be insufficient for aging scenarios. Results also showed that fault injection is useful to accelerate aging effects for the testing and evaluation purposes.",A Study on the Aging and Fault Tolerance of Microservices in Kubernetes,"Microservice-based applications are increasingly being adopted along with cloud service models, and nowadays serve millions of customers daily. They are supported by container-based architectures which are managed by orchestration platforms, such as Kubernetes, that monitor, manage, and automate most of the tasks. Although these tools provide failover capabilities, it is not yet studied how effective they are in dealing with diverse types of faults. Fault injection is an effective methodology for validating components that are supposed to detect the malfunctions and report/correct them. This paper studies the effectiveness of Kubernetes in dealing with faults and aging in microservices, and on the possibility of using faults to accelerate aging effects for testing purposes. For this, we conducted an analysis of the implementation and tuning of Kubernetes probes, followed by experiments with varying load and fault injection into two distinct and representative microservice testbeds to analyze the capacity of probes in detecting issues in applications. The goal is to improve the knowledge of researchers and developers on whether Kubernetes can detect different faults and aging issues. Also, even though some services tend to accumulate aging effects, with increasing resource consumption, Kubernetes does not detect them nor acts on them, indicating that probes may be insufficient for aging scenarios. Results also showed that fault injection is useful to accelerate aging effects for the testing and evaluation purposes.",IEEE journal,no,"['study', 'aging', 'fault', 'tolerance', 'kubernetes', 'increasingly', 'adopted', 'along', 'model', 'nowadays', 'serve', 'million', 'customer', 'daily', 'supported', 'managed', 'orchestration', 'platform', 'kubernetes', 'monitor', 'manage', 'automate', 'task', 'although', 'tool', 'provide', 'capability', 'yet', 'studied', 'effective', 'dealing', 'diverse', 'type', 'fault', 'fault', 'injection', 'effective', 'methodology', 'detect', 'paper', 'study', 'effectiveness', 'kubernetes', 'dealing', 'fault', 'aging', 'possibility', 'using', 'fault', 'accelerate', 'aging', 'effect', 'testing', 'purpose', 'conducted', 'analysis', 'implementation', 'kubernetes', 'probe', 'followed', 'experiment', 'varying', 'load', 'fault', 'injection', 'two', 'distinct', 'representative', 'analyze', 'capacity', 'probe', 'detecting', 'issue', 'goal', 'improve', 'knowledge', 'researcher', 'developer', 'whether', 'kubernetes', 'detect', 'different', 'fault', 'aging', 'issue', 'also', 'even', 'though', 'tend', 'aging', 'effect', 'increasing', 'resource', 'consumption', 'kubernetes', 'detect', 'act', 'indicating', 'probe', 'may', 'aging', 'scenario', 'result', 'also', 'showed', 'fault', 'injection', 'useful', 'accelerate', 'aging', 'effect', 'testing', 'evaluation', 'purpose']"
"Building the Right Technology Landscape This chapter discusses the key aspects of the technology ecosystem and how to build the right technology foundation in a scalable and cost affordable manner. The topics covered are data platform, analytics engine, multi‐agent systems, adaptive user experiences, universal software gateways, and technology partner ecosystems. Database management architecture and systems is the most critical component of the technical infrastructure for AI projects. Analytics engines help reduce the time to develop and deploy the AI algorithms. These engines most often come with a domain‐specific common modeling language to uniformly represent analytical functions. Many industries and companies are adopting microservices architecture as a potential intermediate step before migration into a more mature multi‐agent system. Paying attention to user experience and making it adaptive is therefore critical to the success of any AI initiative. Technology partners become critical as they may bring speed and scale needed to win with AI.",Building the Right Technology Landscape,"This chapter discusses the key aspects of the technology ecosystem and how to build the right technology foundation in a scalable and cost affordable manner. The topics covered are data platform, analytics engine, multi‐agent systems, adaptive user experiences, universal software gateways, and technology partner ecosystems. Database management architecture and systems is the most critical component of the technical infrastructure for AI projects. Analytics engines help reduce the time to develop and deploy the AI algorithms. These engines most often come with a domain‐specific common modeling language to uniformly represent analytical functions. Many industries and companies are adopting microservices architecture as a potential intermediate step before migration into a more mature multi‐agent system. Paying attention to user experience and making it adaptive is therefore critical to the success of any AI initiative. Technology partners become critical as they may bring speed and scale needed to win with AI.",IEEE book,no,"['building', 'right', 'technology', 'landscape', 'chapter', 'discusses', 'key', 'aspect', 'technology', 'ecosystem', 'build', 'right', 'technology', 'foundation', 'scalable', 'cost', 'manner', 'topic', 'covered', 'platform', 'analytics', 'engine', 'adaptive', 'user', 'experience', 'universal', 'gateway', 'technology', 'partner', 'ecosystem', 'database', 'management', 'critical', 'technical', 'infrastructure', 'ai', 'project', 'analytics', 'engine', 'help', 'reduce', 'time', 'develop', 'deploy', 'ai', 'algorithm', 'engine', 'often', 'come', 'common', 'modeling', 'language', 'represent', 'analytical', 'function', 'many', 'industry', 'company', 'adopting', 'potential', 'intermediate', 'step', 'migration', 'attention', 'user', 'experience', 'making', 'adaptive', 'therefore', 'critical', 'success', 'ai', 'initiative', 'technology', 'partner', 'become', 'critical', 'may', 'bring', 'speed', 'scale', 'needed', 'ai']"
