text,Document Title,Abstract,source,bool,processed_text
"Dynamic Evaluation of Microservice Granularity Adaptation Microservices have gained acceptance in software industries as an emerging architectural style for autonomic, scalable, and more reliable computing. Among the critical microservice architecture design decisions is when to adapt the granularity of a microservice architecture by merging/decomposing microservices. No existing work investigates the following question: How can we reason about the trade-off between predicted benefits and cost of pursuing microservice granularity adaptation under uncertainty? To address this question, we provide a novel formulation of the decision problem to pursue granularity adaptation as a real options problem. We propose a novel evaluation process for dynamically evaluating granularity adaptation design decisions under uncertainty. Our process is based on a novel combination of real options and the concept of Bayesian surprises. We show the benefits of our evaluation process by comparing it to four representative industrial microservice runtime monitoring tools, which can be used for retrospective evaluation for granularity adaptation decisions. Our comparison shows that our process can supersede and/or complement these tools. We implement a microservice application—Filmflix—using Amazon Web Service Lambda and use this implementation as a case study to show the unique benefit of our process compared to traditional application of real options analysis.",Dynamic Evaluation of Microservice Granularity Adaptation,"Microservices have gained acceptance in software industries as an emerging architectural style for autonomic, scalable, and more reliable computing. Among the critical microservice architecture design decisions is when to adapt the granularity of a microservice architecture by merging/decomposing microservices. No existing work investigates the following question: How can we reason about the trade-off between predicted benefits and cost of pursuing microservice granularity adaptation under uncertainty? To address this question, we provide a novel formulation of the decision problem to pursue granularity adaptation as a real options problem. We propose a novel evaluation process for dynamically evaluating granularity adaptation design decisions under uncertainty. Our process is based on a novel combination of real options and the concept of Bayesian surprises. We show the benefits of our evaluation process by comparing it to four representative industrial microservice runtime monitoring tools, which can be used for retrospective evaluation for granularity adaptation decisions. Our comparison shows that our process can supersede and/or complement these tools. We implement a microservice application—Filmflix—using Amazon Web Service Lambda and use this implementation as a case study to show the unique benefit of our process compared to traditional application of real options analysis.",ACM,no,"['dynamic', 'evaluation', 'granularity', 'adaptation', 'gained', 'acceptance', 'industry', 'emerging', 'architectural', 'style', 'autonomic', 'scalable', 'reliable', 'computing', 'among', 'critical', 'design', 'decision', 'adapt', 'granularity', 'existing', 'work', 'investigates', 'following', 'question', 'reason', 'predicted', 'benefit', 'cost', 'granularity', 'adaptation', 'uncertainty', 'address', 'question', 'provide', 'novel', 'formulation', 'decision', 'problem', 'granularity', 'adaptation', 'real', 'option', 'problem', 'propose', 'novel', 'evaluation', 'process', 'dynamically', 'evaluating', 'granularity', 'adaptation', 'design', 'decision', 'uncertainty', 'process', 'based', 'novel', 'combination', 'real', 'option', 'concept', 'show', 'benefit', 'evaluation', 'process', 'comparing', 'four', 'representative', 'industrial', 'runtime', 'monitoring', 'tool', 'used', 'evaluation', 'granularity', 'adaptation', 'decision', 'comparison', 'show', 'process', 'complement', 'tool', 'implement', 'amazon', 'web', 'use', 'implementation', 'case', 'study', 'show', 'unique', 'benefit', 'process', 'compared', 'traditional', 'real', 'option', 'analysis']"
"Actor-Driven Decomposition of Microservices through Multi-level Scalability Assessment The microservices architectural style has gained widespread acceptance. However, designing applications according to this style is still challenging. Common difficulties concern finding clear boundaries that guide decomposition while ensuring performance and scalability. With the aim of providing software architects and engineers with a systematic methodology, we introduce a novel actor-driven decomposition strategy to complement the domain-driven design and overcome some of its limitations by reaching a finer modularization yet enforcing performance and scalability improvements. The methodology uses a multi-level scalability assessment framework that supports decision-making over iterative steps. At each iteration, architecture alternatives are quantitatively evaluated at multiple granularity levels. The assessment helps architects to understand the extent to which architecture alternatives increase or decrease performance and scalability. We applied the methodology to drive further decomposition of the core microservices of a real data-intensive smart mobility application and an existing open-source benchmark in the e-commerce domain. The results of an in-depth evaluation show that the approach can effectively support engineers in (i) decomposing monoliths or coarse-grained microservices into more scalable microservices and (ii) comparing among alternative architectures to guide decision-making for their deployment in modern infrastructures that orchestrate lightweight virtualized execution units.",Actor-Driven Decomposition of Microservices through Multi-level Scalability Assessment,"The microservices architectural style has gained widespread acceptance. However, designing applications according to this style is still challenging. Common difficulties concern finding clear boundaries that guide decomposition while ensuring performance and scalability. With the aim of providing software architects and engineers with a systematic methodology, we introduce a novel actor-driven decomposition strategy to complement the domain-driven design and overcome some of its limitations by reaching a finer modularization yet enforcing performance and scalability improvements. The methodology uses a multi-level scalability assessment framework that supports decision-making over iterative steps. At each iteration, architecture alternatives are quantitatively evaluated at multiple granularity levels. The assessment helps architects to understand the extent to which architecture alternatives increase or decrease performance and scalability. We applied the methodology to drive further decomposition of the core microservices of a real data-intensive smart mobility application and an existing open-source benchmark in the e-commerce domain. The results of an in-depth evaluation show that the approach can effectively support engineers in (i) decomposing monoliths or coarse-grained microservices into more scalable microservices and (ii) comparing among alternative architectures to guide decision-making for their deployment in modern infrastructures that orchestrate lightweight virtualized execution units.",ACM,no,"['decomposition', 'scalability', 'assessment', 'architectural', 'style', 'gained', 'widespread', 'acceptance', 'however', 'designing', 'according', 'style', 'still', 'challenging', 'common', 'difficulty', 'concern', 'finding', 'clear', 'boundary', 'guide', 'decomposition', 'ensuring', 'performance', 'scalability', 'aim', 'providing', 'architect', 'engineer', 'systematic', 'methodology', 'introduce', 'novel', 'decomposition', 'strategy', 'complement', 'design', 'overcome', 'limitation', 'finer', 'modularization', 'yet', 'enforcing', 'performance', 'scalability', 'improvement', 'methodology', 'us', 'scalability', 'assessment', 'framework', 'support', 'iterative', 'step', 'iteration', 'alternative', 'quantitatively', 'evaluated', 'multiple', 'granularity', 'level', 'assessment', 'help', 'architect', 'understand', 'extent', 'alternative', 'increase', 'decrease', 'performance', 'scalability', 'applied', 'methodology', 'drive', 'decomposition', 'core', 'real', 'smart', 'mobility', 'existing', 'benchmark', 'domain', 'result', 'evaluation', 'show', 'effectively', 'support', 'engineer', 'decomposing', 'monolith', 'scalable', 'ii', 'comparing', 'among', 'alternative', 'guide', 'deployment', 'modern', 'infrastructure', 'orchestrate', 'lightweight', 'virtualized', 'execution', 'unit']"
"MicroProf: Code-level Attribution of Unnecessary Data Transfer in Microservice Applications The microservice architecture style has gained popularity due to its ability to fault isolation, ease of scaling applications, and developer’s agility. However, writing applications in the microservice design style has its challenges. Due to the loosely coupled nature, services communicate with others through standard communication APIs. This incurs significant overhead in the application due to communication protocol and data transformation. An inefficient service communication at the microservice application logic can further overwhelm the application. We perform a grey literature review showing that unnecessary data transfer is a real challenge in the industry. To the best of our knowledge, no effective tool is currently available to accurately identify the origins of unnecessary microservice communications that lead to significant performance overhead and provide guidance for optimization.To bridge the knowledge gap, we propose MicroProf, a dynamic program analysis tool to detect unnecessary data transfer in Java-based microservice applications. At the implementation level, MicroProf proposes novel techniques such as remote object sampling and hardware debug registers to monitor remote object usage. MicroProf reports the unnecessary data transfer at the application source code level. Furthermore, MicroProf pinpoints the opportunities for communication API optimization. MicroProf is evaluated on four well-known applications involving two real-world applications and two benchmarks, identifying five inefficient remote invocations. Guided by MicroProf, API optimization achieves an 87.5\% reduction in the number of fields within REST API responses. The empirical evaluation further reveals that the optimized services experience a speedup of up to 4.59\texttimes{}.",MicroProf: Code-level Attribution of Unnecessary Data Transfer in Microservice Applications,"The microservice architecture style has gained popularity due to its ability to fault isolation, ease of scaling applications, and developer’s agility. However, writing applications in the microservice design style has its challenges. Due to the loosely coupled nature, services communicate with others through standard communication APIs. This incurs significant overhead in the application due to communication protocol and data transformation. An inefficient service communication at the microservice application logic can further overwhelm the application. We perform a grey literature review showing that unnecessary data transfer is a real challenge in the industry. To the best of our knowledge, no effective tool is currently available to accurately identify the origins of unnecessary microservice communications that lead to significant performance overhead and provide guidance for optimization.To bridge the knowledge gap, we propose MicroProf, a dynamic program analysis tool to detect unnecessary data transfer in Java-based microservice applications. At the implementation level, MicroProf proposes novel techniques such as remote object sampling and hardware debug registers to monitor remote object usage. MicroProf reports the unnecessary data transfer at the application source code level. Furthermore, MicroProf pinpoints the opportunities for communication API optimization. MicroProf is evaluated on four well-known applications involving two real-world applications and two benchmarks, identifying five inefficient remote invocations. Guided by MicroProf, API optimization achieves an 87.5\% reduction in the number of fields within REST API responses. The empirical evaluation further reveals that the optimized services experience a speedup of up to 4.59\texttimes{}.",ACM,no,"['microprof', 'unnecessary', 'transfer', 'style', 'gained', 'popularity', 'due', 'ability', 'fault', 'isolation', 'ease', 'scaling', 'developer', 'agility', 'however', 'writing', 'design', 'style', 'challenge', 'due', 'loosely', 'coupled', 'nature', 'communicate', 'others', 'standard', 'communication', 'apis', 'significant', 'overhead', 'due', 'communication', 'protocol', 'transformation', 'inefficient', 'communication', 'logic', 'perform', 'literature', 'review', 'showing', 'unnecessary', 'transfer', 'real', 'challenge', 'industry', 'best', 'knowledge', 'effective', 'tool', 'currently', 'available', 'accurately', 'identify', 'unnecessary', 'communication', 'lead', 'significant', 'performance', 'overhead', 'provide', 'guidance', 'bridge', 'knowledge', 'gap', 'propose', 'microprof', 'dynamic', 'program', 'analysis', 'tool', 'detect', 'unnecessary', 'transfer', 'implementation', 'level', 'microprof', 'proposes', 'novel', 'technique', 'remote', 'object', 'sampling', 'hardware', 'debug', 'monitor', 'remote', 'object', 'usage', 'microprof', 'report', 'unnecessary', 'transfer', 'source', 'code', 'level', 'furthermore', 'microprof', 'pinpoint', 'opportunity', 'communication', 'api', 'optimization', 'microprof', 'evaluated', 'four', 'involving', 'two', 'two', 'benchmark', 'identifying', 'five', 'inefficient', 'remote', 'invocation', 'guided', 'microprof', 'api', 'optimization', 'achieves', 'reduction', 'number', 'field', 'within', 'rest', 'api', 'response', 'empirical', 'evaluation', 'reveals', 'optimized', 'experience']"
"Data Mesh: A Systematic Gray Literature Review Data mesh is an emerging domain-driven decentralized data architecture that aims to minimize or avoid operational bottlenecks associated with centralized, monolithic data architectures in enterprises. The topic has piqued the practitioners’ interest, and considerable gray literature exists. At the same time, we observe a lack of academic attempts at defining and building upon the concept. Hence, in this article, we aim to start from the foundations and characterize the data mesh architecture regarding its design principles, architectural components, capabilities, and organizational roles. We systematically collected, analyzed, and synthesized 114 industrial gray literature articles. The resulting review provides insights into practitioners’ perspectives on the four key principles of data mesh: data as a product, domain ownership of data, self-serve data platform, and federated computational governance. Moreover, due to the comparability of data mesh and SOA (service-oriented architecture), we mapped the findings from the gray literature into the reference architectures from the SOA academic literature to create the reference architectures for describing three key dimensions of data mesh: organization of capabilities and roles, development, and runtime. Finally, we discuss open research issues in data mesh, partially based on the findings from the gray literature.",Data Mesh: A Systematic Gray Literature Review,"Data mesh is an emerging domain-driven decentralized data architecture that aims to minimize or avoid operational bottlenecks associated with centralized, monolithic data architectures in enterprises. The topic has piqued the practitioners’ interest, and considerable gray literature exists. At the same time, we observe a lack of academic attempts at defining and building upon the concept. Hence, in this article, we aim to start from the foundations and characterize the data mesh architecture regarding its design principles, architectural components, capabilities, and organizational roles. We systematically collected, analyzed, and synthesized 114 industrial gray literature articles. The resulting review provides insights into practitioners’ perspectives on the four key principles of data mesh: data as a product, domain ownership of data, self-serve data platform, and federated computational governance. Moreover, due to the comparability of data mesh and SOA (service-oriented architecture), we mapped the findings from the gray literature into the reference architectures from the SOA academic literature to create the reference architectures for describing three key dimensions of data mesh: organization of capabilities and roles, development, and runtime. Finally, we discuss open research issues in data mesh, partially based on the findings from the gray literature.",ACM,no,"['mesh', 'systematic', 'gray', 'literature', 'review', 'mesh', 'emerging', 'decentralized', 'aim', 'minimize', 'avoid', 'operational', 'bottleneck', 'associated', 'centralized', 'monolithic', 'enterprise', 'topic', 'practitioner', 'interest', 'gray', 'literature', 'exists', 'time', 'observe', 'lack', 'academic', 'attempt', 'defining', 'building', 'upon', 'concept', 'hence', 'article', 'aim', 'start', 'foundation', 'characterize', 'mesh', 'regarding', 'design', 'principle', 'architectural', 'capability', 'organizational', 'role', 'collected', 'analyzed', 'industrial', 'gray', 'literature', 'article', 'resulting', 'review', 'provides', 'insight', 'practitioner', 'perspective', 'four', 'key', 'principle', 'mesh', 'product', 'domain', 'ownership', 'platform', 'federated', 'computational', 'governance', 'moreover', 'due', 'mesh', 'soa', 'mapped', 'finding', 'gray', 'literature', 'reference', 'soa', 'academic', 'literature', 'create', 'reference', 'describing', 'three', 'key', 'dimension', 'mesh', 'organization', 'capability', 'role', 'development', 'runtime', 'finally', 'discus', 'open', 'research', 'issue', 'mesh', 'partially', 'based', 'finding', 'gray', 'literature']"
"The structure and delivery of an advanced systems administration IT course IT program courses should allow students to acquire the needed IT skills to enable them to be job ready by graduation. To prepare the IT graduates to current and future practices of virtualized computing resources, which integrate IT systems and services, DevOps and microservices, systems administration courses need to introduce students to current tools used to administer and manage continuous integration and deployment of infrastructure and services. In this paper, we provide the structure, components, hands-on assignments, and the virtual environment of a senior-level competency-based advanced Unix/Linux systems administration course that is delivered face-to-face and online. The course introduces current organizational practices of continuous integration and delivery of services. Student course evaluation and what helped them learn the most are also presented and discussed.",The structure and delivery of an advanced systems administration IT course,"IT program courses should allow students to acquire the needed IT skills to enable them to be job ready by graduation. To prepare the IT graduates to current and future practices of virtualized computing resources, which integrate IT systems and services, DevOps and microservices, systems administration courses need to introduce students to current tools used to administer and manage continuous integration and deployment of infrastructure and services. In this paper, we provide the structure, components, hands-on assignments, and the virtual environment of a senior-level competency-based advanced Unix/Linux systems administration course that is delivered face-to-face and online. The course introduces current organizational practices of continuous integration and delivery of services. Student course evaluation and what helped them learn the most are also presented and discussed.",ACM,no,"['structure', 'delivery', 'advanced', 'administration', 'course', 'program', 'course', 'allow', 'student', 'needed', 'skill', 'enable', 'job', 'ready', 'current', 'future', 'practice', 'virtualized', 'computing', 'resource', 'integrate', 'devops', 'administration', 'course', 'need', 'introduce', 'student', 'current', 'tool', 'used', 'manage', 'continuous', 'integration', 'deployment', 'infrastructure', 'paper', 'provide', 'structure', 'assignment', 'virtual', 'environment', 'advanced', 'administration', 'course', 'online', 'course', 'introduces', 'current', 'organizational', 'practice', 'continuous', 'integration', 'delivery', 'student', 'course', 'evaluation', 'helped', 'learn', 'also', 'presented', 'discussed']"
"RapidMS: A Tool for Supporting Rapid Microservices Generation and Refinement from Requirements Model Microservices is a crucial architecture design pat-tern for developing cloud-native applications, which focuses on decomposing a large and complex software system into autonomous components that can be independently developed and deployed. However, microservices design is not a trivial task, which highly depends on the profound knowledge and experience of system design and target domain. This is a challenge for novice software architects. In this paper, we propose a microservices design tool named RapidMS, which only requires architects to specify potential context boundaries on the requirements model. The microservices architecture design model with component structure and interaction views can be automatically generated without extra human effort. Moreover, the proposed tool can automatically calculate the characteristic metrics of the microservices, which indicate the quality of the different aspects of models to support rapid architecture refinements. We demonstrate the tool's effectiveness through five case studies. The experimental result shows that architects can get better decomposition of requirement model within four iterations and over 90% of microservice architecture diagrams can be correctly generated within 10 seconds. RapidMS can be further extended and applied in the software industry to reduce the cost and difficulty of microservices decomposition and design. The tool can be downloaded at https://rm2pt.com/advs/ rapidms, and a demo video casting its features is at https://youtu.be/AoIM41FTnFO",RapidMS: A Tool for Supporting Rapid Microservices Generation and Refinement from Requirements Model,"Microservices is a crucial architecture design pat-tern for developing cloud-native applications, which focuses on decomposing a large and complex software system into autonomous components that can be independently developed and deployed. However, microservices design is not a trivial task, which highly depends on the profound knowledge and experience of system design and target domain. This is a challenge for novice software architects. In this paper, we propose a microservices design tool named RapidMS, which only requires architects to specify potential context boundaries on the requirements model. The microservices architecture design model with component structure and interaction views can be automatically generated without extra human effort. Moreover, the proposed tool can automatically calculate the characteristic metrics of the microservices, which indicate the quality of the different aspects of models to support rapid architecture refinements. We demonstrate the tool's effectiveness through five case studies. The experimental result shows that architects can get better decomposition of requirement model within four iterations and over 90% of microservice architecture diagrams can be correctly generated within 10 seconds. RapidMS can be further extended and applied in the software industry to reduce the cost and difficulty of microservices decomposition and design. The tool can be downloaded at https://rm2pt.com/advs/ rapidms, and a demo video casting its features is at https://youtu.be/AoIM41FTnFO",IEEE conference,no,"['rapidms', 'tool', 'supporting', 'rapid', 'generation', 'refinement', 'requirement', 'model', 'crucial', 'design', 'developing', 'focus', 'decomposing', 'large', 'complex', 'autonomous', 'independently', 'developed', 'deployed', 'however', 'design', 'task', 'highly', 'depends', 'knowledge', 'experience', 'design', 'target', 'domain', 'challenge', 'architect', 'paper', 'propose', 'design', 'tool', 'named', 'rapidms', 'requires', 'architect', 'specify', 'potential', 'context', 'boundary', 'requirement', 'model', 'design', 'model', 'structure', 'interaction', 'view', 'automatically', 'generated', 'without', 'extra', 'human', 'effort', 'moreover', 'proposed', 'tool', 'automatically', 'calculate', 'characteristic', 'metric', 'indicate', 'quality', 'different', 'aspect', 'model', 'support', 'rapid', 'refinement', 'demonstrate', 'tool', 'effectiveness', 'five', 'case', 'study', 'experimental', 'result', 'show', 'architect', 'get', 'better', 'decomposition', 'requirement', 'model', 'within', 'four', 'iteration', 'diagram', 'correctly', 'generated', 'within', 'second', 'rapidms', 'extended', 'applied', 'industry', 'reduce', 'cost', 'difficulty', 'decomposition', 'design', 'tool', 'rapidms', 'demo', 'video', 'feature']"
"Performance Evaluation of Monolithic and Microservice Architecture for an E-commerce Startup Today's businesses must be flexible enough to develop scalable applications that can influence emerging models of production and management. The prevailing imperative for organizations to adopt new technologies and business strategies stems from the need to enhance the efficiency and optimization of both human and technology resources. The concept of ""software architecture"" has been employed to define the overall blueprint of a software system. Software architecture has been proposed as a strategy to decrease complexity and enhance reusability by facilitating system decomposition into its high-level components and their interrelationships. Within the technology sector, the phrase ""e-commerce"" is frequently employed to denote the activities encompassing acquiring, vending, and promoting goods and services. The necessity for an e-commerce enterprise lies in reusable code that pays minimal costs and possesses a streamlined infrastructure. Implementing a suitable architectural framework to meet the existing demands of e-commerce is the most optimal strategy presently. This study undertakes a comparative analysis of monolithic and microservice architectures in the context of an e-commerce startup. Two separate software applications are developed, each following one of the mentioned architectures while utilizing the same technology platform. The findings of the tests suggest that monolithic architectures have the potential to decrease infrastructure expenses and enhance performance when compared to traditional microservice architectures. In conclusion, we clarify the challenges encountered during the deployment and implementation phases of microservices and monolithic web applications.",Performance Evaluation of Monolithic and Microservice Architecture for an E-commerce Startup,"Today's businesses must be flexible enough to develop scalable applications that can influence emerging models of production and management. The prevailing imperative for organizations to adopt new technologies and business strategies stems from the need to enhance the efficiency and optimization of both human and technology resources. The concept of ""software architecture"" has been employed to define the overall blueprint of a software system. Software architecture has been proposed as a strategy to decrease complexity and enhance reusability by facilitating system decomposition into its high-level components and their interrelationships. Within the technology sector, the phrase ""e-commerce"" is frequently employed to denote the activities encompassing acquiring, vending, and promoting goods and services. The necessity for an e-commerce enterprise lies in reusable code that pays minimal costs and possesses a streamlined infrastructure. Implementing a suitable architectural framework to meet the existing demands of e-commerce is the most optimal strategy presently. This study undertakes a comparative analysis of monolithic and microservice architectures in the context of an e-commerce startup. Two separate software applications are developed, each following one of the mentioned architectures while utilizing the same technology platform. The findings of the tests suggest that monolithic architectures have the potential to decrease infrastructure expenses and enhance performance when compared to traditional microservice architectures. In conclusion, we clarify the challenges encountered during the deployment and implementation phases of microservices and monolithic web applications.",IEEE conference,no,"['performance', 'evaluation', 'monolithic', 'startup', 'today', 'business', 'must', 'flexible', 'enough', 'develop', 'scalable', 'influence', 'emerging', 'model', 'production', 'management', 'prevailing', 'imperative', 'organization', 'adopt', 'new', 'technology', 'business', 'strategy', 'need', 'enhance', 'efficiency', 'optimization', 'human', 'technology', 'resource', 'concept', 'employed', 'define', 'overall', 'blueprint', 'proposed', 'strategy', 'decrease', 'complexity', 'enhance', 'reusability', 'facilitating', 'decomposition', 'within', 'technology', 'sector', 'employed', 'activity', 'encompassing', 'promoting', 'good', 'necessity', 'enterprise', 'lie', 'reusable', 'code', 'minimal', 'cost', 'streamlined', 'infrastructure', 'implementing', 'suitable', 'architectural', 'framework', 'meet', 'existing', 'demand', 'optimal', 'strategy', 'study', 'comparative', 'analysis', 'monolithic', 'context', 'startup', 'two', 'separate', 'developed', 'following', 'one', 'utilizing', 'technology', 'platform', 'finding', 'test', 'suggest', 'monolithic', 'potential', 'decrease', 'infrastructure', 'enhance', 'performance', 'compared', 'traditional', 'conclusion', 'challenge', 'deployment', 'implementation', 'phase', 'monolithic', 'web']"
"A Component-Based Evolution Model for Service-Based Software Architectures Microservices architecture has emerged as an architectural style which focuses on the design and development of software systems as a set of small independent services. Although MSA is inspired by the Service-Oriented Architecture style (both are service-based architectures), it presents important differences. Likewise, software architecture must evolve as new architectural styles and software frameworks arise, and the evolution of the software architecture is considered as a central feature of any software system. In this way, this paper proposes an approach to evolve SOA to MSA architectures through the use of Sarch language. To accomplish this, the language was extended to allow the modeling of the two architectural styles from the component-and-connector view, the inclusion of a decomposition view for functional properties, and the use of a model-to-model transformation algorithm.",A Component-Based Evolution Model for Service-Based Software Architectures,"Microservices architecture has emerged as an architectural style which focuses on the design and development of software systems as a set of small independent services. Although MSA is inspired by the Service-Oriented Architecture style (both are service-based architectures), it presents important differences. Likewise, software architecture must evolve as new architectural styles and software frameworks arise, and the evolution of the software architecture is considered as a central feature of any software system. In this way, this paper proposes an approach to evolve SOA to MSA architectures through the use of Sarch language. To accomplish this, the language was extended to allow the modeling of the two architectural styles from the component-and-connector view, the inclusion of a decomposition view for functional properties, and the use of a model-to-model transformation algorithm.",IEEE conference,no,"['evolution', 'model', 'emerged', 'architectural', 'style', 'focus', 'design', 'development', 'set', 'small', 'independent', 'although', 'msa', 'inspired', 'style', 'present', 'important', 'difference', 'must', 'evolve', 'new', 'architectural', 'style', 'framework', 'arise', 'evolution', 'considered', 'central', 'feature', 'way', 'paper', 'proposes', 'evolve', 'soa', 'msa', 'use', 'language', 'accomplish', 'language', 'extended', 'allow', 'modeling', 'two', 'architectural', 'style', 'view', 'inclusion', 'decomposition', 'view', 'functional', 'property', 'use', 'transformation', 'algorithm']"
"Evaluating the Inter-Service Communication on Microservice Architecture Distributed computing concepts have proliferated with cloud computing concepts in the past decade. With the evolution in cloud computing, Microservice architecture has significantly become popular as a new architectural pattern and a software development architecture. Most enterprise software development has moved their monolithic software architecture to microservice-based architecture, as it can divide large applications into light-weighted, distributed components. However, this approach may be subject to certain downsides as well. With the modern convention, engineers have succeeded in achieving scalability and maintainability quality attributes and lack the performance attribute in terms of response time. This is because the microservice architecture has introduced inter-service communication over the network. The key challenge when developing a microservice-based application is choosing the correct inter-service communication mechanism to reduce the time taken when calling each service. This research has taken an experimental methodology to compare and contrast the most trending inter-service communication mechanisms. Industry-standard benchmark load test is run to collect quantitative data to evaluate the overall system performance in terms of response time. The testing observed that gRPC protocol performs well in terms of response time and throughput compared to the HTTP and Web Socket protocols.",Evaluating the Inter-Service Communication on Microservice Architecture,"Distributed computing concepts have proliferated with cloud computing concepts in the past decade. With the evolution in cloud computing, Microservice architecture has significantly become popular as a new architectural pattern and a software development architecture. Most enterprise software development has moved their monolithic software architecture to microservice-based architecture, as it can divide large applications into light-weighted, distributed components. However, this approach may be subject to certain downsides as well. With the modern convention, engineers have succeeded in achieving scalability and maintainability quality attributes and lack the performance attribute in terms of response time. This is because the microservice architecture has introduced inter-service communication over the network. The key challenge when developing a microservice-based application is choosing the correct inter-service communication mechanism to reduce the time taken when calling each service. This research has taken an experimental methodology to compare and contrast the most trending inter-service communication mechanisms. Industry-standard benchmark load test is run to collect quantitative data to evaluate the overall system performance in terms of response time. The testing observed that gRPC protocol performs well in terms of response time and throughput compared to the HTTP and Web Socket protocols.",IEEE conference,no,"['evaluating', 'communication', 'distributed', 'computing', 'concept', 'computing', 'concept', 'past', 'decade', 'evolution', 'computing', 'significantly', 'become', 'popular', 'new', 'architectural', 'pattern', 'development', 'enterprise', 'development', 'moved', 'monolithic', 'divide', 'large', 'distributed', 'however', 'may', 'subject', 'certain', 'well', 'modern', 'engineer', 'achieving', 'scalability', 'maintainability', 'quality', 'attribute', 'lack', 'performance', 'attribute', 'term', 'response', 'time', 'introduced', 'communication', 'network', 'key', 'challenge', 'developing', 'choosing', 'correct', 'communication', 'mechanism', 'reduce', 'time', 'taken', 'calling', 'research', 'taken', 'experimental', 'methodology', 'compare', 'contrast', 'communication', 'mechanism', 'benchmark', 'load', 'test', 'run', 'collect', 'quantitative', 'evaluate', 'overall', 'performance', 'term', 'response', 'time', 'testing', 'observed', 'grpc', 'protocol', 'performs', 'well', 'term', 'response', 'time', 'throughput', 'compared', 'http', 'web', 'protocol']"
"Comparative Analysis of Monolith, Microservice API Gateway and Microservice Federated Gateway on Web-based application using GraphQL API The purpose of this research is to provide a detailed explanation regarding the characteristics as well as the pros and cons offered by various software development architecture, such as monolithic and Microservice architecture implemented with graph-based API called GraphQL. Monolithic architecture offers a centralized software development pattern with relatively simpler integration and development process. Conversely, Microservices architecture such as Gateway Aggregation and Federated Gateway will divide independent components of the application into smaller modules. Gateway Aggregation utilizes a single Gateway which acts as the main entry point for data exchange between the client and the application. In this research aims an application is developed using the three different architectures to measure the quality, both qualitative and quantitative performances of each architecture. There are several different parameters that are going to be used to measure the architecture’s performance such as response time and data throughput which become an essential criterion in conducting load and stress testing. The result is that the Monolithic architecture offers some advantages in its quantitative performance measurement due to better efficiency in collecting and processing requested data in a single application which utilizes fewer resources and shorter time. In contrast, the Gateway Aggregation architecture and Federated Gateway architecture also have some significant performance differences because it costs resources to combine several subgraphs together into a valid graph.","Comparative Analysis of Monolith, Microservice API Gateway and Microservice Federated Gateway on Web-based application using GraphQL API","The purpose of this research is to provide a detailed explanation regarding the characteristics as well as the pros and cons offered by various software development architecture, such as monolithic and Microservice architecture implemented with graph-based API called GraphQL. Monolithic architecture offers a centralized software development pattern with relatively simpler integration and development process. Conversely, Microservices architecture such as Gateway Aggregation and Federated Gateway will divide independent components of the application into smaller modules. Gateway Aggregation utilizes a single Gateway which acts as the main entry point for data exchange between the client and the application. In this research aims an application is developed using the three different architectures to measure the quality, both qualitative and quantitative performances of each architecture. There are several different parameters that are going to be used to measure the architecture’s performance such as response time and data throughput which become an essential criterion in conducting load and stress testing. The result is that the Monolithic architecture offers some advantages in its quantitative performance measurement due to better efficiency in collecting and processing requested data in a single application which utilizes fewer resources and shorter time. In contrast, the Gateway Aggregation architecture and Federated Gateway architecture also have some significant performance differences because it costs resources to combine several subgraphs together into a valid graph.",IEEE conference,no,"['comparative', 'analysis', 'monolith', 'api', 'gateway', 'federated', 'gateway', 'using', 'graphql', 'api', 'purpose', 'research', 'provide', 'detailed', 'regarding', 'characteristic', 'well', 'pro', 'con', 'offered', 'various', 'development', 'monolithic', 'implemented', 'api', 'called', 'graphql', 'monolithic', 'offer', 'centralized', 'development', 'pattern', 'relatively', 'simpler', 'integration', 'development', 'process', 'gateway', 'aggregation', 'federated', 'gateway', 'divide', 'independent', 'smaller', 'module', 'gateway', 'aggregation', 'utilizes', 'single', 'gateway', 'act', 'main', 'entry', 'point', 'exchange', 'client', 'research', 'aim', 'developed', 'using', 'three', 'different', 'measure', 'quality', 'qualitative', 'quantitative', 'performance', 'several', 'different', 'parameter', 'going', 'used', 'measure', 'performance', 'response', 'time', 'throughput', 'become', 'essential', 'criterion', 'conducting', 'load', 'testing', 'result', 'monolithic', 'offer', 'advantage', 'quantitative', 'performance', 'measurement', 'due', 'better', 'efficiency', 'collecting', 'processing', 'requested', 'single', 'utilizes', 'fewer', 'resource', 'time', 'contrast', 'gateway', 'aggregation', 'federated', 'gateway', 'also', 'significant', 'performance', 'difference', 'cost', 'resource', 'combine', 'several', 'together', 'graph']"
"An Approach of a Migration Process from a Legacy Web Management System with a Monolithic Architecture to a Modern Microservices-Based Architecture of a Tourism Services Company The migration from a monolithic to a microservice architecture is a complex process that involves separating an application into independent services that work together to provide the complete functionality that the legacy system provides. During this process, despite extensive planning; limitations and difficulties can arise, primarily related to code rewriting and updating outdated technologies. To mitigate all difficulties, it is necessary to first document the architectures properly; analyze their advantages and disadvantages, use cases, tech-nologies, and the existence of similar migration processes, among others. Gathering comprehensive documentation from the legacy system is also essential to establish a solid foundation of requirements and functionalities on which to conduct the migration. Finally, the choice of tools, such as in our case, those offered by Spring Cloud, Spring Boot, and Docker can greatly facilitate this process. The migration to microservices offers benefits such as easier implementation of new functionalities, quicker problem detection and resolution, improved availability, and enhanced user experience. Therefore, in this research paper we will (a) analyze the current architecture of the system of a company dedicated to providing tourism services in the city of Cuenca, Ecuador; (b) design an architecture based on microservices; and (c) develop a prototype to help us validate the feasibility of the proposed architecture. Thus, contributing to better performance, applying fault tolerance, and the possibility of both horizontal and vertical scaling in the microservices architecture system.",An Approach of a Migration Process from a Legacy Web Management System with a Monolithic Architecture to a Modern Microservices-Based Architecture of a Tourism Services Company,"The migration from a monolithic to a microservice architecture is a complex process that involves separating an application into independent services that work together to provide the complete functionality that the legacy system provides. During this process, despite extensive planning; limitations and difficulties can arise, primarily related to code rewriting and updating outdated technologies. To mitigate all difficulties, it is necessary to first document the architectures properly; analyze their advantages and disadvantages, use cases, tech-nologies, and the existence of similar migration processes, among others. Gathering comprehensive documentation from the legacy system is also essential to establish a solid foundation of requirements and functionalities on which to conduct the migration. Finally, the choice of tools, such as in our case, those offered by Spring Cloud, Spring Boot, and Docker can greatly facilitate this process. The migration to microservices offers benefits such as easier implementation of new functionalities, quicker problem detection and resolution, improved availability, and enhanced user experience. Therefore, in this research paper we will (a) analyze the current architecture of the system of a company dedicated to providing tourism services in the city of Cuenca, Ecuador; (b) design an architecture based on microservices; and (c) develop a prototype to help us validate the feasibility of the proposed architecture. Thus, contributing to better performance, applying fault tolerance, and the possibility of both horizontal and vertical scaling in the microservices architecture system.",IEEE conference,no,"['migration', 'process', 'legacy', 'web', 'management', 'monolithic', 'modern', 'company', 'migration', 'monolithic', 'complex', 'process', 'involves', 'independent', 'work', 'together', 'provide', 'complete', 'functionality', 'legacy', 'provides', 'process', 'despite', 'extensive', 'planning', 'limitation', 'difficulty', 'arise', 'primarily', 'related', 'code', 'updating', 'technology', 'mitigate', 'difficulty', 'necessary', 'first', 'document', 'properly', 'analyze', 'advantage', 'disadvantage', 'use', 'case', 'existence', 'similar', 'migration', 'process', 'among', 'others', 'gathering', 'comprehensive', 'documentation', 'legacy', 'also', 'essential', 'establish', 'solid', 'foundation', 'requirement', 'functionality', 'conduct', 'migration', 'finally', 'choice', 'tool', 'case', 'offered', 'spring', 'spring', 'boot', 'docker', 'greatly', 'facilitate', 'process', 'migration', 'offer', 'benefit', 'easier', 'implementation', 'new', 'functionality', 'problem', 'detection', 'improved', 'availability', 'enhanced', 'user', 'experience', 'therefore', 'research', 'paper', 'analyze', 'current', 'company', 'dedicated', 'providing', 'city', 'b', 'design', 'based', 'c', 'develop', 'prototype', 'help', 'u', 'validate', 'feasibility', 'proposed', 'thus', 'contributing', 'better', 'performance', 'applying', 'fault', 'tolerance', 'possibility', 'horizontal', 'vertical', 'scaling']"
"Paradigm Shift From Monolithic to Microservices Microservices have been making waves among forward-thinking application development organizations. In the realm of software development, software architecture holds paramount importance because it serves as a guiding force to shape the entire life cycle of a software system. Software architecture is a foundation for complex digital components built upon a software system. Within this domain, two prevalent paradigms, monolithic and service-oriented architecture (SOA), stand distinct. While monolithic simplifies development using its integrated structure, SOA reduces complexity through modular services. However, both paradigms suffer severe scalability, development cycle, and flexibility challenges. Subsequently, microservice architecture as a modern paradigm emerges to overcome these challenges. This paper presents an in-depth analysis of the paradigm shift from monolithic to microservice architecture. It begins with exploring the monolithic and SOA conceptual landscape and their pros and cons. After that, we delve into the microservice platform, including its basic architecture and implementation stages. Furthermore, we provide the trend of the paradigm shift that highlights the recent developments in the field and identifies the research challenges associated with it. Thus, the paper brings multiple research dimensions for the researchers and lets the software and application development teams improve resilience and expedite their time to market.",Paradigm Shift From Monolithic to Microservices,"Microservices have been making waves among forward-thinking application development organizations. In the realm of software development, software architecture holds paramount importance because it serves as a guiding force to shape the entire life cycle of a software system. Software architecture is a foundation for complex digital components built upon a software system. Within this domain, two prevalent paradigms, monolithic and service-oriented architecture (SOA), stand distinct. While monolithic simplifies development using its integrated structure, SOA reduces complexity through modular services. However, both paradigms suffer severe scalability, development cycle, and flexibility challenges. Subsequently, microservice architecture as a modern paradigm emerges to overcome these challenges. This paper presents an in-depth analysis of the paradigm shift from monolithic to microservice architecture. It begins with exploring the monolithic and SOA conceptual landscape and their pros and cons. After that, we delve into the microservice platform, including its basic architecture and implementation stages. Furthermore, we provide the trend of the paradigm shift that highlights the recent developments in the field and identifies the research challenges associated with it. Thus, the paper brings multiple research dimensions for the researchers and lets the software and application development teams improve resilience and expedite their time to market.",IEEE conference,no,"['paradigm', 'shift', 'monolithic', 'making', 'among', 'development', 'organization', 'realm', 'development', 'paramount', 'importance', 'serf', 'shape', 'entire', 'life', 'cycle', 'foundation', 'complex', 'digital', 'built', 'upon', 'within', 'domain', 'two', 'prevalent', 'paradigm', 'monolithic', 'soa', 'stand', 'distinct', 'monolithic', 'simplifies', 'development', 'using', 'integrated', 'structure', 'soa', 'reduces', 'complexity', 'modular', 'however', 'paradigm', 'suffer', 'severe', 'scalability', 'development', 'cycle', 'flexibility', 'challenge', 'subsequently', 'modern', 'paradigm', 'emerges', 'overcome', 'challenge', 'paper', 'present', 'analysis', 'paradigm', 'shift', 'monolithic', 'begin', 'exploring', 'monolithic', 'soa', 'conceptual', 'landscape', 'pro', 'con', 'platform', 'including', 'basic', 'implementation', 'stage', 'furthermore', 'provide', 'trend', 'paradigm', 'shift', 'highlight', 'recent', 'development', 'field', 'identifies', 'research', 'challenge', 'associated', 'thus', 'paper', 'brings', 'multiple', 'research', 'dimension', 'researcher', 'let', 'development', 'team', 'improve', 'resilience', 'time', 'market']"
"A microservice based reference architecture model in the context of enterprise architecture In the service oriented, customer experience centric and customer changing demand driven market environment, ICT is becoming the leading enabler and partner of the modern enterprise business. More and more companies are transformed into more or pure digital style and virtual organized enterprises that are enabled and supported by a group of business oriented and microservice based applications and modules that are new to most of the companies and enterprises, both business and technical solution staff. This paper presents a microservice based reference architecture model with clear understanding and definition of the concept of microservice and key architectural components and building blocks for implementing and managing enterprise microservices in the context of enterprise architecture. This reference architecture model can be used as the pragmatic guidance for both business and IT professionals when they develop the enterprise IT transformation architecture solutions so that the API and microservice relevant technologies could be used properly at enterprise level without confusion. This paper also highlights a set of key architectural issues and provides corresponding recommendations when APIs and microsevices are leveraged within a company at enterprise level.",A microservice based reference architecture model in the context of enterprise architecture,"In the service oriented, customer experience centric and customer changing demand driven market environment, ICT is becoming the leading enabler and partner of the modern enterprise business. More and more companies are transformed into more or pure digital style and virtual organized enterprises that are enabled and supported by a group of business oriented and microservice based applications and modules that are new to most of the companies and enterprises, both business and technical solution staff. This paper presents a microservice based reference architecture model with clear understanding and definition of the concept of microservice and key architectural components and building blocks for implementing and managing enterprise microservices in the context of enterprise architecture. This reference architecture model can be used as the pragmatic guidance for both business and IT professionals when they develop the enterprise IT transformation architecture solutions so that the API and microservice relevant technologies could be used properly at enterprise level without confusion. This paper also highlights a set of key architectural issues and provides corresponding recommendations when APIs and microsevices are leveraged within a company at enterprise level.",IEEE conference,no,"['based', 'reference', 'model', 'context', 'enterprise', 'oriented', 'customer', 'experience', 'centric', 'customer', 'changing', 'demand', 'driven', 'market', 'environment', 'ict', 'becoming', 'leading', 'enabler', 'partner', 'modern', 'enterprise', 'business', 'company', 'transformed', 'digital', 'style', 'virtual', 'organized', 'enterprise', 'enabled', 'supported', 'group', 'business', 'oriented', 'based', 'module', 'new', 'company', 'enterprise', 'business', 'technical', 'solution', 'paper', 'present', 'based', 'reference', 'model', 'clear', 'understanding', 'definition', 'concept', 'key', 'architectural', 'building', 'block', 'implementing', 'managing', 'enterprise', 'context', 'enterprise', 'reference', 'model', 'used', 'pragmatic', 'guidance', 'business', 'professional', 'develop', 'enterprise', 'transformation', 'solution', 'api', 'relevant', 'technology', 'could', 'used', 'properly', 'enterprise', 'level', 'without', 'paper', 'also', 'highlight', 'set', 'key', 'architectural', 'issue', 'provides', 'corresponding', 'recommendation', 'apis', 'within', 'company', 'enterprise', 'level']"
"Model-based engineering for microservice architectures using Enterprise Integration Patterns for inter-service communication Microservices need to communicate via inter-service communication mechanism. This leads to service integration that requires the aspect of messaging and event handling to be considered during the specification of microservices. Therefore, the application of Enterprise Integration Patterns (EIP) in the context of the design of microservice architectures seems to be a promising approach for microservice architecture engineering. This paper presents a model-based approach for microservice architectural design and service integration through formal models using the UML and UML profiles. A domain model (bounded contexts) is used as a starting point. UML component diagrams are extended so that microservices can be modeled. Enterprise integration patterns are applied to the microservice diagrams providing a precise microservice specification that can be used for further simulations, transformations, or code generation tasks.",Model-based engineering for microservice architectures using Enterprise Integration Patterns for inter-service communication,"Microservices need to communicate via inter-service communication mechanism. This leads to service integration that requires the aspect of messaging and event handling to be considered during the specification of microservices. Therefore, the application of Enterprise Integration Patterns (EIP) in the context of the design of microservice architectures seems to be a promising approach for microservice architecture engineering. This paper presents a model-based approach for microservice architectural design and service integration through formal models using the UML and UML profiles. A domain model (bounded contexts) is used as a starting point. UML component diagrams are extended so that microservices can be modeled. Enterprise integration patterns are applied to the microservice diagrams providing a precise microservice specification that can be used for further simulations, transformations, or code generation tasks.",IEEE conference,no,"['engineering', 'using', 'enterprise', 'integration', 'pattern', 'communication', 'need', 'communicate', 'via', 'communication', 'mechanism', 'lead', 'integration', 'requires', 'aspect', 'messaging', 'event', 'handling', 'considered', 'specification', 'therefore', 'enterprise', 'integration', 'pattern', 'context', 'design', 'seems', 'promising', 'engineering', 'paper', 'present', 'architectural', 'design', 'integration', 'formal', 'model', 'using', 'uml', 'uml', 'profile', 'domain', 'model', 'bounded', 'context', 'used', 'starting', 'point', 'uml', 'diagram', 'extended', 'modeled', 'enterprise', 'integration', 'pattern', 'applied', 'diagram', 'providing', 'precise', 'specification', 'used', 'simulation', 'transformation', 'code', 'generation', 'task']"
"Proposed Methodology for Designing a Microservice Architecture The changing needs of the enterprise require the manageability of its information system. Therefore, it is crucial to absorb these changes by orienting the design of the information system towards a modern architecture that decomposes the monolithic application into autonomous services. This paper proposes an enterprise architecture methodological framework to design the so-called microservice architecture known as MSA. Our approach is to describe the similarities between the MSA style of architecture and the service-oriented architecture known as SOA, the latter having a rich research literature focused on exploiting the methodology for designing services in a service architecture. The result of the comparative study indicates that the ideology for designing a SOA is identical as MSA which ultimately relies on decomposing applications into smaller components with a smaller and more manageable footprint. Thus, we conclude that it is preferable to use the adapted enterprise architecture methodology for SOA to design MSA.",Proposed Methodology for Designing a Microservice Architecture,"The changing needs of the enterprise require the manageability of its information system. Therefore, it is crucial to absorb these changes by orienting the design of the information system towards a modern architecture that decomposes the monolithic application into autonomous services. This paper proposes an enterprise architecture methodological framework to design the so-called microservice architecture known as MSA. Our approach is to describe the similarities between the MSA style of architecture and the service-oriented architecture known as SOA, the latter having a rich research literature focused on exploiting the methodology for designing services in a service architecture. The result of the comparative study indicates that the ideology for designing a SOA is identical as MSA which ultimately relies on decomposing applications into smaller components with a smaller and more manageable footprint. Thus, we conclude that it is preferable to use the adapted enterprise architecture methodology for SOA to design MSA.",IEEE conference,no,"['proposed', 'methodology', 'designing', 'changing', 'need', 'enterprise', 'require', 'manageability', 'information', 'therefore', 'crucial', 'change', 'design', 'information', 'towards', 'modern', 'decomposes', 'monolithic', 'autonomous', 'paper', 'proposes', 'enterprise', 'framework', 'design', 'known', 'msa', 'describe', 'similarity', 'msa', 'style', 'known', 'soa', 'latter', 'rich', 'research', 'literature', 'focused', 'exploiting', 'methodology', 'designing', 'result', 'comparative', 'study', 'designing', 'soa', 'msa', 'relies', 'decomposing', 'smaller', 'smaller', 'manageable', 'footprint', 'thus', 'conclude', 'use', 'adapted', 'enterprise', 'methodology', 'soa', 'design', 'msa']"
"Perspectives for Selecting Cloud Microservices In the era of Cloud platforms, microservices have multiplied, becoming a de facto standard for software reuse. With so many alternatives, a challenge still open is to find the most adequate one, given a set of requirements and priorities. In this context, we present DIRECTOR, a Cloud microservice selection framework based on different perspectives: technical, social and semantical. Emerging results prove that it can support software acquisition via discovery and comparison of microservices, being able to recommend the fittest among hundreds of candidates.",Perspectives for Selecting Cloud Microservices,"In the era of Cloud platforms, microservices have multiplied, becoming a de facto standard for software reuse. With so many alternatives, a challenge still open is to find the most adequate one, given a set of requirements and priorities. In this context, we present DIRECTOR, a Cloud microservice selection framework based on different perspectives: technical, social and semantical. Emerging results prove that it can support software acquisition via discovery and comparison of microservices, being able to recommend the fittest among hundreds of candidates.",IEEE conference,no,"['perspective', 'selecting', 'era', 'platform', 'becoming', 'de', 'facto', 'standard', 'reuse', 'many', 'alternative', 'challenge', 'still', 'open', 'find', 'adequate', 'one', 'given', 'set', 'requirement', 'priority', 'context', 'present', 'director', 'selection', 'framework', 'based', 'different', 'perspective', 'technical', 'social', 'emerging', 'result', 'support', 'acquisition', 'via', 'discovery', 'comparison', 'able', 'recommend', 'among', 'hundred', 'candidate']"
"A Rule-based System for Automated Generation of Serverless-Microservices Architecture Software being ubiquitous in today's systems and business operations, it's highly important to structure the high-level architecture of a software application accordingly to deliver the expected customer requirements while accounting for quality measures such as scalability, high availability and high performance. We propose The Architect, a rule-based system for serverless-microservices based high-level architecture generation. In the process of auto generating serverless-microservices high-level architecture, TheArchitect will preserve the highlighted quality measures. It will also provide a tool based support for the high-level architecture designing process of the software architect. Any software developer will be able to use TheArchitect to generate a proper architecture minimizing the involvement of a software architect. Furthermore, the positives of microservices and serverless technologies have made a significant impact on the software engineering community in terms of shifting from the era of building large monolith applications containing overly complex designs, to microservices and serverless based technologies. Hence The Architect focuses on generating best fitted microservices and serverless based high-level architecture for a given application.",A Rule-based System for Automated Generation of Serverless-Microservices Architecture,"Software being ubiquitous in today's systems and business operations, it's highly important to structure the high-level architecture of a software application accordingly to deliver the expected customer requirements while accounting for quality measures such as scalability, high availability and high performance. We propose The Architect, a rule-based system for serverless-microservices based high-level architecture generation. In the process of auto generating serverless-microservices high-level architecture, TheArchitect will preserve the highlighted quality measures. It will also provide a tool based support for the high-level architecture designing process of the software architect. Any software developer will be able to use TheArchitect to generate a proper architecture minimizing the involvement of a software architect. Furthermore, the positives of microservices and serverless technologies have made a significant impact on the software engineering community in terms of shifting from the era of building large monolith applications containing overly complex designs, to microservices and serverless based technologies. Hence The Architect focuses on generating best fitted microservices and serverless based high-level architecture for a given application.",IEEE conference,no,"['automated', 'generation', 'ubiquitous', 'today', 'business', 'operation', 'highly', 'important', 'structure', 'accordingly', 'deliver', 'expected', 'customer', 'requirement', 'accounting', 'quality', 'measure', 'scalability', 'high', 'availability', 'high', 'performance', 'propose', 'architect', 'based', 'generation', 'process', 'auto', 'generating', 'preserve', 'quality', 'measure', 'also', 'provide', 'tool', 'based', 'support', 'designing', 'process', 'architect', 'developer', 'able', 'use', 'generate', 'proper', 'minimizing', 'involvement', 'architect', 'furthermore', 'positive', 'serverless', 'technology', 'made', 'significant', 'impact', 'engineering', 'community', 'term', 'shifting', 'era', 'building', 'large', 'monolith', 'containing', 'complex', 'design', 'serverless', 'based', 'technology', 'hence', 'architect', 'focus', 'generating', 'best', 'serverless', 'based', 'given']"
"Design and implementation of online judgment system based on microservice architecture and Docker The online judgment system tests whether the source code can pass the problem’s test cases in the programming contests. Users only need to click the submit button on the front-end page, and the system will return the judge results after a certain period. Although there are many online judgment systems for programming contests, there are few online judgment systems for programming teaching and adopting a microservice architecture. This paper aims to design and implement an online judgment system for programming teaching. The system’s front-end adopts Vue and Element-Ui framework, and the back-end adopts microservice architecture for development. On the one hand, using the system can improve students' programming ability and teachers' efficiency and accuracy in marking programming assignments. On the other hand, the system has an online contest function, which can hold contests or be used as an examination platform to assess students' actual levels.",Design and implementation of online judgment system based on microservice architecture and Docker,"The online judgment system tests whether the source code can pass the problem’s test cases in the programming contests. Users only need to click the submit button on the front-end page, and the system will return the judge results after a certain period. Although there are many online judgment systems for programming contests, there are few online judgment systems for programming teaching and adopting a microservice architecture. This paper aims to design and implement an online judgment system for programming teaching. The system’s front-end adopts Vue and Element-Ui framework, and the back-end adopts microservice architecture for development. On the one hand, using the system can improve students' programming ability and teachers' efficiency and accuracy in marking programming assignments. On the other hand, the system has an online contest function, which can hold contests or be used as an examination platform to assess students' actual levels.",IEEE conference,no,"['design', 'implementation', 'online', 'judgment', 'based', 'docker', 'online', 'judgment', 'test', 'whether', 'source', 'code', 'problem', 'test', 'case', 'programming', 'contest', 'user', 'need', 'result', 'certain', 'period', 'although', 'many', 'online', 'judgment', 'programming', 'contest', 'online', 'judgment', 'programming', 'teaching', 'adopting', 'paper', 'aim', 'design', 'implement', 'online', 'judgment', 'programming', 'teaching', 'adopts', 'framework', 'adopts', 'development', 'one', 'hand', 'using', 'improve', 'student', 'programming', 'ability', 'efficiency', 'accuracy', 'programming', 'assignment', 'hand', 'online', 'contest', 'function', 'contest', 'used', 'platform', 'assess', 'student', 'actual', 'level']"
"Microservice Architectures for Scalability, Agility and Reliability in E-Commerce Microservice architectures provide small services that may be deployed and scaled independently of each other, and may employ different middleware stacks for their implementation. Microservice architectures intend to overcome the shortcomings of monolithic architectures where all of the application's logic and data are managed in one deployable unit. We present how the properties of microservice architectures facilitate scalability, agility and reliability at otto.de, which is one of the biggest European e-commerce platforms. In particular, we discuss vertical decomposition into self contained systems and appropriate granularity of microservices as well as coupling, integration, scalability and monitoring of microservices at otto.de. While increasing agility to more than 500 live deployments per week, high reliability is achieved by means of automated quality assurance with continuous integration and deployment.","Microservice Architectures for Scalability, Agility and Reliability in E-Commerce","Microservice architectures provide small services that may be deployed and scaled independently of each other, and may employ different middleware stacks for their implementation. Microservice architectures intend to overcome the shortcomings of monolithic architectures where all of the application's logic and data are managed in one deployable unit. We present how the properties of microservice architectures facilitate scalability, agility and reliability at otto.de, which is one of the biggest European e-commerce platforms. In particular, we discuss vertical decomposition into self contained systems and appropriate granularity of microservices as well as coupling, integration, scalability and monitoring of microservices at otto.de. While increasing agility to more than 500 live deployments per week, high reliability is achieved by means of automated quality assurance with continuous integration and deployment.",IEEE conference,no,"['scalability', 'agility', 'reliability', 'provide', 'small', 'may', 'deployed', 'scaled', 'independently', 'may', 'employ', 'different', 'middleware', 'stack', 'implementation', 'overcome', 'shortcoming', 'monolithic', 'logic', 'managed', 'one', 'deployable', 'unit', 'present', 'property', 'facilitate', 'scalability', 'agility', 'reliability', 'one', 'european', 'platform', 'particular', 'discus', 'vertical', 'decomposition', 'self', 'appropriate', 'granularity', 'well', 'coupling', 'integration', 'scalability', 'monitoring', 'increasing', 'agility', 'live', 'deployment', 'per', 'high', 'reliability', 'achieved', 'mean', 'automated', 'quality', 'assurance', 'continuous', 'integration', 'deployment']"
"RM2MS: A Tool for Automatic Identification of Microservices from Requirements Models Microservices identification is the key development process of cloud-native applications. It focuses on decomposing system into decoupling autonomous components to support development and deployment independently. This process requires sophisticated human efforts for careful requirements analysis and validation to identify the appropriate microservices boundary inside system modules. Our previous work RM2PT can help to achieve a validated requirements model through automatically generating prototypes from original requirements models. The validated requirements model contains the precise definitions of functionality and data structure that can help in microservices identification. In this paper, we present a tool named RM2MS to further alleviate the problem of cloud-native application development to support automatic identification of microservices from the validated requirements model. RM2MS can automatically analyse the relationship between functionality and data structure, and trade-off non-functional factors for microservices identification. We demonstrate that the microservice architecture solution generated by RM2MS demonstrates a average gain of 27.1% over the manual approach in three key metrics(Function-Cohesion, Modularity, and Instability), while exhibiting efficiency that surpasses the manual process by more than 10-fold through five case studies. The proposed approach can be further extended and applied for the cloud-native application development in the software industry. The tool can be downloaded at https://rm2pt.com/advs/rm2ms, and a demo video casting its features is at https://www.youtube.com/watch?v=T71vQDasOSw",RM2MS: A Tool for Automatic Identification of Microservices from Requirements Models,"Microservices identification is the key development process of cloud-native applications. It focuses on decomposing system into decoupling autonomous components to support development and deployment independently. This process requires sophisticated human efforts for careful requirements analysis and validation to identify the appropriate microservices boundary inside system modules. Our previous work RM2PT can help to achieve a validated requirements model through automatically generating prototypes from original requirements models. The validated requirements model contains the precise definitions of functionality and data structure that can help in microservices identification. In this paper, we present a tool named RM2MS to further alleviate the problem of cloud-native application development to support automatic identification of microservices from the validated requirements model. RM2MS can automatically analyse the relationship between functionality and data structure, and trade-off non-functional factors for microservices identification. We demonstrate that the microservice architecture solution generated by RM2MS demonstrates a average gain of 27.1% over the manual approach in three key metrics(Function-Cohesion, Modularity, and Instability), while exhibiting efficiency that surpasses the manual process by more than 10-fold through five case studies. The proposed approach can be further extended and applied for the cloud-native application development in the software industry. The tool can be downloaded at https://rm2pt.com/advs/rm2ms, and a demo video casting its features is at https://www.youtube.com/watch?v=T71vQDasOSw",IEEE conference,no,"['tool', 'automatic', 'identification', 'requirement', 'model', 'identification', 'key', 'development', 'process', 'focus', 'decomposing', 'decoupling', 'autonomous', 'support', 'development', 'deployment', 'independently', 'process', 'requires', 'sophisticated', 'human', 'effort', 'careful', 'requirement', 'analysis', 'validation', 'identify', 'appropriate', 'boundary', 'inside', 'module', 'previous', 'work', 'help', 'achieve', 'validated', 'requirement', 'model', 'automatically', 'generating', 'prototype', 'original', 'requirement', 'model', 'validated', 'requirement', 'model', 'contains', 'precise', 'definition', 'functionality', 'structure', 'help', 'identification', 'paper', 'present', 'tool', 'named', 'problem', 'development', 'support', 'automatic', 'identification', 'validated', 'requirement', 'model', 'automatically', 'analyse', 'relationship', 'functionality', 'structure', 'factor', 'identification', 'demonstrate', 'solution', 'generated', 'demonstrates', 'average', 'gain', 'manual', 'three', 'key', 'metric', 'modularity', 'efficiency', 'manual', 'process', 'five', 'case', 'study', 'proposed', 'extended', 'applied', 'development', 'industry', 'tool', 'demo', 'video', 'feature']"
"Monolithic to Microservices Architecture - A Framework for Design and Implementation Systems for scalable and reliable software applications can be realised only after a thorough consideration of the design and architecture of the underlying components. The ubiquitous use of distributed architecture to design and implement building applications serves as an impetus to delve into analysing various architectural models such as monoliths and microservices. Through the design and implementation of a modern banking system, this research paper makes a comprehensive analysis of the different aspects of monolithic and microservice architectures. The paper highlights various logistical concerns and strategies - from discussing database patterns and communication strategies to deployment methods. The paper also outlines a step-wise, algorithmic approach to aid software engineering practitioners in migrating from a monolith to a microservice. The aforementioned approach was implemented in developing the banking application, and the result was a modular, functional and scalable microservice system. The quantitative and qualitative analysis of the results were encouraging, which attests to the feasibility of the proposed methodology.",Monolithic to Microservices Architecture - A Framework for Design and Implementation,"Systems for scalable and reliable software applications can be realised only after a thorough consideration of the design and architecture of the underlying components. The ubiquitous use of distributed architecture to design and implement building applications serves as an impetus to delve into analysing various architectural models such as monoliths and microservices. Through the design and implementation of a modern banking system, this research paper makes a comprehensive analysis of the different aspects of monolithic and microservice architectures. The paper highlights various logistical concerns and strategies - from discussing database patterns and communication strategies to deployment methods. The paper also outlines a step-wise, algorithmic approach to aid software engineering practitioners in migrating from a monolith to a microservice. The aforementioned approach was implemented in developing the banking application, and the result was a modular, functional and scalable microservice system. The quantitative and qualitative analysis of the results were encouraging, which attests to the feasibility of the proposed methodology.",IEEE conference,no,"['monolithic', 'framework', 'design', 'implementation', 'scalable', 'reliable', 'consideration', 'design', 'underlying', 'ubiquitous', 'use', 'distributed', 'design', 'implement', 'building', 'serf', 'various', 'architectural', 'model', 'monolith', 'design', 'implementation', 'modern', 'banking', 'research', 'paper', 'make', 'comprehensive', 'analysis', 'different', 'aspect', 'monolithic', 'paper', 'highlight', 'various', 'concern', 'strategy', 'database', 'pattern', 'communication', 'strategy', 'deployment', 'method', 'paper', 'also', 'outline', 'aid', 'engineering', 'practitioner', 'migrating', 'monolith', 'aforementioned', 'implemented', 'developing', 'banking', 'result', 'modular', 'functional', 'scalable', 'quantitative', 'qualitative', 'analysis', 'result', 'feasibility', 'proposed', 'methodology']"
Smart city service system engineering based on microservices architecture: Case study: Government of tangerang city Smart City can be viewed as a service system so that the vision of a city to create valuable services for the citizens can be realized by creating a good service system. In this paper the good service system engineering referred to will be realized by using service system engineering methodology with the top-down and holistic approach. This methodology is used to produce a service system design as a solution to solve the problems that arise with current approaches. This research uses the government of Tangerang City as a case study. The contribution of this research is to provide systematic guidance on how to apply service system engineering methodology. The result of this study is a smart city service system engineering based on microservices architecture.,Smart city service system engineering based on microservices architecture: Case study: Government of tangerang city,Smart City can be viewed as a service system so that the vision of a city to create valuable services for the citizens can be realized by creating a good service system. In this paper the good service system engineering referred to will be realized by using service system engineering methodology with the top-down and holistic approach. This methodology is used to produce a service system design as a solution to solve the problems that arise with current approaches. This research uses the government of Tangerang City as a case study. The contribution of this research is to provide systematic guidance on how to apply service system engineering methodology. The result of this study is a smart city service system engineering based on microservices architecture.,IEEE conference,no,"['smart', 'city', 'engineering', 'based', 'case', 'study', 'government', 'city', 'smart', 'city', 'vision', 'city', 'create', 'valuable', 'citizen', 'realized', 'creating', 'good', 'paper', 'good', 'engineering', 'referred', 'realized', 'using', 'engineering', 'methodology', 'holistic', 'methodology', 'used', 'produce', 'design', 'solution', 'solve', 'problem', 'arise', 'current', 'research', 'us', 'government', 'city', 'case', 'study', 'contribution', 'research', 'provide', 'systematic', 'guidance', 'apply', 'engineering', 'methodology', 'result', 'study', 'smart', 'city', 'engineering', 'based']"
"Acceptance Tests over Microservices Architecture using Behaviour-Driven Development The application of software quality assurance practices upon microservices architectures can be somehow challenging, mainly caused by the high granularity with low coupling of its software components. Since this granularity is not visible to the end user, it is difficult to assess the whole system behaviour. This paper proposes the use of Behaviour-Driven Development (BDD) technique on software development based on microservices architecture, by building test scenarios written by non-technical users and developing automated tests on API REST services layer, enabling the ability to match system results to end-user needs. Using a real scenario of a pay roll system, the applicability of the Behave BDD tool was assessed for acceptance tests automation.",Acceptance Tests over Microservices Architecture using Behaviour-Driven Development,"The application of software quality assurance practices upon microservices architectures can be somehow challenging, mainly caused by the high granularity with low coupling of its software components. Since this granularity is not visible to the end user, it is difficult to assess the whole system behaviour. This paper proposes the use of Behaviour-Driven Development (BDD) technique on software development based on microservices architecture, by building test scenarios written by non-technical users and developing automated tests on API REST services layer, enabling the ability to match system results to end-user needs. Using a real scenario of a pay roll system, the applicability of the Behave BDD tool was assessed for acceptance tests automation.",IEEE conference,no,"['acceptance', 'test', 'using', 'development', 'quality', 'assurance', 'practice', 'upon', 'challenging', 'mainly', 'caused', 'high', 'granularity', 'low', 'coupling', 'since', 'granularity', 'end', 'user', 'difficult', 'assess', 'whole', 'behaviour', 'paper', 'proposes', 'use', 'development', 'technique', 'development', 'based', 'building', 'test', 'scenario', 'written', 'user', 'developing', 'automated', 'test', 'api', 'rest', 'layer', 'enabling', 'ability', 'match', 'result', 'need', 'using', 'real', 'scenario', 'applicability', 'behave', 'tool', 'assessed', 'acceptance', 'test', 'automation']"
"MicroIP: A general-purpose microservice-based integration platform The development of large-scale software systems is usually supported by integration platforms, which provide connectivity and mediation capabilities to facilitate the integration of heterogeneous and distributed applications. Integration platforms have traditionally been built as monolithic systems which, in some of the current contexts (e.g. market's high pace of demand, large amount of users and data), present issues in terms of scalability, maintainability and fault tolerance, among others. In turn, microservices architecture is an approach for developing applications as a set of small independent services, which may contribute to address such limitations (e.g. maintaining and scaling services independently, according to their specific needs). Indeed, various integration platform proposals leveraging this approach have emerged during the last years. However, those proposals are domain-specific and/or they do not provide insights regarding the architecture and implementation of the platform. This paper proposes a general-purpose microservice-based integration platform, which aims to address limitations of monolithic solutions and of the aforementioned existing proposals. Our work comprises the definition of the platform and its main functionality, a description of its microservice-based architecture, and implementation alternatives as well as prototypes for some of its main components.",MicroIP: A general-purpose microservice-based integration platform,"The development of large-scale software systems is usually supported by integration platforms, which provide connectivity and mediation capabilities to facilitate the integration of heterogeneous and distributed applications. Integration platforms have traditionally been built as monolithic systems which, in some of the current contexts (e.g. market's high pace of demand, large amount of users and data), present issues in terms of scalability, maintainability and fault tolerance, among others. In turn, microservices architecture is an approach for developing applications as a set of small independent services, which may contribute to address such limitations (e.g. maintaining and scaling services independently, according to their specific needs). Indeed, various integration platform proposals leveraging this approach have emerged during the last years. However, those proposals are domain-specific and/or they do not provide insights regarding the architecture and implementation of the platform. This paper proposes a general-purpose microservice-based integration platform, which aims to address limitations of monolithic solutions and of the aforementioned existing proposals. Our work comprises the definition of the platform and its main functionality, a description of its microservice-based architecture, and implementation alternatives as well as prototypes for some of its main components.",IEEE conference,no,"['integration', 'platform', 'development', 'usually', 'supported', 'integration', 'platform', 'provide', 'connectivity', 'capability', 'facilitate', 'integration', 'heterogeneous', 'distributed', 'integration', 'platform', 'traditionally', 'built', 'monolithic', 'current', 'context', 'market', 'high', 'pace', 'demand', 'large', 'amount', 'user', 'present', 'issue', 'term', 'scalability', 'maintainability', 'fault', 'tolerance', 'among', 'others', 'turn', 'developing', 'set', 'small', 'independent', 'may', 'contribute', 'address', 'limitation', 'maintaining', 'scaling', 'independently', 'according', 'specific', 'need', 'indeed', 'various', 'integration', 'platform', 'proposal', 'leveraging', 'emerged', 'last', 'year', 'however', 'proposal', 'provide', 'insight', 'regarding', 'implementation', 'platform', 'paper', 'proposes', 'integration', 'platform', 'aim', 'address', 'limitation', 'monolithic', 'solution', 'aforementioned', 'existing', 'proposal', 'work', 'comprises', 'definition', 'platform', 'main', 'functionality', 'description', 'implementation', 'alternative', 'well', 'prototype', 'main']"
"Migration of Monolithic to Microservices With an Extraction Design Pattern in Single Sign on (SSO) Module Using Graph Neural Network (GNN) In software system development, Mololithic is an architectural model that is built in the same codebase. For example, on an online shopping site, there are several feature sections such as user authorization, shopping cart, payment, shipping, and others, all of these features are built in an integrated manner on the same codebase. This is different from the microservice architecture approach. In microservices, each feature or component will be an architecture that is separate from one another. Each of these services will later communicate with each other via a special protocol. Mololithic is increasingly being abandoned because it does not meet scalability needs, if there is a surge in users the Mololithic model tends to be unstable.As happens in the SSO module, in the SSO module process itself there are several functions including registration, authentication, user management, back end API and several other functions where these functions are combined in one unified module. Therefore, a Microservices Architecture model is needed to handle the needs due to the surge in users. Scalability can be regulated because the codebase separation process depends on needs. The migration process from monolithic to microservices is not easy, it requires sufficient knowledge regarding the application to determine the number of nodes and determine the number of services. This research will separate the codebase to determine the number of services using extraction design patterns on function entities, and system logs used in the SSO module at one institution in Indonesia.It is hoped that by extracting functions from the source code and data transaction we will get how many services are running and the nodes that will be used. The modeling process regarding the number of nodes and services will be carried out using a Graph Neural Network (GNN)",Migration of Monolithic to Microservices With an Extraction Design Pattern in Single Sign on (SSO) Module Using Graph Neural Network (GNN),"In software system development, Mololithic is an architectural model that is built in the same codebase. For example, on an online shopping site, there are several feature sections such as user authorization, shopping cart, payment, shipping, and others, all of these features are built in an integrated manner on the same codebase. This is different from the microservice architecture approach. In microservices, each feature or component will be an architecture that is separate from one another. Each of these services will later communicate with each other via a special protocol. Mololithic is increasingly being abandoned because it does not meet scalability needs, if there is a surge in users the Mololithic model tends to be unstable.As happens in the SSO module, in the SSO module process itself there are several functions including registration, authentication, user management, back end API and several other functions where these functions are combined in one unified module. Therefore, a Microservices Architecture model is needed to handle the needs due to the surge in users. Scalability can be regulated because the codebase separation process depends on needs. The migration process from monolithic to microservices is not easy, it requires sufficient knowledge regarding the application to determine the number of nodes and determine the number of services. This research will separate the codebase to determine the number of services using extraction design patterns on function entities, and system logs used in the SSO module at one institution in Indonesia.It is hoped that by extracting functions from the source code and data transaction we will get how many services are running and the nodes that will be used. The modeling process regarding the number of nodes and services will be carried out using a Graph Neural Network (GNN)",IEEE conference,no,"['migration', 'monolithic', 'extraction', 'design', 'pattern', 'single', 'sso', 'module', 'using', 'graph', 'neural', 'network', 'gnn', 'development', 'mololithic', 'architectural', 'model', 'built', 'codebase', 'example', 'online', 'shopping', 'site', 'several', 'feature', 'section', 'user', 'authorization', 'shopping', 'payment', 'others', 'feature', 'built', 'integrated', 'manner', 'codebase', 'different', 'feature', 'separate', 'one', 'another', 'later', 'communicate', 'via', 'special', 'protocol', 'mololithic', 'increasingly', 'meet', 'scalability', 'need', 'surge', 'user', 'mololithic', 'model', 'sso', 'module', 'sso', 'module', 'process', 'several', 'function', 'including', 'registration', 'authentication', 'user', 'management', 'back', 'end', 'api', 'several', 'function', 'function', 'combined', 'one', 'unified', 'module', 'therefore', 'model', 'needed', 'handle', 'need', 'due', 'surge', 'user', 'scalability', 'codebase', 'separation', 'process', 'depends', 'need', 'migration', 'process', 'monolithic', 'easy', 'requires', 'knowledge', 'regarding', 'determine', 'number', 'node', 'determine', 'number', 'research', 'separate', 'codebase', 'determine', 'number', 'using', 'extraction', 'design', 'pattern', 'function', 'entity', 'log', 'used', 'sso', 'module', 'one', 'institution', 'function', 'source', 'code', 'transaction', 'get', 'many', 'running', 'node', 'used', 'modeling', 'process', 'regarding', 'number', 'node', 'carried', 'using', 'graph', 'neural', 'network', 'gnn']"
"Migrating web applications to clouds with microservice architectures For the recent advances of Cloud Computing technologies, cloud applications have been popularity for their rich set of features. Therefore, their practical use for promoting business values can be expected. As such, cloud applications are recognized as a trend for the next generation of existing Web applications, and hence how to migrate these Web applications to the clouds becomes a desired field in the literature. For this need, we present a migration method that employs the well-known microservice architectures to support an effective migration of Web applications into the clouds.",Migrating web applications to clouds with microservice architectures,"For the recent advances of Cloud Computing technologies, cloud applications have been popularity for their rich set of features. Therefore, their practical use for promoting business values can be expected. As such, cloud applications are recognized as a trend for the next generation of existing Web applications, and hence how to migrate these Web applications to the clouds becomes a desired field in the literature. For this need, we present a migration method that employs the well-known microservice architectures to support an effective migration of Web applications into the clouds.",IEEE conference,no,"['migrating', 'web', 'recent', 'advance', 'computing', 'technology', 'popularity', 'rich', 'set', 'feature', 'therefore', 'practical', 'use', 'promoting', 'business', 'value', 'expected', 'recognized', 'trend', 'next', 'generation', 'existing', 'web', 'hence', 'migrate', 'web', 'becomes', 'desired', 'field', 'literature', 'need', 'present', 'migration', 'method', 'employ', 'support', 'effective', 'migration', 'web']"
"Microservices Architecture: Challenges and Proposed Conceptual Design Microservices Architecture has evolved in the recent past and has gained significant popularity offering various benefits as compared to existing architectures addressing various serious concerns of the recent era in Software Engineering. This paper will first briefly introduce the microservices architecture and its evolution being still in inception phase. After enlisting its offered benefits, its envisaged implementation challenges will be addressed including various options available for coping up with those challenges by using empirical and conceptual method. Based on the challenges and available options, a conceptual design of microservices architecture including major components and their role will be proposed. This paper addresses the new comers for understanding of microservices architecture, researchers and the practitioners for verification of evolved conceptual design and future prospects.",Microservices Architecture: Challenges and Proposed Conceptual Design,"Microservices Architecture has evolved in the recent past and has gained significant popularity offering various benefits as compared to existing architectures addressing various serious concerns of the recent era in Software Engineering. This paper will first briefly introduce the microservices architecture and its evolution being still in inception phase. After enlisting its offered benefits, its envisaged implementation challenges will be addressed including various options available for coping up with those challenges by using empirical and conceptual method. Based on the challenges and available options, a conceptual design of microservices architecture including major components and their role will be proposed. This paper addresses the new comers for understanding of microservices architecture, researchers and the practitioners for verification of evolved conceptual design and future prospects.",IEEE conference,no,"['challenge', 'proposed', 'conceptual', 'design', 'evolved', 'recent', 'past', 'gained', 'significant', 'popularity', 'offering', 'various', 'benefit', 'compared', 'existing', 'addressing', 'various', 'concern', 'recent', 'era', 'engineering', 'paper', 'first', 'introduce', 'evolution', 'still', 'phase', 'offered', 'benefit', 'implementation', 'challenge', 'addressed', 'including', 'various', 'option', 'available', 'challenge', 'using', 'empirical', 'conceptual', 'method', 'based', 'challenge', 'available', 'option', 'conceptual', 'design', 'including', 'major', 'role', 'proposed', 'paper', 'address', 'new', 'understanding', 'researcher', 'practitioner', 'verification', 'evolved', 'conceptual', 'design', 'future']"
"Automating the Recognition of Microservices from Business Process Analysis In the evolution from monolithic to modular software architectures, the integration of microservices is increasingly preferred due to its enhancement of operational efficiency and adaptability. Microservices are distinguished by their compact size, cohesive functionality, and independent operation, positioning them as a formidable alternative to traditional architectures. However, identifying optimal microservice configurations poses significant challenges. This study introduces an innovative automated method for deriving microservices from business processes, incorporating a broader BPMN with more activities and dependencies than previous studies to verify the quality of our approach. Our method leverages a cooperative clustering strategy that integrates multiple models to analyze control, information, and semantic connections within business operations. Each dependency type is addressed by a dedicated clustering algorithm, allowing modules to leverage insights from one another, thereby enhancing microservice identification accuracy. We validate our methodology through a case study in a bike rental service, involving 25 distinct activities to evaluate our dependency model’s effectiveness. The findings demonstrate superior precision in microservices generation compared to existing methods, highlighting the advantage of using detailed business operations as a foundation for precise microservice architecture design.",Automating the Recognition of Microservices from Business Process Analysis,"In the evolution from monolithic to modular software architectures, the integration of microservices is increasingly preferred due to its enhancement of operational efficiency and adaptability. Microservices are distinguished by their compact size, cohesive functionality, and independent operation, positioning them as a formidable alternative to traditional architectures. However, identifying optimal microservice configurations poses significant challenges. This study introduces an innovative automated method for deriving microservices from business processes, incorporating a broader BPMN with more activities and dependencies than previous studies to verify the quality of our approach. Our method leverages a cooperative clustering strategy that integrates multiple models to analyze control, information, and semantic connections within business operations. Each dependency type is addressed by a dedicated clustering algorithm, allowing modules to leverage insights from one another, thereby enhancing microservice identification accuracy. We validate our methodology through a case study in a bike rental service, involving 25 distinct activities to evaluate our dependency model’s effectiveness. The findings demonstrate superior precision in microservices generation compared to existing methods, highlighting the advantage of using detailed business operations as a foundation for precise microservice architecture design.",IEEE conference,no,"['automating', 'recognition', 'business', 'process', 'analysis', 'evolution', 'monolithic', 'modular', 'integration', 'increasingly', 'preferred', 'due', 'enhancement', 'operational', 'efficiency', 'adaptability', 'size', 'cohesive', 'functionality', 'independent', 'operation', 'alternative', 'traditional', 'however', 'identifying', 'optimal', 'configuration', 'pose', 'significant', 'challenge', 'study', 'introduces', 'innovative', 'automated', 'method', 'business', 'process', 'incorporating', 'broader', 'activity', 'dependency', 'previous', 'study', 'verify', 'quality', 'method', 'leverage', 'cooperative', 'clustering', 'strategy', 'integrates', 'multiple', 'model', 'analyze', 'control', 'information', 'semantic', 'connection', 'within', 'business', 'operation', 'dependency', 'type', 'addressed', 'dedicated', 'clustering', 'algorithm', 'allowing', 'module', 'leverage', 'insight', 'one', 'another', 'thereby', 'enhancing', 'identification', 'accuracy', 'validate', 'methodology', 'case', 'study', 'involving', 'distinct', 'activity', 'evaluate', 'dependency', 'model', 'effectiveness', 'finding', 'demonstrate', 'superior', 'precision', 'generation', 'compared', 'existing', 'method', 'highlighting', 'advantage', 'using', 'detailed', 'business', 'operation', 'foundation', 'precise', 'design']"
"Monolithic to microservices redesign of event driven integration platform With this paper we presented architectural redesign of SOA (service oriented architecture) integration platform by following principles of microservices design. Presented SOA platform is currently in use for Real estate sector. Number of messages which need to be processed by platform is growing as well as number of new integrations which requires redesign of platform. Redesign should provide ability for scalability, better resource management, maintenance and deployment. To support this, it is necessary to transform integration platform to be microservices based.",Monolithic to microservices redesign of event driven integration platform,"With this paper we presented architectural redesign of SOA (service oriented architecture) integration platform by following principles of microservices design. Presented SOA platform is currently in use for Real estate sector. Number of messages which need to be processed by platform is growing as well as number of new integrations which requires redesign of platform. Redesign should provide ability for scalability, better resource management, maintenance and deployment. To support this, it is necessary to transform integration platform to be microservices based.",IEEE conference,no,"['monolithic', 'redesign', 'event', 'driven', 'integration', 'platform', 'paper', 'presented', 'architectural', 'redesign', 'soa', 'oriented', 'integration', 'platform', 'following', 'principle', 'design', 'presented', 'soa', 'platform', 'currently', 'use', 'real', 'sector', 'number', 'message', 'need', 'processed', 'platform', 'growing', 'well', 'number', 'new', 'integration', 'requires', 'redesign', 'platform', 'redesign', 'provide', 'ability', 'scalability', 'better', 'resource', 'management', 'maintenance', 'deployment', 'support', 'necessary', 'transform', 'integration', 'platform', 'based']"
"Microns: Commands for Building Bubble Microservices Microns are bean-like command objects with structural and behavioral properties that are naturally aligned with microservices design principles and architectural goals. A micron based microservice implementation revolves around building every microservice operation as a micron command. Microns are then logically grouped to virtually realize a bubble microservice. Bubbles facilitate postponing the need for physically defining service domain boundaries until deployment and are meant to be more agile and scalable than traditional microservices implementation approaches. Microns are not limited to building microservices; they are adequate for building many parts of the architecture as long-lived software assets that can be reused in realizing existing and future architecture trends. This paper attempts to re-explore commands through microns and discusses their suitability for building microservices and many other parts of the architecture with the ultimate goal of increasing system's agility, scalability, performance, and consistency. The paper also presents some micron-based applications and designs, where microns serve as high-quality architectural elements that can non-invasively make existing as well as new snippets of logic accessible over the web and other channels with minimal effort.",Microns: Commands for Building Bubble Microservices,"Microns are bean-like command objects with structural and behavioral properties that are naturally aligned with microservices design principles and architectural goals. A micron based microservice implementation revolves around building every microservice operation as a micron command. Microns are then logically grouped to virtually realize a bubble microservice. Bubbles facilitate postponing the need for physically defining service domain boundaries until deployment and are meant to be more agile and scalable than traditional microservices implementation approaches. Microns are not limited to building microservices; they are adequate for building many parts of the architecture as long-lived software assets that can be reused in realizing existing and future architecture trends. This paper attempts to re-explore commands through microns and discusses their suitability for building microservices and many other parts of the architecture with the ultimate goal of increasing system's agility, scalability, performance, and consistency. The paper also presents some micron-based applications and designs, where microns serve as high-quality architectural elements that can non-invasively make existing as well as new snippets of logic accessible over the web and other channels with minimal effort.",IEEE conference,no,"['micron', 'command', 'building', 'bubble', 'micron', 'command', 'object', 'structural', 'property', 'aligned', 'design', 'principle', 'architectural', 'goal', 'micron', 'based', 'implementation', 'around', 'building', 'every', 'operation', 'micron', 'command', 'micron', 'logically', 'realize', 'bubble', 'bubble', 'facilitate', 'need', 'defining', 'domain', 'boundary', 'deployment', 'agile', 'scalable', 'traditional', 'implementation', 'micron', 'limited', 'building', 'adequate', 'building', 'many', 'part', 'asset', 'realizing', 'existing', 'future', 'trend', 'paper', 'attempt', 'command', 'micron', 'discusses', 'building', 'many', 'part', 'goal', 'increasing', 'agility', 'scalability', 'performance', 'consistency', 'paper', 'also', 'present', 'design', 'micron', 'serve', 'architectural', 'element', 'make', 'existing', 'well', 'new', 'logic', 'accessible', 'web', 'channel', 'minimal', 'effort']"
"Towards Integrating Microservices with Adaptable Enterprise Architecture IT environments that consist of a very large number of rather small structures like microservices, Internet of Things (IoT) components, or mobility systems are emerging to support flexible and agile products and services in the age of digital transformation. Biological metaphors of living and adaptable ecosystems with service-oriented enterprise architectures provide the foundation for self-optimizing, resilient run- time environments and distributed information systems. We are extending Enterprise Architecture (EA) methodologies and models that cover a high degree of heterogeneity and distribution to support the digital transformation and related information systems with micro-granular architectures. Our aim is to support flexibility and agile transformation for both IT and business capabilities within adaptable digital enterprise architectures. The present research paper investigates mechanisms for integrating Microservice Architectures (MSA) by extending original enterprise architecture reference models with elements for more flexible architectural metamodels and EA-mini-descriptions.",Towards Integrating Microservices with Adaptable Enterprise Architecture,"IT environments that consist of a very large number of rather small structures like microservices, Internet of Things (IoT) components, or mobility systems are emerging to support flexible and agile products and services in the age of digital transformation. Biological metaphors of living and adaptable ecosystems with service-oriented enterprise architectures provide the foundation for self-optimizing, resilient run- time environments and distributed information systems. We are extending Enterprise Architecture (EA) methodologies and models that cover a high degree of heterogeneity and distribution to support the digital transformation and related information systems with micro-granular architectures. Our aim is to support flexibility and agile transformation for both IT and business capabilities within adaptable digital enterprise architectures. The present research paper investigates mechanisms for integrating Microservice Architectures (MSA) by extending original enterprise architecture reference models with elements for more flexible architectural metamodels and EA-mini-descriptions.",IEEE conference,no,"['towards', 'integrating', 'adaptable', 'enterprise', 'environment', 'consist', 'large', 'number', 'rather', 'small', 'structure', 'like', 'internet', 'thing', 'iot', 'mobility', 'emerging', 'support', 'flexible', 'agile', 'product', 'age', 'digital', 'transformation', 'biological', 'metaphor', 'living', 'adaptable', 'ecosystem', 'enterprise', 'provide', 'foundation', 'resilient', 'time', 'environment', 'distributed', 'information', 'extending', 'enterprise', 'ea', 'methodology', 'model', 'cover', 'high', 'degree', 'heterogeneity', 'distribution', 'support', 'digital', 'transformation', 'related', 'information', 'aim', 'support', 'flexibility', 'agile', 'transformation', 'business', 'capability', 'within', 'adaptable', 'digital', 'enterprise', 'present', 'research', 'paper', 'investigates', 'mechanism', 'integrating', 'msa', 'extending', 'original', 'enterprise', 'reference', 'model', 'element', 'flexible', 'architectural']"
"PF4MD: A Microservice Decomposition Tool Combining Problem Frames Microservices have an important position in today's software development, enabling a highly cohesive and low-coupling way of service organization. To address the complexity issues of inter-service communication, data consistency and distributed system management in the microservice decomposition process, we extend the traditional problem diagram based on the commonality of microservice decomposition and problem frames: the causal domain in the problem domain is further divided into communication components and business components. We design a microservice decomposition tool PF4MD to visualize service requirements and design problem decomposition and complexity calculation rules. We evaluated it with cases such as the Smart Building system and obtained a strategy similar to manual decomposition but with more intuitive and finer granularity, thus helping architects to make more efficient decisions and understand the decomposition process more clearly in system requirements.",PF4MD: A Microservice Decomposition Tool Combining Problem Frames,"Microservices have an important position in today's software development, enabling a highly cohesive and low-coupling way of service organization. To address the complexity issues of inter-service communication, data consistency and distributed system management in the microservice decomposition process, we extend the traditional problem diagram based on the commonality of microservice decomposition and problem frames: the causal domain in the problem domain is further divided into communication components and business components. We design a microservice decomposition tool PF4MD to visualize service requirements and design problem decomposition and complexity calculation rules. We evaluated it with cases such as the Smart Building system and obtained a strategy similar to manual decomposition but with more intuitive and finer granularity, thus helping architects to make more efficient decisions and understand the decomposition process more clearly in system requirements.",IEEE conference,no,"['decomposition', 'tool', 'combining', 'problem', 'frame', 'important', 'today', 'development', 'enabling', 'highly', 'cohesive', 'way', 'organization', 'address', 'complexity', 'issue', 'communication', 'consistency', 'distributed', 'management', 'decomposition', 'process', 'extend', 'traditional', 'problem', 'diagram', 'based', 'decomposition', 'problem', 'frame', 'causal', 'domain', 'problem', 'domain', 'divided', 'communication', 'business', 'design', 'decomposition', 'tool', 'visualize', 'requirement', 'design', 'problem', 'decomposition', 'complexity', 'calculation', 'rule', 'evaluated', 'case', 'smart', 'building', 'obtained', 'strategy', 'similar', 'manual', 'decomposition', 'intuitive', 'finer', 'granularity', 'thus', 'helping', 'architect', 'make', 'efficient', 'decision', 'understand', 'decomposition', 'process', 'clearly', 'requirement']"
"Dealing with Anti-Patterns When Migrating from Monoliths to Microservices: Challenges and Research Directions Microservices refers to a highly effective architectural style for organizations to build cloud-native applications. However, in most real-world cases, the adoption of microservices is not a deliberate choice made by organizations. Instead, the shift towards microservices is compelled by the urgent necessity to overcome the constraints imposed by traditional monolithic architectures. As a result, organizations typically seek to migrate their existing systems to microservices incrementally and with caution to ensure safe migration. To achieve this particular goal, the industry has provided various strategies and patterns. However, many practitioners overlook a very important aspect while migrating to microservices, which is the presence of anti-patterns and their potential evolution during the migration phases. Therefore, studies and investigations are needed to assist the migration task to microservices against anti-patterns. Accordingly, this paper brings attention to a research gap concerning the impact of anti-patterns on migrating to microservices. This gap is addressed through the formulation of four research questions. The main aim is to inspire the academic community to conduct additional investigations in this area, aiming to improve migration quality and facilitate the development of more efficient architectures.",Dealing with Anti-Patterns When Migrating from Monoliths to Microservices: Challenges and Research Directions,"Microservices refers to a highly effective architectural style for organizations to build cloud-native applications. However, in most real-world cases, the adoption of microservices is not a deliberate choice made by organizations. Instead, the shift towards microservices is compelled by the urgent necessity to overcome the constraints imposed by traditional monolithic architectures. As a result, organizations typically seek to migrate their existing systems to microservices incrementally and with caution to ensure safe migration. To achieve this particular goal, the industry has provided various strategies and patterns. However, many practitioners overlook a very important aspect while migrating to microservices, which is the presence of anti-patterns and their potential evolution during the migration phases. Therefore, studies and investigations are needed to assist the migration task to microservices against anti-patterns. Accordingly, this paper brings attention to a research gap concerning the impact of anti-patterns on migrating to microservices. This gap is addressed through the formulation of four research questions. The main aim is to inspire the academic community to conduct additional investigations in this area, aiming to improve migration quality and facilitate the development of more efficient architectures.",IEEE conference,no,"['dealing', 'migrating', 'monolith', 'challenge', 'research', 'direction', 'refers', 'highly', 'effective', 'architectural', 'style', 'organization', 'build', 'however', 'case', 'adoption', 'choice', 'made', 'organization', 'instead', 'shift', 'towards', 'urgent', 'necessity', 'overcome', 'constraint', 'traditional', 'monolithic', 'result', 'organization', 'typically', 'migrate', 'existing', 'ensure', 'safe', 'migration', 'achieve', 'particular', 'goal', 'industry', 'provided', 'various', 'strategy', 'pattern', 'however', 'many', 'practitioner', 'overlook', 'important', 'aspect', 'migrating', 'presence', 'potential', 'evolution', 'migration', 'phase', 'therefore', 'study', 'investigation', 'needed', 'assist', 'migration', 'task', 'accordingly', 'paper', 'brings', 'attention', 'research', 'gap', 'concerning', 'impact', 'migrating', 'gap', 'addressed', 'formulation', 'four', 'research', 'question', 'main', 'aim', 'academic', 'community', 'conduct', 'additional', 'investigation', 'area', 'aiming', 'improve', 'migration', 'quality', 'facilitate', 'development', 'efficient']"
"Automated Reverse Engineering for MoM-Based Microservices (ARE4MOM) Using Static Analysis Context: Understanding architecture is crucial during the development of Message-oriented Middleware-based (MoM-based) microservices. Such architecture serves as a prerequisite for system maintenance, comprehension, and refactoring. However, maintaining an accurate architecture document becomes challenging due to continuous changes in the architecture throughout development. Problem: The challenge lies in maintaining the correct architectural document amid ongoing architectural modifications. While Reverse Engineering supports architecture extraction, existing approaches are limited to synchronous microservice communication and lack clear identification of microservice components and messaging interfaces. Objective: This research aims to automatically extract both the component-based architecture and behavior of MoM-based microservice systems, focusing on asynchronous communication. The primary contribution is the extraction of components and behavior models tailored for asynchronous scenarios. Method: To address the challenges, we extend the existing Software Model eXtractor (SoMoX) approach, incorporating a model-based reverse engineering concept to support asynchronous communication. Our approach automates the extraction of MoM-based microservice system architecture from its source code using static analysis. Result: The paper introduces the concepts of our approach (ARE4MOM) through a running example, demonstrating its capabilities. Evaluation: involves three GitHub case studies utilizing different MoMs and technologies for asynchronous communication. ARE4MOM successfully extracts the architecture and behavior model with a 98.1% F1 score.",Automated Reverse Engineering for MoM-Based Microservices (ARE4MOM) Using Static Analysis,"Context: Understanding architecture is crucial during the development of Message-oriented Middleware-based (MoM-based) microservices. Such architecture serves as a prerequisite for system maintenance, comprehension, and refactoring. However, maintaining an accurate architecture document becomes challenging due to continuous changes in the architecture throughout development. Problem: The challenge lies in maintaining the correct architectural document amid ongoing architectural modifications. While Reverse Engineering supports architecture extraction, existing approaches are limited to synchronous microservice communication and lack clear identification of microservice components and messaging interfaces. Objective: This research aims to automatically extract both the component-based architecture and behavior of MoM-based microservice systems, focusing on asynchronous communication. The primary contribution is the extraction of components and behavior models tailored for asynchronous scenarios. Method: To address the challenges, we extend the existing Software Model eXtractor (SoMoX) approach, incorporating a model-based reverse engineering concept to support asynchronous communication. Our approach automates the extraction of MoM-based microservice system architecture from its source code using static analysis. Result: The paper introduces the concepts of our approach (ARE4MOM) through a running example, demonstrating its capabilities. Evaluation: involves three GitHub case studies utilizing different MoMs and technologies for asynchronous communication. ARE4MOM successfully extracts the architecture and behavior model with a 98.1% F1 score.",IEEE conference,no,"['automated', 'reverse', 'engineering', 'using', 'static', 'analysis', 'context', 'understanding', 'crucial', 'development', 'serf', 'maintenance', 'comprehension', 'refactoring', 'however', 'maintaining', 'accurate', 'document', 'becomes', 'challenging', 'due', 'continuous', 'change', 'throughout', 'development', 'problem', 'challenge', 'lie', 'maintaining', 'correct', 'architectural', 'document', 'ongoing', 'architectural', 'modification', 'reverse', 'engineering', 'support', 'extraction', 'existing', 'limited', 'synchronous', 'communication', 'lack', 'clear', 'identification', 'messaging', 'interface', 'objective', 'research', 'aim', 'automatically', 'extract', 'behavior', 'focusing', 'asynchronous', 'communication', 'primary', 'contribution', 'extraction', 'behavior', 'model', 'tailored', 'asynchronous', 'scenario', 'method', 'address', 'challenge', 'extend', 'existing', 'model', 'incorporating', 'reverse', 'engineering', 'concept', 'support', 'asynchronous', 'communication', 'automates', 'extraction', 'source', 'code', 'using', 'static', 'analysis', 'result', 'paper', 'introduces', 'concept', 'running', 'example', 'demonstrating', 'capability', 'evaluation', 'involves', 'three', 'github', 'case', 'study', 'utilizing', 'different', 'technology', 'asynchronous', 'communication', 'successfully', 'extract', 'behavior', 'model', 'score']"
"Borehole Trajectory System Based on Microservices Architecture This research aims to integrate microservices architecture into the borehole trajectory design system, addressing the challenges faced by traditional monolithic systems in processing big data and rapid updates. By dividing and deploying the frontend, backend, database, database operation modules, and the drilling trajectory module as microservices, this paper achieves coordinated operation among system components through a loosely coupled architecture, thereby efficiently completing system functions. This method not only improves adaptability to new technologies but also provides an effective strategy for overcoming existing problems.",Borehole Trajectory System Based on Microservices Architecture,"This research aims to integrate microservices architecture into the borehole trajectory design system, addressing the challenges faced by traditional monolithic systems in processing big data and rapid updates. By dividing and deploying the frontend, backend, database, database operation modules, and the drilling trajectory module as microservices, this paper achieves coordinated operation among system components through a loosely coupled architecture, thereby efficiently completing system functions. This method not only improves adaptability to new technologies but also provides an effective strategy for overcoming existing problems.",IEEE conference,no,"['trajectory', 'based', 'research', 'aim', 'integrate', 'trajectory', 'design', 'addressing', 'challenge', 'faced', 'traditional', 'monolithic', 'processing', 'big', 'rapid', 'update', 'dividing', 'deploying', 'frontend', 'backend', 'database', 'database', 'operation', 'module', 'trajectory', 'module', 'paper', 'achieves', 'coordinated', 'operation', 'among', 'loosely', 'coupled', 'thereby', 'efficiently', 'function', 'method', 'improves', 'adaptability', 'new', 'technology', 'also', 'provides', 'effective', 'strategy', 'overcoming', 'existing', 'problem']"
"Towards Decomposing Monolithic Applications into Microservices Continuously changing the existing software systems results in large and monolith software solutions making them difficult to maintain. As maintenance and development of monolithic software systems is a difficult task, there is a need for decomposing these monolithic systems into smaller subsystems, components and services, i.e., microservices. Service-oriented architectures yield more maintenance and less complexity in developing large-scale software applications. Thus, this paper focuses on decomposing monolithic software systems into microservices in order to maintain them with less development effort. Moreover, it addresses to the problem of architectural refactoring and improvement of software systems during architectural migration.",Towards Decomposing Monolithic Applications into Microservices,"Continuously changing the existing software systems results in large and monolith software solutions making them difficult to maintain. As maintenance and development of monolithic software systems is a difficult task, there is a need for decomposing these monolithic systems into smaller subsystems, components and services, i.e., microservices. Service-oriented architectures yield more maintenance and less complexity in developing large-scale software applications. Thus, this paper focuses on decomposing monolithic software systems into microservices in order to maintain them with less development effort. Moreover, it addresses to the problem of architectural refactoring and improvement of software systems during architectural migration.",IEEE conference,no,"['towards', 'decomposing', 'monolithic', 'continuously', 'changing', 'existing', 'result', 'large', 'monolith', 'solution', 'making', 'difficult', 'maintain', 'maintenance', 'development', 'monolithic', 'difficult', 'task', 'need', 'decomposing', 'monolithic', 'smaller', 'yield', 'maintenance', 'less', 'complexity', 'developing', 'thus', 'paper', 'focus', 'decomposing', 'monolithic', 'order', 'maintain', 'less', 'development', 'effort', 'moreover', 'address', 'problem', 'architectural', 'refactoring', 'improvement', 'architectural', 'migration']"
"Making the move to microservice architecture Microservice architecture is an architectural style suitable for large software projects. The main goals of microservices are flexible on-demand scalability and short release cycles. Microservice architecture decomposes applications into multiple independent components (called microservices), each running in its own process. This sets microservice applications apart from monoliths, which run in a single process. This paper describes the characteristics of both architectures and explores under which circumstances a shift from a monolith towards the more costly microservice architecture is justified. Furthermore, the paper describes (non-)technical challenges that arise in that shift.",Making the move to microservice architecture,"Microservice architecture is an architectural style suitable for large software projects. The main goals of microservices are flexible on-demand scalability and short release cycles. Microservice architecture decomposes applications into multiple independent components (called microservices), each running in its own process. This sets microservice applications apart from monoliths, which run in a single process. This paper describes the characteristics of both architectures and explores under which circumstances a shift from a monolith towards the more costly microservice architecture is justified. Furthermore, the paper describes (non-)technical challenges that arise in that shift.",IEEE conference,no,"['making', 'move', 'architectural', 'style', 'suitable', 'large', 'project', 'main', 'goal', 'flexible', 'scalability', 'short', 'release', 'cycle', 'decomposes', 'multiple', 'independent', 'called', 'running', 'process', 'set', 'monolith', 'run', 'single', 'process', 'paper', 'describes', 'characteristic', 'explores', 'circumstance', 'shift', 'monolith', 'towards', 'costly', 'furthermore', 'paper', 'describes', 'technical', 'challenge', 'arise', 'shift']"
"Fostering Microservice Maintainability Assurance Through a Comprehensive Framework Cloud-native systems represent a significant leap in constructing scalable, large systems, employing microservice architecture as a key element in developing distributed systems through self-contained components. However, the decentralized nature of these systems, characterized by separate source codes and deployments, introduces challenges in assessing system qual-ities. Microservice-based systems, with their inherent complexity and the need for coordinated changes across multiple microser-vices, lack established best practices and guidelines, leading to difficulties in constructing and comprehending the holistic system view. This gap can result in performance degradation and increased maintenance costs, potentially requiring system refactoring. The main goal of this project is to offer maintainability assur-ance for microservice practitioners. It introduces an automated assessment framework tailored to microservice architecture, en-hancing practitioners' understanding and analytical capabilities of the multiple system perspectives. The framework addresses various granularity levels, from artifacts to constructing holistic views of static and dynamic system characteristics. It integrates diverse perspectives, encompassing human-centric elements like architectural visualization and automated evaluations, including coupling detection, testing coverage measurement, and semantic clone identification. Validation studies involving practitioners demonstrate the framework's effectiveness in addressing diverse quality and maintainability issues, revealing insights not apparent when analyzing individual microservices in isolation.",Fostering Microservice Maintainability Assurance Through a Comprehensive Framework,"Cloud-native systems represent a significant leap in constructing scalable, large systems, employing microservice architecture as a key element in developing distributed systems through self-contained components. However, the decentralized nature of these systems, characterized by separate source codes and deployments, introduces challenges in assessing system qual-ities. Microservice-based systems, with their inherent complexity and the need for coordinated changes across multiple microser-vices, lack established best practices and guidelines, leading to difficulties in constructing and comprehending the holistic system view. This gap can result in performance degradation and increased maintenance costs, potentially requiring system refactoring. The main goal of this project is to offer maintainability assur-ance for microservice practitioners. It introduces an automated assessment framework tailored to microservice architecture, en-hancing practitioners' understanding and analytical capabilities of the multiple system perspectives. The framework addresses various granularity levels, from artifacts to constructing holistic views of static and dynamic system characteristics. It integrates diverse perspectives, encompassing human-centric elements like architectural visualization and automated evaluations, including coupling detection, testing coverage measurement, and semantic clone identification. Validation studies involving practitioners demonstrate the framework's effectiveness in addressing diverse quality and maintainability issues, revealing insights not apparent when analyzing individual microservices in isolation.",IEEE conference,no,"['fostering', 'maintainability', 'assurance', 'comprehensive', 'framework', 'represent', 'significant', 'constructing', 'scalable', 'large', 'employing', 'key', 'element', 'developing', 'distributed', 'however', 'decentralized', 'nature', 'characterized', 'separate', 'source', 'code', 'deployment', 'introduces', 'challenge', 'assessing', 'inherent', 'complexity', 'need', 'coordinated', 'change', 'across', 'multiple', 'lack', 'established', 'best', 'practice', 'guideline', 'leading', 'difficulty', 'constructing', 'holistic', 'view', 'gap', 'result', 'performance', 'degradation', 'increased', 'maintenance', 'cost', 'potentially', 'requiring', 'refactoring', 'main', 'goal', 'project', 'offer', 'maintainability', 'practitioner', 'introduces', 'automated', 'assessment', 'framework', 'tailored', 'practitioner', 'understanding', 'analytical', 'capability', 'multiple', 'perspective', 'framework', 'address', 'various', 'granularity', 'level', 'artifact', 'constructing', 'holistic', 'view', 'static', 'dynamic', 'characteristic', 'integrates', 'diverse', 'perspective', 'encompassing', 'element', 'like', 'architectural', 'visualization', 'automated', 'evaluation', 'including', 'coupling', 'detection', 'testing', 'coverage', 'measurement', 'semantic', 'identification', 'validation', 'study', 'involving', 'practitioner', 'demonstrate', 'framework', 'effectiveness', 'addressing', 'diverse', 'quality', 'maintainability', 'issue', 'insight', 'apparent', 'analyzing', 'individual', 'isolation']"
"MAT: Automating Go monolithic applications transform into microservices through dependency analysis and AST The advancement of containerization and various integration tools has greatly reduced the development cost of microservice architecture. Under this premise, many companies have begun to migrate their legacy systems (monolithic applications) to microservice architectures in order to adapt to market demands. Instead of migrating legacy systems to microservice architecture from scratch, we provide another approach of splitting an existing monolithic system into microservices. In this paper, we use Go language’s AST as a basis to split the original project into multiple independent components and design a method for analyzing dependencies, classifying them, and producing independently runnable microservices.",MAT: Automating Go monolithic applications transform into microservices through dependency analysis and AST,"The advancement of containerization and various integration tools has greatly reduced the development cost of microservice architecture. Under this premise, many companies have begun to migrate their legacy systems (monolithic applications) to microservice architectures in order to adapt to market demands. Instead of migrating legacy systems to microservice architecture from scratch, we provide another approach of splitting an existing monolithic system into microservices. In this paper, we use Go language’s AST as a basis to split the original project into multiple independent components and design a method for analyzing dependencies, classifying them, and producing independently runnable microservices.",IEEE conference,no,"['automating', 'go', 'monolithic', 'transform', 'dependency', 'analysis', 'advancement', 'containerization', 'various', 'integration', 'tool', 'greatly', 'reduced', 'development', 'cost', 'premise', 'many', 'company', 'migrate', 'legacy', 'monolithic', 'order', 'adapt', 'market', 'demand', 'instead', 'migrating', 'legacy', 'scratch', 'provide', 'another', 'splitting', 'existing', 'monolithic', 'paper', 'use', 'go', 'language', 'basis', 'split', 'original', 'project', 'multiple', 'independent', 'design', 'method', 'analyzing', 'dependency', 'producing', 'independently']"
"Strategies for Request-Response Logging in Microservices Architecture Microservices Architecture is the prevailing architectural choice today for building distributed software systems in various business sectors, such as telecommunications, e-commerce, and finance. It is often necessary to log the full content of request and response messages (i.e., the entire body of these messages) that are entering and leaving such distributed systems due to legal book-keeping requirements. In this work, two systematic design strategies were used to realize the structured logging of request-response messages including their entire message body, particularly in a microservices architecture-based distributed software system. As a case study, a prototype per strategy was implemented and deployed into an existing Microservices Architecture-based banking system, which was provided by a commercial bank for the research presented in this paper in the Kubernetes cluster. Load tests were performed against this banking system to measure average request throughputs and average response times per logging strategy for analysis purposes. The results that are presented in this paper are expected to be helpful for both researchers and practitioners in the software industry who need a similar logging solution.",Strategies for Request-Response Logging in Microservices Architecture,"Microservices Architecture is the prevailing architectural choice today for building distributed software systems in various business sectors, such as telecommunications, e-commerce, and finance. It is often necessary to log the full content of request and response messages (i.e., the entire body of these messages) that are entering and leaving such distributed systems due to legal book-keeping requirements. In this work, two systematic design strategies were used to realize the structured logging of request-response messages including their entire message body, particularly in a microservices architecture-based distributed software system. As a case study, a prototype per strategy was implemented and deployed into an existing Microservices Architecture-based banking system, which was provided by a commercial bank for the research presented in this paper in the Kubernetes cluster. Load tests were performed against this banking system to measure average request throughputs and average response times per logging strategy for analysis purposes. The results that are presented in this paper are expected to be helpful for both researchers and practitioners in the software industry who need a similar logging solution.",IEEE conference,no,"['strategy', 'logging', 'prevailing', 'architectural', 'choice', 'today', 'building', 'distributed', 'various', 'business', 'sector', 'telecommunication', 'finance', 'often', 'necessary', 'log', 'full', 'content', 'request', 'response', 'message', 'entire', 'body', 'message', 'leaving', 'distributed', 'due', 'requirement', 'work', 'two', 'systematic', 'design', 'strategy', 'used', 'realize', 'structured', 'logging', 'message', 'including', 'entire', 'message', 'body', 'particularly', 'distributed', 'case', 'study', 'prototype', 'per', 'strategy', 'implemented', 'deployed', 'existing', 'banking', 'provided', 'commercial', 'bank', 'research', 'presented', 'paper', 'kubernetes', 'cluster', 'load', 'test', 'performed', 'banking', 'measure', 'average', 'request', 'throughput', 'average', 'response', 'time', 'per', 'logging', 'strategy', 'analysis', 'purpose', 'result', 'presented', 'paper', 'expected', 'helpful', 'researcher', 'practitioner', 'industry', 'need', 'similar', 'logging', 'solution']"
"A Microservices Quality Model Based on Microservices Anti-patterns Microservices architecture is becoming popular as many software organizations have the need to transform large complex systems into small-sized software units whose functions are separated by business capabilities. Microservices architecture is preferable since it promotes independence of software modification, maintenance, and deployment. However, anti-patterns or poor development patterns of microservices can decrease the software quality. Nonetheless, quality measurement of microservices design based on anti-patterns has not been found in existing research. Using the QMOOD method for quality model design, this paper proposes a microservices quality model based on 11 microservices anti-patterns and ISO/IEe 25010 as a standard reference for quality attributes. Also, a microservices quality measurement tool called MSA Nose+ is developed to measure the quality of microservices applications. In an experiment to validate the proposed model, the result shows that the quality values obtained from the proposed model improve consistently with the refactorings that are applied to a microservice-based system. Thus, development teams can use the proposed model and quality measurements as part of the decision making on quality improvement and maintenance of microservices applications.",A Microservices Quality Model Based on Microservices Anti-patterns,"Microservices architecture is becoming popular as many software organizations have the need to transform large complex systems into small-sized software units whose functions are separated by business capabilities. Microservices architecture is preferable since it promotes independence of software modification, maintenance, and deployment. However, anti-patterns or poor development patterns of microservices can decrease the software quality. Nonetheless, quality measurement of microservices design based on anti-patterns has not been found in existing research. Using the QMOOD method for quality model design, this paper proposes a microservices quality model based on 11 microservices anti-patterns and ISO/IEe 25010 as a standard reference for quality attributes. Also, a microservices quality measurement tool called MSA Nose+ is developed to measure the quality of microservices applications. In an experiment to validate the proposed model, the result shows that the quality values obtained from the proposed model improve consistently with the refactorings that are applied to a microservice-based system. Thus, development teams can use the proposed model and quality measurements as part of the decision making on quality improvement and maintenance of microservices applications.",IEEE conference,no,"['quality', 'model', 'based', 'becoming', 'popular', 'many', 'organization', 'need', 'transform', 'large', 'complex', 'unit', 'whose', 'function', 'business', 'capability', 'since', 'promotes', 'independence', 'modification', 'maintenance', 'deployment', 'however', 'poor', 'development', 'pattern', 'decrease', 'quality', 'nonetheless', 'quality', 'measurement', 'design', 'based', 'found', 'existing', 'research', 'using', 'method', 'quality', 'model', 'design', 'paper', 'proposes', 'quality', 'model', 'based', 'standard', 'reference', 'quality', 'attribute', 'also', 'quality', 'measurement', 'tool', 'called', 'msa', 'developed', 'measure', 'quality', 'experiment', 'validate', 'proposed', 'model', 'result', 'show', 'quality', 'value', 'obtained', 'proposed', 'model', 'improve', 'consistently', 'applied', 'thus', 'development', 'team', 'use', 'proposed', 'model', 'quality', 'measurement', 'part', 'decision', 'making', 'quality', 'improvement', 'maintenance']"
"Analyzing Microservices and Monolithic Systems: Key Factors in Architecture, Development, and Operations Microservices and monolithic systems are two prevalent architectural approaches in software development. This study provides a complete review and analysis of the key components involved in design, development, and operation in software development. A systematic review of the literature was conducted according to the Preferred Reporting Items for Systematic Reviews and Meta-Analyses (PRISMA) guidelines. This review examined various sources debating monolithic systems vs microservices, highlighting their benefits, drawbacks, and implementation in enterprises. The paper addresses important research questions, aiming to further analyze this architectural approach. Findings show that microservices offer benefits such as scalability, flexibility, and independent deployment, while monolithic systems provide simplicity and ease of development. However, challenges related to network communication, data consistency, and operational complexity were also found with microservices. This research focuses on discussing the trade-offs and factors to consider when deciding between monolithic systems and microservices, which provides in-depth information for practitioners in decision-making for software development. This research aims to help readers understand the effects of using monolithic or microservice-based systems in software development.","Analyzing Microservices and Monolithic Systems: Key Factors in Architecture, Development, and Operations","Microservices and monolithic systems are two prevalent architectural approaches in software development. This study provides a complete review and analysis of the key components involved in design, development, and operation in software development. A systematic review of the literature was conducted according to the Preferred Reporting Items for Systematic Reviews and Meta-Analyses (PRISMA) guidelines. This review examined various sources debating monolithic systems vs microservices, highlighting their benefits, drawbacks, and implementation in enterprises. The paper addresses important research questions, aiming to further analyze this architectural approach. Findings show that microservices offer benefits such as scalability, flexibility, and independent deployment, while monolithic systems provide simplicity and ease of development. However, challenges related to network communication, data consistency, and operational complexity were also found with microservices. This research focuses on discussing the trade-offs and factors to consider when deciding between monolithic systems and microservices, which provides in-depth information for practitioners in decision-making for software development. This research aims to help readers understand the effects of using monolithic or microservice-based systems in software development.",IEEE conference,no,"['analyzing', 'monolithic', 'key', 'factor', 'development', 'operation', 'monolithic', 'two', 'prevalent', 'architectural', 'development', 'study', 'provides', 'complete', 'review', 'analysis', 'key', 'involved', 'design', 'development', 'operation', 'development', 'systematic', 'review', 'literature', 'conducted', 'according', 'preferred', 'item', 'systematic', 'review', 'guideline', 'review', 'examined', 'various', 'source', 'monolithic', 'v', 'highlighting', 'benefit', 'drawback', 'implementation', 'enterprise', 'paper', 'address', 'important', 'research', 'question', 'aiming', 'analyze', 'architectural', 'finding', 'show', 'offer', 'benefit', 'scalability', 'flexibility', 'independent', 'deployment', 'monolithic', 'provide', 'simplicity', 'ease', 'development', 'however', 'challenge', 'related', 'network', 'communication', 'consistency', 'operational', 'complexity', 'also', 'found', 'research', 'focus', 'factor', 'consider', 'monolithic', 'provides', 'information', 'practitioner', 'development', 'research', 'aim', 'help', 'understand', 'effect', 'using', 'monolithic', 'development']"
"Research on Digital Agile Information System Based on Microservice Architecture With the vigorous development of various business systems of the State Grid Corporation of China, the business requirements are continuously updated and changed, and the traditional waterfall model development can no longer meet the current business needs. And in the paper, the architecture method of microservice integration Data Middle Office is proposed. Based on the microservice architecture system, the application and function are realized by integrating the component technology of the Data Middle Office, then the project practice is carried out through agile development, and the technical architecture layer and the agile development process are elaborated. In addition, the technical layers and workflows involved. By adopting the micro-service architecture and integrating the agile development model, focusing on the demand and rapidly iterating, the platform is continuously optimized and iterative upgraded, which provides a reference for the enterprise-level development solution of State Grid Corporation under the construction of the new information system.",Research on Digital Agile Information System Based on Microservice Architecture,"With the vigorous development of various business systems of the State Grid Corporation of China, the business requirements are continuously updated and changed, and the traditional waterfall model development can no longer meet the current business needs. And in the paper, the architecture method of microservice integration Data Middle Office is proposed. Based on the microservice architecture system, the application and function are realized by integrating the component technology of the Data Middle Office, then the project practice is carried out through agile development, and the technical architecture layer and the agile development process are elaborated. In addition, the technical layers and workflows involved. By adopting the micro-service architecture and integrating the agile development model, focusing on the demand and rapidly iterating, the platform is continuously optimized and iterative upgraded, which provides a reference for the enterprise-level development solution of State Grid Corporation under the construction of the new information system.",IEEE conference,no,"['research', 'digital', 'agile', 'information', 'based', 'development', 'various', 'business', 'state', 'grid', 'corporation', 'business', 'requirement', 'continuously', 'updated', 'changed', 'traditional', 'model', 'development', 'longer', 'meet', 'current', 'business', 'need', 'paper', 'method', 'integration', 'middle', 'office', 'proposed', 'based', 'function', 'realized', 'integrating', 'technology', 'middle', 'office', 'project', 'practice', 'carried', 'agile', 'development', 'technical', 'layer', 'agile', 'development', 'process', 'elaborated', 'addition', 'technical', 'layer', 'workflow', 'involved', 'adopting', 'integrating', 'agile', 'development', 'model', 'focusing', 'demand', 'rapidly', 'platform', 'continuously', 'optimized', 'iterative', 'upgraded', 'provides', 'reference', 'development', 'solution', 'state', 'grid', 'corporation', 'construction', 'new', 'information']"
"Understanding the Causes of Microservice Logical Coupling: an Exploratory Study When implementing a software system, two crucial metrics come into play: the degree of interdependence between modules, known as coupling, and the extent to which the components within a module collaborate to fulfill its task, referred to as cohesion. This paper studies the phenomenon of apparent coupling and explores the possibilities to exclude it from measurement when studying coupling between microservices.",Understanding the Causes of Microservice Logical Coupling: an Exploratory Study,"When implementing a software system, two crucial metrics come into play: the degree of interdependence between modules, known as coupling, and the extent to which the components within a module collaborate to fulfill its task, referred to as cohesion. This paper studies the phenomenon of apparent coupling and explores the possibilities to exclude it from measurement when studying coupling between microservices.",IEEE conference,no,"['understanding', 'cause', 'logical', 'coupling', 'exploratory', 'study', 'implementing', 'two', 'crucial', 'metric', 'come', 'play', 'degree', 'module', 'known', 'coupling', 'extent', 'within', 'module', 'collaborate', 'fulfill', 'task', 'referred', 'cohesion', 'paper', 'study', 'phenomenon', 'apparent', 'coupling', 'explores', 'possibility', 'measurement', 'coupling']"
"A Microservices Identification Approach based on Problem Frames As software grows in size continuously, traditional monolithic architecture is difficult to upgrade and update. As a more flexible architecture, microservices consist of smaller pieces or services that are loosely coupled and can be deployed independently. More and more IT companies are adopting microservices architecture. However, migrating to microservices is still a big challenge due to the lack of a more systematic methodology on microservices identification. Most existing studies on microservices identification are mainly based on refactoring the system module rather than considering the actual functional requirements. Therefore, we propose a microservices identification approach based on the problem frames to address this challenge, which considers real-world requirements. It relies on the merging process with the problem diagram, where the problem domain is processed, and the causal chain is obtained by searching the problem diagram. Subsequently, we calculate the correlation degree of the domains in the problem diagram. Then, based on the calculated correlation, we implement a clustering algorithm for the problem domains and get the categorization result of the problem domains which is the initial microservice candidate. The developers can consider each category of the problem domain as a microservice by converting the problem domains into the microservices. Finally, a case study verifies the validity of our proposed approach.",A Microservices Identification Approach based on Problem Frames,"As software grows in size continuously, traditional monolithic architecture is difficult to upgrade and update. As a more flexible architecture, microservices consist of smaller pieces or services that are loosely coupled and can be deployed independently. More and more IT companies are adopting microservices architecture. However, migrating to microservices is still a big challenge due to the lack of a more systematic methodology on microservices identification. Most existing studies on microservices identification are mainly based on refactoring the system module rather than considering the actual functional requirements. Therefore, we propose a microservices identification approach based on the problem frames to address this challenge, which considers real-world requirements. It relies on the merging process with the problem diagram, where the problem domain is processed, and the causal chain is obtained by searching the problem diagram. Subsequently, we calculate the correlation degree of the domains in the problem diagram. Then, based on the calculated correlation, we implement a clustering algorithm for the problem domains and get the categorization result of the problem domains which is the initial microservice candidate. The developers can consider each category of the problem domain as a microservice by converting the problem domains into the microservices. Finally, a case study verifies the validity of our proposed approach.",IEEE conference,no,"['identification', 'based', 'problem', 'frame', 'grows', 'size', 'continuously', 'traditional', 'monolithic', 'difficult', 'upgrade', 'update', 'flexible', 'consist', 'smaller', 'piece', 'loosely', 'coupled', 'deployed', 'independently', 'company', 'adopting', 'however', 'migrating', 'still', 'big', 'challenge', 'due', 'lack', 'systematic', 'methodology', 'identification', 'existing', 'study', 'identification', 'mainly', 'based', 'refactoring', 'module', 'rather', 'considering', 'actual', 'functional', 'requirement', 'therefore', 'propose', 'identification', 'based', 'problem', 'frame', 'address', 'challenge', 'considers', 'requirement', 'relies', 'process', 'problem', 'diagram', 'problem', 'domain', 'processed', 'causal', 'chain', 'obtained', 'problem', 'diagram', 'subsequently', 'calculate', 'correlation', 'degree', 'domain', 'problem', 'diagram', 'based', 'calculated', 'correlation', 'implement', 'clustering', 'algorithm', 'problem', 'domain', 'get', 'result', 'problem', 'domain', 'initial', 'candidate', 'developer', 'consider', 'category', 'problem', 'domain', 'converting', 'problem', 'domain', 'finally', 'case', 'study', 'validity', 'proposed']"
"Using Microservices for Rapid Creation of Remote Sensing Products Driven by the demands of various sensing data products, remote sensing software systems have increasingly been developed and applied to a wide range of fields. Due to the legacy monolithic product line, we used to satisfy the requirements on a project-by-project basis, only with reuse of some fundamental source codes and tools. By employing microservices to refactor our product line, we are now able to follow a divide-and-conquer strategy to maximize the reusability of component business capacities and create satellite remote sensing products at a much faster pace. This paper mainly introduces our microservice-oriented product line, and the data-analytics-visualization (DAV) pattern for logically organizing and managing relevant microservices of different products. In particular, two projects (namely archaeological detection and cultural heritage protection & urban planning and land use) are used to demonstrate how we prevent to develop thematic products from scratch.",Using Microservices for Rapid Creation of Remote Sensing Products,"Driven by the demands of various sensing data products, remote sensing software systems have increasingly been developed and applied to a wide range of fields. Due to the legacy monolithic product line, we used to satisfy the requirements on a project-by-project basis, only with reuse of some fundamental source codes and tools. By employing microservices to refactor our product line, we are now able to follow a divide-and-conquer strategy to maximize the reusability of component business capacities and create satellite remote sensing products at a much faster pace. This paper mainly introduces our microservice-oriented product line, and the data-analytics-visualization (DAV) pattern for logically organizing and managing relevant microservices of different products. In particular, two projects (namely archaeological detection and cultural heritage protection & urban planning and land use) are used to demonstrate how we prevent to develop thematic products from scratch.",IEEE conference,no,"['using', 'rapid', 'creation', 'remote', 'sensing', 'product', 'driven', 'demand', 'various', 'sensing', 'product', 'remote', 'sensing', 'increasingly', 'developed', 'applied', 'wide', 'range', 'field', 'due', 'legacy', 'monolithic', 'product', 'line', 'used', 'satisfy', 'requirement', 'basis', 'reuse', 'fundamental', 'source', 'code', 'tool', 'employing', 'product', 'line', 'able', 'follow', 'strategy', 'maximize', 'reusability', 'business', 'capacity', 'create', 'remote', 'sensing', 'product', 'much', 'faster', 'pace', 'paper', 'mainly', 'introduces', 'product', 'line', 'pattern', 'logically', 'managing', 'relevant', 'different', 'product', 'particular', 'two', 'project', 'namely', 'detection', 'protection', 'urban', 'planning', 'land', 'use', 'used', 'demonstrate', 'prevent', 'develop', 'product', 'scratch']"
"Migrating Monolithic Mobile Application to Microservice Architecture: An Experiment Report The microservice architecture (MSA) is an emerging cloud software system, which provides fine-grained, self-contained service components (microservices) used in the construction of complex software systems. DevOps techniques are commonly used to automate the process of development and operation through continuous integration and continuous deployment. Monitoring software systems created by DevOps, makes it possible for MSA to obtain the feedback necessary to improve the system quickly and easily. Nonetheless, systematic, SDLC-driven methods (SDLC: software development life cycle) are lacking to facilitate the migration of software systems from a traditional monolithic architecture to MSA. Therefore, this paper proposes a migration process based on SDLC, including all of the methods and tools required during design, development, and implementation. The mobile application, EasyLearn, was used as an illustrative example to demonstrate the efficacy of the proposed migration process. We believe that this paper could provide valuable references for other development teams seeking to facilitate the migration of existing applications to MSA.",Migrating Monolithic Mobile Application to Microservice Architecture: An Experiment Report,"The microservice architecture (MSA) is an emerging cloud software system, which provides fine-grained, self-contained service components (microservices) used in the construction of complex software systems. DevOps techniques are commonly used to automate the process of development and operation through continuous integration and continuous deployment. Monitoring software systems created by DevOps, makes it possible for MSA to obtain the feedback necessary to improve the system quickly and easily. Nonetheless, systematic, SDLC-driven methods (SDLC: software development life cycle) are lacking to facilitate the migration of software systems from a traditional monolithic architecture to MSA. Therefore, this paper proposes a migration process based on SDLC, including all of the methods and tools required during design, development, and implementation. The mobile application, EasyLearn, was used as an illustrative example to demonstrate the efficacy of the proposed migration process. We believe that this paper could provide valuable references for other development teams seeking to facilitate the migration of existing applications to MSA.",IEEE conference,no,"['migrating', 'monolithic', 'mobile', 'experiment', 'report', 'msa', 'emerging', 'provides', 'used', 'construction', 'complex', 'devops', 'technique', 'commonly', 'used', 'automate', 'process', 'development', 'operation', 'continuous', 'integration', 'continuous', 'deployment', 'monitoring', 'created', 'devops', 'make', 'possible', 'msa', 'obtain', 'feedback', 'necessary', 'improve', 'quickly', 'easily', 'nonetheless', 'systematic', 'method', 'sdlc', 'development', 'life', 'cycle', 'facilitate', 'migration', 'traditional', 'monolithic', 'msa', 'therefore', 'paper', 'proposes', 'migration', 'process', 'based', 'sdlc', 'including', 'method', 'tool', 'required', 'design', 'development', 'implementation', 'mobile', 'used', 'illustrative', 'example', 'demonstrate', 'efficacy', 'proposed', 'migration', 'process', 'believe', 'paper', 'could', 'provide', 'valuable', 'reference', 'development', 'team', 'seeking', 'facilitate', 'migration', 'existing', 'msa']"
"Pattern-based Modelling, Integration, and Deployment of Microservice Architectures Microservice-based architectures (MSAs) gained momentum in industrial and research communities since finer-grained and more independent components foster reuse and reduce time to market. However, to come from the design of MSAs to running applications, substantial knowledge and technology-specific expertise in the deployment and integration of microservices is needed. In this paper, we propose a model-driven and pattern-based approach for composing microservices, which facilitates the transition from architectural models to running deployments. Using a unified modelling for MSAs, including both their integration based on Enterprise Integration Patterns (EIPs) and deployment aspects, our approach enables automatically generating the artefacts for deploying microservice compositions. This helps abstracting away the underlying infrastructure including container orchestration platforms and middleware layer for service integration. To validate the feasibility of our approach, we illustrate its prototypical implementation, with Kubernetes used as container orchestration system and OpenFaaS used for managing integration logic, and we present a case study.","Pattern-based Modelling, Integration, and Deployment of Microservice Architectures","Microservice-based architectures (MSAs) gained momentum in industrial and research communities since finer-grained and more independent components foster reuse and reduce time to market. However, to come from the design of MSAs to running applications, substantial knowledge and technology-specific expertise in the deployment and integration of microservices is needed. In this paper, we propose a model-driven and pattern-based approach for composing microservices, which facilitates the transition from architectural models to running deployments. Using a unified modelling for MSAs, including both their integration based on Enterprise Integration Patterns (EIPs) and deployment aspects, our approach enables automatically generating the artefacts for deploying microservice compositions. This helps abstracting away the underlying infrastructure including container orchestration platforms and middleware layer for service integration. To validate the feasibility of our approach, we illustrate its prototypical implementation, with Kubernetes used as container orchestration system and OpenFaaS used for managing integration logic, and we present a case study.",IEEE conference,no,"['modelling', 'integration', 'deployment', 'msas', 'gained', 'momentum', 'industrial', 'research', 'community', 'since', 'independent', 'foster', 'reuse', 'reduce', 'time', 'market', 'however', 'come', 'design', 'msas', 'running', 'substantial', 'knowledge', 'expertise', 'deployment', 'integration', 'needed', 'paper', 'propose', 'composing', 'facilitates', 'transition', 'architectural', 'model', 'running', 'deployment', 'using', 'unified', 'modelling', 'msas', 'including', 'integration', 'based', 'enterprise', 'integration', 'pattern', 'deployment', 'aspect', 'enables', 'automatically', 'generating', 'deploying', 'composition', 'help', 'abstracting', 'away', 'underlying', 'infrastructure', 'including', 'container', 'orchestration', 'platform', 'middleware', 'layer', 'integration', 'validate', 'feasibility', 'illustrate', 'implementation', 'kubernetes', 'used', 'container', 'orchestration', 'used', 'managing', 'integration', 'logic', 'present', 'case', 'study']"
"An Approach to Extract the Architecture of Microservice-Based Software Systems Microservices decouple network-accessible system components to support independent development, deployment, and scalability. The architecture of microservice-based software systems is typically not defined upfront but emerges by dynamically assembling services to systems. This makes it hard to extract component relations from static sources since component relationships may only become evident at runtime. Existing systems focus either on the static structure of service relations, neglecting runtime properties, or on (short-term) monitoring of runtime properties to detect errors. We present an approach to extract and analyze the architecture of a microservice-based software system based on a combination of static service information with infrastructure-related and aggregated runtime information.",An Approach to Extract the Architecture of Microservice-Based Software Systems,"Microservices decouple network-accessible system components to support independent development, deployment, and scalability. The architecture of microservice-based software systems is typically not defined upfront but emerges by dynamically assembling services to systems. This makes it hard to extract component relations from static sources since component relationships may only become evident at runtime. Existing systems focus either on the static structure of service relations, neglecting runtime properties, or on (short-term) monitoring of runtime properties to detect errors. We present an approach to extract and analyze the architecture of a microservice-based software system based on a combination of static service information with infrastructure-related and aggregated runtime information.",IEEE conference,no,"['extract', 'decouple', 'support', 'independent', 'development', 'deployment', 'scalability', 'typically', 'defined', 'emerges', 'dynamically', 'make', 'hard', 'extract', 'relation', 'static', 'source', 'since', 'relationship', 'may', 'become', 'runtime', 'existing', 'focus', 'either', 'static', 'structure', 'relation', 'neglecting', 'runtime', 'property', 'monitoring', 'runtime', 'property', 'detect', 'error', 'present', 'extract', 'analyze', 'based', 'combination', 'static', 'information', 'aggregated', 'runtime', 'information']"
"A Survey on Microservices Criticality Attributes on Established Architectures The microservice oriented software architecture considers the delegation of responsibilities by separate components, thus creating a set of interconnected but independent services. Information about the most critical microservices is relevant to software architects and other decision-makers, thus guiding the maintenance and evolution of architecture in a more assertive and guided way. This paper aims to observe the need for a method to measure criticality in a microservice oriented architecture, motivated by this purpose, during August 2019, a survey with twenty experienced participants from the industry and academia was conducted, where the lack of a grounded method to measure the criticality on established architectures was observed.",A Survey on Microservices Criticality Attributes on Established Architectures,"The microservice oriented software architecture considers the delegation of responsibilities by separate components, thus creating a set of interconnected but independent services. Information about the most critical microservices is relevant to software architects and other decision-makers, thus guiding the maintenance and evolution of architecture in a more assertive and guided way. This paper aims to observe the need for a method to measure criticality in a microservice oriented architecture, motivated by this purpose, during August 2019, a survey with twenty experienced participants from the industry and academia was conducted, where the lack of a grounded method to measure the criticality on established architectures was observed.",IEEE conference,no,"['survey', 'criticality', 'attribute', 'established', 'oriented', 'considers', 'responsibility', 'separate', 'thus', 'creating', 'set', 'interconnected', 'independent', 'information', 'critical', 'relevant', 'architect', 'thus', 'maintenance', 'evolution', 'guided', 'way', 'paper', 'aim', 'observe', 'need', 'method', 'measure', 'criticality', 'oriented', 'motivated', 'purpose', 'survey', 'experienced', 'participant', 'industry', 'academia', 'conducted', 'lack', 'method', 'measure', 'criticality', 'established', 'observed']"
"Are knowledge and usage of microservices patterns aligned? An exploratory study with professionals Microservices Architecture is a trending solution for large systems, which counts with an extensive pattern language that defines its base practices and documents solutions to recurrent problems. However, there is a lack of studies investigating how these patterns are known and applied by professionals. Understanding how the patterns are used enables to comprehend the design process for this architectural style and identify opportunities for improvement. So, this work aims to collect and analyze information about how professionals know and use microservice patterns. To achieve that, we conducted a questionnaire study focused on eleven patterns that directly influence the architecture and components structure. The questionnaire was answered by 63 participants and revealed that, in general, they know the patterns, but with a significant amount declaring that it was known only as a practice. Additionally, among other results, our study also identified that the patterns are more commonly adopted at the project beginning rather than by refactoring and that they frequently are adopted more than once in the same system.",Are knowledge and usage of microservices patterns aligned? An exploratory study with professionals,"Microservices Architecture is a trending solution for large systems, which counts with an extensive pattern language that defines its base practices and documents solutions to recurrent problems. However, there is a lack of studies investigating how these patterns are known and applied by professionals. Understanding how the patterns are used enables to comprehend the design process for this architectural style and identify opportunities for improvement. So, this work aims to collect and analyze information about how professionals know and use microservice patterns. To achieve that, we conducted a questionnaire study focused on eleven patterns that directly influence the architecture and components structure. The questionnaire was answered by 63 participants and revealed that, in general, they know the patterns, but with a significant amount declaring that it was known only as a practice. Additionally, among other results, our study also identified that the patterns are more commonly adopted at the project beginning rather than by refactoring and that they frequently are adopted more than once in the same system.",IEEE conference,no,"['knowledge', 'usage', 'pattern', 'aligned', 'exploratory', 'study', 'professional', 'solution', 'large', 'count', 'extensive', 'pattern', 'language', 'defines', 'base', 'practice', 'document', 'solution', 'recurrent', 'problem', 'however', 'lack', 'study', 'investigating', 'pattern', 'known', 'applied', 'professional', 'understanding', 'pattern', 'used', 'enables', 'comprehend', 'design', 'process', 'architectural', 'style', 'identify', 'opportunity', 'improvement', 'work', 'aim', 'collect', 'analyze', 'information', 'professional', 'know', 'use', 'pattern', 'achieve', 'conducted', 'study', 'focused', 'pattern', 'directly', 'influence', 'structure', 'participant', 'revealed', 'general', 'know', 'pattern', 'significant', 'amount', 'known', 'practice', 'additionally', 'among', 'result', 'study', 'also', 'identified', 'pattern', 'commonly', 'adopted', 'project', 'rather', 'refactoring', 'adopted']"
"Access Point Management Using Java Based Microservice This research paper explores the design and implementation of an event-driven monitoring system for Wi-Fi6 Access Points (APs) using Java-based microservices architecture. WiFi 6's primary advantage over other standards is that it provides maximum speed and accessibility in congested networks. The system aims to enhance network management capabilities by leveraging real-time event processing and Kafka messaging infrastructure. Key components include event listeners for capturing Quality of Experience (QoE) and Trap events via Kafka topics from APs, microservices for event processing, and Kafka topics for inter-service communication. The paper discusses the architecture, functionality, and integration of each component, as well as the system's ability to identify and handle various event types, such as ap-info and user reports. Additionally, the paper addresses error handling mechanisms and debugging practices for events with undefined syntax. Overall, the research contributes to the advancement of network monitoring solutions through the utilization of microservices and events-driven architectures.",Access Point Management Using Java Based Microservice,"This research paper explores the design and implementation of an event-driven monitoring system for Wi-Fi6 Access Points (APs) using Java-based microservices architecture. WiFi 6's primary advantage over other standards is that it provides maximum speed and accessibility in congested networks. The system aims to enhance network management capabilities by leveraging real-time event processing and Kafka messaging infrastructure. Key components include event listeners for capturing Quality of Experience (QoE) and Trap events via Kafka topics from APs, microservices for event processing, and Kafka topics for inter-service communication. The paper discusses the architecture, functionality, and integration of each component, as well as the system's ability to identify and handle various event types, such as ap-info and user reports. Additionally, the paper addresses error handling mechanisms and debugging practices for events with undefined syntax. Overall, the research contributes to the advancement of network monitoring solutions through the utilization of microservices and events-driven architectures.",IEEE conference,no,"['access', 'point', 'management', 'using', 'java', 'based', 'research', 'paper', 'explores', 'design', 'implementation', 'monitoring', 'access', 'point', 'using', 'primary', 'advantage', 'standard', 'provides', 'maximum', 'speed', 'accessibility', 'network', 'aim', 'enhance', 'network', 'management', 'capability', 'leveraging', 'event', 'processing', 'kafka', 'messaging', 'infrastructure', 'key', 'include', 'event', 'capturing', 'quality', 'experience', 'event', 'via', 'kafka', 'topic', 'event', 'processing', 'kafka', 'topic', 'communication', 'paper', 'discusses', 'functionality', 'integration', 'well', 'ability', 'identify', 'handle', 'various', 'event', 'type', 'user', 'report', 'additionally', 'paper', 'address', 'error', 'handling', 'mechanism', 'debugging', 'practice', 'event', 'overall', 'research', 'contributes', 'advancement', 'network', 'monitoring', 'solution', 'utilization']"
"Analysis and Design of Microservices Architecture with GraphlQL as an API Gateway for Higher Education Information System The use of monolithic architecture is considered ineffective for use in large-scale applications because it can affect the complexity of further development. In addition, the use of monolithic architecture allows failure of part of the system that can affect the entire system, so that the application must be fully maintained. Microservices is an architecture built by separating component parts (services) that do not depend on each other and have their respective functions. Each service can communicate and is managed by an API gateway that implements GraphQL as a data communication protocol. The method of decomposition of the system into service is carried out by applying the Decomposition by business capability pattern method. In this study, the authors recommend the use of a new system architecture for Academic Information System on UIN Jakarta based on literature studies from existing research. The result of this research is an analysis and architectural design of microservices with GraphQL as the API Gateway for the academic information system of UIN Jakarta for student.",Analysis and Design of Microservices Architecture with GraphlQL as an API Gateway for Higher Education Information System,"The use of monolithic architecture is considered ineffective for use in large-scale applications because it can affect the complexity of further development. In addition, the use of monolithic architecture allows failure of part of the system that can affect the entire system, so that the application must be fully maintained. Microservices is an architecture built by separating component parts (services) that do not depend on each other and have their respective functions. Each service can communicate and is managed by an API gateway that implements GraphQL as a data communication protocol. The method of decomposition of the system into service is carried out by applying the Decomposition by business capability pattern method. In this study, the authors recommend the use of a new system architecture for Academic Information System on UIN Jakarta based on literature studies from existing research. The result of this research is an analysis and architectural design of microservices with GraphQL as the API Gateway for the academic information system of UIN Jakarta for student.",IEEE conference,no,"['analysis', 'design', 'api', 'gateway', 'higher', 'education', 'information', 'use', 'monolithic', 'considered', 'ineffective', 'use', 'affect', 'complexity', 'development', 'addition', 'use', 'monolithic', 'allows', 'failure', 'part', 'affect', 'entire', 'must', 'fully', 'built', 'part', 'respective', 'function', 'communicate', 'managed', 'api', 'gateway', 'implement', 'graphql', 'communication', 'protocol', 'method', 'decomposition', 'carried', 'applying', 'decomposition', 'business', 'capability', 'pattern', 'method', 'study', 'author', 'recommend', 'use', 'new', 'academic', 'information', 'based', 'literature', 'study', 'existing', 'research', 'result', 'research', 'analysis', 'architectural', 'design', 'graphql', 'api', 'gateway', 'academic', 'information', 'student']"
"An exploratory evaluation of replacing ESB with microservices in service-oriented architecture With the continuous progress in technology during the past few decades, cloud computing has become a fast-growing technology in the world, making computerized systems widespread. The emergence of Cloud Computing has evolved towards microservice concepts, which are highly demanded by corporates for enterprise application level. Most enterprise applications have moved away from traditional unified models of software programs like monolithic architecture and traditional SOA architecture to microservice architecture to ensure better scalability, lesser investment in hardware, and high performance. The monolithic architecture is designed in a manner that all the components and the modules are packed together and deployed on a single binary. However, in the microservice architecture, components are developed as small services so that horizontally and vertically scaling is made easier in comparison to monolith or SOA architecture. SOA and monolithic architecture are at a disadvantage compared to Microservice architecture, as they require colossal hardware specifications to scale the software. In general terms, the system performance of these architectures can be measured considering different aspects such as system capacity, throughput, and latency. This research focuses on how scalability and performance software quality attributes behave when converting the SOA system to microservice architecture. Experimental results have shown that microservice architecture can bring more scalability with a minimum cost generation. Nevertheless, specific gaps in performance are identified in the perspective of the final user experiences due to the interservice communication in the microservice architecture in a distributed environment.",An exploratory evaluation of replacing ESB with microservices in service-oriented architecture,"With the continuous progress in technology during the past few decades, cloud computing has become a fast-growing technology in the world, making computerized systems widespread. The emergence of Cloud Computing has evolved towards microservice concepts, which are highly demanded by corporates for enterprise application level. Most enterprise applications have moved away from traditional unified models of software programs like monolithic architecture and traditional SOA architecture to microservice architecture to ensure better scalability, lesser investment in hardware, and high performance. The monolithic architecture is designed in a manner that all the components and the modules are packed together and deployed on a single binary. However, in the microservice architecture, components are developed as small services so that horizontally and vertically scaling is made easier in comparison to monolith or SOA architecture. SOA and monolithic architecture are at a disadvantage compared to Microservice architecture, as they require colossal hardware specifications to scale the software. In general terms, the system performance of these architectures can be measured considering different aspects such as system capacity, throughput, and latency. This research focuses on how scalability and performance software quality attributes behave when converting the SOA system to microservice architecture. Experimental results have shown that microservice architecture can bring more scalability with a minimum cost generation. Nevertheless, specific gaps in performance are identified in the perspective of the final user experiences due to the interservice communication in the microservice architecture in a distributed environment.",IEEE conference,no,"['exploratory', 'evaluation', 'replacing', 'continuous', 'progress', 'technology', 'past', 'decade', 'computing', 'become', 'technology', 'world', 'making', 'widespread', 'emergence', 'computing', 'evolved', 'towards', 'concept', 'highly', 'enterprise', 'level', 'enterprise', 'moved', 'away', 'traditional', 'unified', 'model', 'program', 'like', 'monolithic', 'traditional', 'soa', 'ensure', 'better', 'scalability', 'investment', 'hardware', 'high', 'performance', 'monolithic', 'designed', 'manner', 'module', 'together', 'deployed', 'single', 'binary', 'however', 'developed', 'small', 'scaling', 'made', 'easier', 'comparison', 'monolith', 'soa', 'soa', 'monolithic', 'disadvantage', 'compared', 'require', 'hardware', 'specification', 'scale', 'general', 'term', 'performance', 'measured', 'considering', 'different', 'aspect', 'capacity', 'throughput', 'latency', 'research', 'focus', 'scalability', 'performance', 'quality', 'attribute', 'behave', 'converting', 'soa', 'experimental', 'result', 'shown', 'bring', 'scalability', 'minimum', 'cost', 'generation', 'nevertheless', 'specific', 'gap', 'performance', 'identified', 'perspective', 'final', 'user', 'experience', 'due', 'communication', 'distributed', 'environment']"
"An application about server communication: Using the Command pattern on Web API requests In modern applications, performing a large number of activities and exchange of information, the architectural approach of microservices is increasingly required. If we make a more detailed analysis of them, they are nothing more than standalone applications that are synchronized in their communication between them, they are interchangeable in certain situations, and they are also divided by functionality. In addition to microservices, the so-called monolithic applications also work with the reception and processing of requests, which architecturally translates into an even greater concentration of functionality in one place and this leads to difficulties in their maintenance. In modern microservice architectures, different methods of communication are often used: microservices often communicate via HTTP with RESTful API design. URLs are used to detect and access microservices. Message Brokers: the use of communications brokers such as RabbitMQ 1 or Apache Kafka 2 provides an effective way of asynchronous communication. Whether we are talking about monolithic or microservice applications, it always comes the moment with the growing code, complex service structure and maintenance. In the current development, we focus on the implementation of a new service in a microservice architecture. The goal of the development is to create an application architecture using design patterns and optimization solutions that lead to fast and efficient operations of the business layer, which remains stable in its performance even with a large amount of data to process.1www.rabbitmq.com2https://kafka.apache.org",An application about server communication: Using the Command pattern on Web API requests,"In modern applications, performing a large number of activities and exchange of information, the architectural approach of microservices is increasingly required. If we make a more detailed analysis of them, they are nothing more than standalone applications that are synchronized in their communication between them, they are interchangeable in certain situations, and they are also divided by functionality. In addition to microservices, the so-called monolithic applications also work with the reception and processing of requests, which architecturally translates into an even greater concentration of functionality in one place and this leads to difficulties in their maintenance. In modern microservice architectures, different methods of communication are often used: microservices often communicate via HTTP with RESTful API design. URLs are used to detect and access microservices. Message Brokers: the use of communications brokers such as RabbitMQ 1 or Apache Kafka 2 provides an effective way of asynchronous communication. Whether we are talking about monolithic or microservice applications, it always comes the moment with the growing code, complex service structure and maintenance. In the current development, we focus on the implementation of a new service in a microservice architecture. The goal of the development is to create an application architecture using design patterns and optimization solutions that lead to fast and efficient operations of the business layer, which remains stable in its performance even with a large amount of data to process.1www.rabbitmq.com2https://kafka.apache.org",IEEE conference,no,"['server', 'communication', 'using', 'command', 'pattern', 'web', 'api', 'request', 'modern', 'performing', 'large', 'number', 'activity', 'exchange', 'information', 'architectural', 'increasingly', 'required', 'make', 'detailed', 'analysis', 'synchronized', 'communication', 'certain', 'situation', 'also', 'divided', 'functionality', 'addition', 'monolithic', 'also', 'work', 'processing', 'request', 'even', 'greater', 'functionality', 'one', 'place', 'lead', 'difficulty', 'maintenance', 'modern', 'different', 'method', 'communication', 'often', 'used', 'often', 'communicate', 'via', 'http', 'restful', 'api', 'design', 'used', 'detect', 'access', 'message', 'broker', 'use', 'communication', 'broker', 'rabbitmq', 'apache', 'kafka', 'provides', 'effective', 'way', 'asynchronous', 'communication', 'whether', 'monolithic', 'always', 'come', 'growing', 'code', 'complex', 'structure', 'maintenance', 'current', 'development', 'focus', 'implementation', 'new', 'goal', 'development', 'create', 'using', 'design', 'pattern', 'optimization', 'solution', 'lead', 'fast', 'efficient', 'operation', 'business', 'layer', 'remains', 'stable', 'performance', 'even', 'large', 'amount']"
"Automatically Refactoring Application Transactions for Microservice-Oriented Architecture An Application Transaction, which is a method-call flow from an exported API to a data-source access, is important for application modernization for microservice-oriented architecture. The application transaction in legacy applications is based on a traditional unified architecture on which a single application and database structure under low latency is assumed, which means that a significant decrease in performance can occur on microservice-oriented architectures composed of distributed application and database structures under high latency. Therefore, transaction refactoring is essential for application modernization. However, it is time-consuming and labor-intensive to manually identify the transaction split point in an application transaction. In this paper, we propose an approach for automatically refactoring the recommendation for application transactions by identifying the split point on the basis of database operation and business contexts. Our approach involves using a framework we designed for discovering application transactions from binary Java code and two partitioning methods, “operation-based splitting“ and “business-context-based splitting“ for detecting the optimal split points for application transactions in applications with different implementation patterns. We applied our approach to actual enterprise applications, identified split points for transaction-refactoring recommendation, and showed that it can significantly reduce processing time compared with doing it manually.",Automatically Refactoring Application Transactions for Microservice-Oriented Architecture,"An Application Transaction, which is a method-call flow from an exported API to a data-source access, is important for application modernization for microservice-oriented architecture. The application transaction in legacy applications is based on a traditional unified architecture on which a single application and database structure under low latency is assumed, which means that a significant decrease in performance can occur on microservice-oriented architectures composed of distributed application and database structures under high latency. Therefore, transaction refactoring is essential for application modernization. However, it is time-consuming and labor-intensive to manually identify the transaction split point in an application transaction. In this paper, we propose an approach for automatically refactoring the recommendation for application transactions by identifying the split point on the basis of database operation and business contexts. Our approach involves using a framework we designed for discovering application transactions from binary Java code and two partitioning methods, “operation-based splitting“ and “business-context-based splitting“ for detecting the optimal split points for application transactions in applications with different implementation patterns. We applied our approach to actual enterprise applications, identified split points for transaction-refactoring recommendation, and showed that it can significantly reduce processing time compared with doing it manually.",IEEE conference,no,"['automatically', 'refactoring', 'transaction', 'transaction', 'flow', 'api', 'access', 'important', 'transaction', 'legacy', 'based', 'traditional', 'unified', 'single', 'database', 'structure', 'low', 'latency', 'mean', 'significant', 'decrease', 'performance', 'occur', 'composed', 'distributed', 'database', 'structure', 'high', 'latency', 'therefore', 'transaction', 'refactoring', 'essential', 'however', 'manually', 'identify', 'transaction', 'split', 'point', 'transaction', 'paper', 'propose', 'automatically', 'refactoring', 'recommendation', 'transaction', 'identifying', 'split', 'point', 'basis', 'database', 'operation', 'business', 'context', 'involves', 'using', 'framework', 'designed', 'transaction', 'binary', 'java', 'code', 'two', 'partitioning', 'method', 'splitting', 'splitting', 'detecting', 'optimal', 'split', 'point', 'transaction', 'different', 'implementation', 'pattern', 'applied', 'actual', 'enterprise', 'identified', 'split', 'point', 'recommendation', 'showed', 'significantly', 'reduce', 'processing', 'time', 'compared', 'manually']"
"Reactive Microservices Architecture Using a Framework of Fault Tolerance Mechanisms In Cloud Computing, microservices have been recently introduced for enabling the development of large-scale structures, which are scalable, agile and especially suitable for meeting the emerging demands. The asynchronous communication has facilitated using reactive system which managed in interaction challenges and even variation of load in modern systems. There are certain features of microservices like elasticity and resilience have considered for messages can be progressed through Reactive Microservices (RM) which consists of segregated components over event stream that can able to perform individually or shown with various microservices for reaching the event at final stages. The reactive principle in microservices have involved for individual possibility in every microservice components reference architecture include the components of microservices, which have the ability to develop, release, organize, scale, upgrade and retired individually. It has infused the necessary redundancy into the network for avoiding failure cascading, which maintains the system reactive in case of any failure. This paper has explored the RM architecture application and provides insights by assisting in reducing the developing demand to create resilient and scalable systems. The basic use case of microservice framework implementation has been illustrated by Vert.x, which act as the general toolkit to create RM and also the performance of both reactive and nonreactive implementation are compared as an alternate. The performance comparison can reveal how RM performs better than non-reactive microservices.",Reactive Microservices Architecture Using a Framework of Fault Tolerance Mechanisms,"In Cloud Computing, microservices have been recently introduced for enabling the development of large-scale structures, which are scalable, agile and especially suitable for meeting the emerging demands. The asynchronous communication has facilitated using reactive system which managed in interaction challenges and even variation of load in modern systems. There are certain features of microservices like elasticity and resilience have considered for messages can be progressed through Reactive Microservices (RM) which consists of segregated components over event stream that can able to perform individually or shown with various microservices for reaching the event at final stages. The reactive principle in microservices have involved for individual possibility in every microservice components reference architecture include the components of microservices, which have the ability to develop, release, organize, scale, upgrade and retired individually. It has infused the necessary redundancy into the network for avoiding failure cascading, which maintains the system reactive in case of any failure. This paper has explored the RM architecture application and provides insights by assisting in reducing the developing demand to create resilient and scalable systems. The basic use case of microservice framework implementation has been illustrated by Vert.x, which act as the general toolkit to create RM and also the performance of both reactive and nonreactive implementation are compared as an alternate. The performance comparison can reveal how RM performs better than non-reactive microservices.",IEEE conference,no,"['reactive', 'using', 'framework', 'fault', 'tolerance', 'mechanism', 'computing', 'recently', 'introduced', 'enabling', 'development', 'structure', 'scalable', 'agile', 'especially', 'suitable', 'meeting', 'emerging', 'demand', 'asynchronous', 'communication', 'facilitated', 'using', 'reactive', 'managed', 'interaction', 'challenge', 'even', 'load', 'modern', 'certain', 'feature', 'like', 'elasticity', 'resilience', 'considered', 'message', 'reactive', 'rm', 'consists', 'event', 'stream', 'able', 'perform', 'individually', 'shown', 'various', 'event', 'final', 'stage', 'reactive', 'principle', 'involved', 'individual', 'possibility', 'every', 'reference', 'include', 'ability', 'develop', 'release', 'scale', 'upgrade', 'individually', 'necessary', 'redundancy', 'network', 'avoiding', 'failure', 'maintains', 'reactive', 'case', 'failure', 'paper', 'explored', 'rm', 'provides', 'insight', 'assisting', 'reducing', 'developing', 'demand', 'create', 'resilient', 'scalable', 'basic', 'use', 'case', 'framework', 'implementation', 'illustrated', 'act', 'general', 'toolkit', 'create', 'rm', 'also', 'performance', 'reactive', 'implementation', 'compared', 'performance', 'comparison', 'reveal', 'rm', 'performs', 'better']"
"Architecture Interoperability and Repeatability with Microservices: An Industry Perspective Microservices, along with supporting technologies such as containers, have become a prevalent architecture approach for today's software systems, especially in enterprise environments. They represent the latest evolutionary step in the decades-old journey towards service-and component-based software architectures. Along with virtualization technologies, microservices have enabled the loose-coupling of both service interfaces (message passing) and service integration (form and fit). This paper attempts to explore the impact of microservices on software architecture interoperability and repeatability, based on our experiences in developing two microservice-based systems. Our central thesis is that, if we view software architecture as a set of principal design decisions, the microservices approach enable us to more elegantly separate these decisions from non-architectural, domain-specific ones, and thus make these decisions more interoperable, reusable, and repeatable across disparate problem domains. We therefore propose that a microservices based reference architecture (RA) and reference implementation (RI) be created for the community-wide infrastructure for software engineering and software architecture research, along with a set of detailed considerations.",Architecture Interoperability and Repeatability with Microservices: An Industry Perspective,"Microservices, along with supporting technologies such as containers, have become a prevalent architecture approach for today's software systems, especially in enterprise environments. They represent the latest evolutionary step in the decades-old journey towards service-and component-based software architectures. Along with virtualization technologies, microservices have enabled the loose-coupling of both service interfaces (message passing) and service integration (form and fit). This paper attempts to explore the impact of microservices on software architecture interoperability and repeatability, based on our experiences in developing two microservice-based systems. Our central thesis is that, if we view software architecture as a set of principal design decisions, the microservices approach enable us to more elegantly separate these decisions from non-architectural, domain-specific ones, and thus make these decisions more interoperable, reusable, and repeatable across disparate problem domains. We therefore propose that a microservices based reference architecture (RA) and reference implementation (RI) be created for the community-wide infrastructure for software engineering and software architecture research, along with a set of detailed considerations.",IEEE conference,no,"['interoperability', 'industry', 'perspective', 'along', 'supporting', 'technology', 'container', 'become', 'prevalent', 'today', 'especially', 'enterprise', 'environment', 'represent', 'latest', 'evolutionary', 'step', 'towards', 'along', 'virtualization', 'technology', 'enabled', 'interface', 'message', 'passing', 'integration', 'form', 'fit', 'paper', 'attempt', 'explore', 'impact', 'interoperability', 'based', 'experience', 'developing', 'two', 'central', 'view', 'set', 'principal', 'design', 'decision', 'enable', 'u', 'separate', 'decision', 'one', 'thus', 'make', 'decision', 'interoperable', 'reusable', 'repeatable', 'across', 'problem', 'domain', 'therefore', 'propose', 'based', 'reference', 'reference', 'implementation', 'created', 'infrastructure', 'engineering', 'research', 'along', 'set', 'detailed', 'consideration']"
"Online Experiment Platform: A Microservices-based Cloud Native Application The development of cloud native technologies and web technologies is constantly innovating all aspects of web applications. As the scale of web applications continues to expand, the complexity of design, development, deployment and maintenance is getting higher and higher. The industry urgently needs a new web development paradigm to meet the upcoming challenge, so the concept of microservices comes into being, and soon becomes the preferred solution for large companies and individual developers. The emergence of public and private clouds further reduces the difficulty of implementing microservices-based applications. This article analyzes the idea of microservices architecture and its key components, then presents a microservices-based cloud native application Online experiment platform. As a complete product, its life cycle well demonstrates the advantages of microservices architecture and the practical significance of cloud native concept.",Online Experiment Platform: A Microservices-based Cloud Native Application,"The development of cloud native technologies and web technologies is constantly innovating all aspects of web applications. As the scale of web applications continues to expand, the complexity of design, development, deployment and maintenance is getting higher and higher. The industry urgently needs a new web development paradigm to meet the upcoming challenge, so the concept of microservices comes into being, and soon becomes the preferred solution for large companies and individual developers. The emergence of public and private clouds further reduces the difficulty of implementing microservices-based applications. This article analyzes the idea of microservices architecture and its key components, then presents a microservices-based cloud native application Online experiment platform. As a complete product, its life cycle well demonstrates the advantages of microservices architecture and the practical significance of cloud native concept.",IEEE conference,no,"['online', 'experiment', 'platform', 'native', 'development', 'native', 'technology', 'web', 'technology', 'constantly', 'aspect', 'web', 'scale', 'web', 'complexity', 'design', 'development', 'deployment', 'maintenance', 'getting', 'higher', 'higher', 'industry', 'need', 'new', 'web', 'development', 'paradigm', 'meet', 'challenge', 'concept', 'come', 'soon', 'becomes', 'preferred', 'solution', 'large', 'company', 'individual', 'developer', 'emergence', 'public', 'private', 'reduces', 'difficulty', 'implementing', 'article', 'analyzes', 'idea', 'key', 'present', 'native', 'online', 'experiment', 'platform', 'complete', 'product', 'life', 'cycle', 'well', 'demonstrates', 'advantage', 'practical', 'native', 'concept']"
"Reflections on SOA and Microservices Today's Enterprises are facing many challenges in the service oriented, customer experience centric and customer demand driven global environment where ICT is becoming the leading enabler and partner of the modern enterprise. In the last decade, many enterprises have invested heavily in SOA-aligned IT transformations, but not harvested what SOA promised to provide. Now the API and Microservice paradigm has emerged as the ""next big thing"" for delivering IT outcomes to support the modern enterprise, with many technology vendors and service jumping on the bandwagon. This paper undertakes a critical investigation of the key concepts around SOA, API and Microservices, identifying similarities and differences between them and dispelling the confusion and hype around them. Based on our discussion and analysis, this paper presents a set of recommendations and best practices on the effective use and management of enterprise software components, drawing upon the best of SOA, API and Microservice concepts and practice.",Reflections on SOA and Microservices,"Today's Enterprises are facing many challenges in the service oriented, customer experience centric and customer demand driven global environment where ICT is becoming the leading enabler and partner of the modern enterprise. In the last decade, many enterprises have invested heavily in SOA-aligned IT transformations, but not harvested what SOA promised to provide. Now the API and Microservice paradigm has emerged as the ""next big thing"" for delivering IT outcomes to support the modern enterprise, with many technology vendors and service jumping on the bandwagon. This paper undertakes a critical investigation of the key concepts around SOA, API and Microservices, identifying similarities and differences between them and dispelling the confusion and hype around them. Based on our discussion and analysis, this paper presents a set of recommendations and best practices on the effective use and management of enterprise software components, drawing upon the best of SOA, API and Microservice concepts and practice.",IEEE conference,no,"['soa', 'today', 'enterprise', 'facing', 'many', 'challenge', 'oriented', 'customer', 'experience', 'centric', 'customer', 'demand', 'driven', 'global', 'environment', 'ict', 'becoming', 'leading', 'enabler', 'partner', 'modern', 'enterprise', 'last', 'decade', 'many', 'enterprise', 'heavily', 'transformation', 'soa', 'provide', 'api', 'paradigm', 'emerged', 'next', 'big', 'thing', 'delivering', 'outcome', 'support', 'modern', 'enterprise', 'many', 'technology', 'vendor', 'paper', 'critical', 'investigation', 'key', 'concept', 'around', 'soa', 'api', 'identifying', 'similarity', 'difference', 'around', 'based', 'discussion', 'analysis', 'paper', 'present', 'set', 'recommendation', 'best', 'practice', 'effective', 'use', 'management', 'enterprise', 'upon', 'best', 'soa', 'api', 'concept', 'practice']"
"Development of Applications Based on Microservices - Case Study of Ministry of Economy and Finance of Paraguay The Ministry of Economy and Finance (MEF) is responsible for the development and maintenance of Paraguay's Integrated State Financial Administration System (SIARE), which provides state financial services for the Ministry and other governmental entities. Currently, the MEF count with a system built on client-server architecture and monolithic sub-systems, which presents challenges related to scalability, agility in the implementation of new functionalities and high coupling between modules. This article presents the technological adaptation and integration of the microservices architecture in SIARE. The solution comprises an ecosystem of components. Each of these components adheres to a layering scheme, which responds to a logical grouping of the internal components of each one of them. This architectural approach allows them to be grouped by responsibilities from the point of view of information, behavior and security. This architectural approach favors the decoupling of components, which increases the flexibility and maintainability of the system. The development practice employed throughout the project life cycle was the agile scrum methodology. The functionalities are outlined in Use Cases and the main technologies used to build the applications were: Spring Boot, Angular, Oracle, PostgreSql, Redis and Kafka. Besides, for artifact orchestration, Jenkins and WSO2 API Manager were deployed to manage the REST API services. In addition, for application observability, the ELK tool was selected as a monitoring tool. As a result of the performance tests we could observe that the architecture is stable to support large amount of workload, supporting at least 5000 simultaneous requests per second.",Development of Applications Based on Microservices - Case Study of Ministry of Economy and Finance of Paraguay,"The Ministry of Economy and Finance (MEF) is responsible for the development and maintenance of Paraguay's Integrated State Financial Administration System (SIARE), which provides state financial services for the Ministry and other governmental entities. Currently, the MEF count with a system built on client-server architecture and monolithic sub-systems, which presents challenges related to scalability, agility in the implementation of new functionalities and high coupling between modules. This article presents the technological adaptation and integration of the microservices architecture in SIARE. The solution comprises an ecosystem of components. Each of these components adheres to a layering scheme, which responds to a logical grouping of the internal components of each one of them. This architectural approach allows them to be grouped by responsibilities from the point of view of information, behavior and security. This architectural approach favors the decoupling of components, which increases the flexibility and maintainability of the system. The development practice employed throughout the project life cycle was the agile scrum methodology. The functionalities are outlined in Use Cases and the main technologies used to build the applications were: Spring Boot, Angular, Oracle, PostgreSql, Redis and Kafka. Besides, for artifact orchestration, Jenkins and WSO2 API Manager were deployed to manage the REST API services. In addition, for application observability, the ELK tool was selected as a monitoring tool. As a result of the performance tests we could observe that the architecture is stable to support large amount of workload, supporting at least 5000 simultaneous requests per second.",IEEE conference,no,"['development', 'based', 'case', 'study', 'ministry', 'economy', 'finance', 'ministry', 'economy', 'finance', 'responsible', 'development', 'maintenance', 'integrated', 'state', 'financial', 'administration', 'provides', 'state', 'financial', 'ministry', 'entity', 'currently', 'count', 'built', 'monolithic', 'present', 'challenge', 'related', 'scalability', 'agility', 'implementation', 'new', 'functionality', 'high', 'coupling', 'module', 'article', 'present', 'technological', 'adaptation', 'integration', 'solution', 'comprises', 'ecosystem', 'scheme', 'logical', 'grouping', 'internal', 'one', 'architectural', 'allows', 'responsibility', 'point', 'view', 'information', 'behavior', 'security', 'architectural', 'decoupling', 'increase', 'flexibility', 'maintainability', 'development', 'practice', 'employed', 'throughout', 'project', 'life', 'cycle', 'agile', 'methodology', 'functionality', 'outlined', 'use', 'case', 'main', 'technology', 'used', 'build', 'spring', 'boot', 'kafka', 'besides', 'artifact', 'orchestration', 'jenkins', 'api', 'manager', 'deployed', 'manage', 'rest', 'api', 'addition', 'observability', 'tool', 'selected', 'monitoring', 'tool', 'result', 'performance', 'test', 'could', 'observe', 'stable', 'support', 'large', 'amount', 'workload', 'supporting', 'least', 'request', 'per', 'second']"
"Introduction to Inline-Services: A Seamless Approach to Microservices Development In recent years, there has been a notable surge in the popularity of the modern software development approach using microservices. This approach inherently comes with its own complexities and over time there have been efforts made ease deployment and maintenance using orchestration frameworks, but not much has been done on the development, creation and usage of microservices. The purpose of this paper is to introduce a streamlined and simpler approach for the creation and utilization of Microservices. By employing this approach, the intricacies of service development and deployment are concealed, allowing developers to concentrate on the core aspects of the problem domain. This paper will outline the fundamental concepts and components of the framework, accompanied by a Proof-of-Concept implementation in Java. The development of a complex distributed service-oriented application is reduced to as simple as a local application.",Introduction to Inline-Services: A Seamless Approach to Microservices Development,"In recent years, there has been a notable surge in the popularity of the modern software development approach using microservices. This approach inherently comes with its own complexities and over time there have been efforts made ease deployment and maintenance using orchestration frameworks, but not much has been done on the development, creation and usage of microservices. The purpose of this paper is to introduce a streamlined and simpler approach for the creation and utilization of Microservices. By employing this approach, the intricacies of service development and deployment are concealed, allowing developers to concentrate on the core aspects of the problem domain. This paper will outline the fundamental concepts and components of the framework, accompanied by a Proof-of-Concept implementation in Java. The development of a complex distributed service-oriented application is reduced to as simple as a local application.",IEEE conference,no,"['introduction', 'seamless', 'development', 'recent', 'year', 'notable', 'surge', 'popularity', 'modern', 'development', 'using', 'inherently', 'come', 'complexity', 'time', 'effort', 'made', 'ease', 'deployment', 'maintenance', 'using', 'orchestration', 'framework', 'much', 'done', 'development', 'creation', 'usage', 'purpose', 'paper', 'introduce', 'streamlined', 'simpler', 'creation', 'utilization', 'employing', 'intricacy', 'development', 'deployment', 'allowing', 'developer', 'concentrate', 'core', 'aspect', 'problem', 'domain', 'paper', 'outline', 'fundamental', 'concept', 'framework', 'implementation', 'java', 'development', 'complex', 'distributed', 'reduced', 'simple', 'local']"
"Smart City Service System Design Based On Microservice Architecture: Case Study in Magelang City The micro service-oriented platform provides a flexible and scalable implementation to accommodate the various services offered to citizens in the smart city concept. Integration is a problem that arises along with the widespread application of smart cities, which are seen as a service system. The purpose of the research is to design a good service system as a solution to existing problems. The study will be more specific on service systems as part of implementing smart cities by referring to previous research. Service system engineering is the method, and it takes a top-down, holistic approach. This research results in a microservice architecture design for smart city service system engineering. The resulting design can be a guide to providing decent and better services for citizens.",Smart City Service System Design Based On Microservice Architecture: Case Study in Magelang City,"The micro service-oriented platform provides a flexible and scalable implementation to accommodate the various services offered to citizens in the smart city concept. Integration is a problem that arises along with the widespread application of smart cities, which are seen as a service system. The purpose of the research is to design a good service system as a solution to existing problems. The study will be more specific on service systems as part of implementing smart cities by referring to previous research. Service system engineering is the method, and it takes a top-down, holistic approach. This research results in a microservice architecture design for smart city service system engineering. The resulting design can be a guide to providing decent and better services for citizens.",IEEE conference,no,"['smart', 'city', 'design', 'based', 'case', 'study', 'city', 'micro', 'platform', 'provides', 'flexible', 'scalable', 'implementation', 'accommodate', 'various', 'offered', 'citizen', 'smart', 'city', 'concept', 'integration', 'problem', 'arises', 'along', 'widespread', 'smart', 'city', 'seen', 'purpose', 'research', 'design', 'good', 'solution', 'existing', 'problem', 'study', 'specific', 'part', 'implementing', 'smart', 'city', 'previous', 'research', 'engineering', 'method', 'take', 'holistic', 'research', 'result', 'design', 'smart', 'city', 'engineering', 'resulting', 'design', 'guide', 'providing', 'better', 'citizen']"
"Towards a Multi-Tenant Microservice Architecture: An Industrial Experience Academia and industry have recently acknowledged the many benefits of architecting with microservices. Nonethe-less, adopting a microservice architecture does not immediately guarantee the achievements promised by such an architectural style. A crucial architectural decision is why and where multi-tenancy should be adopted in microservice architectures. This paper presents a multi-tenant microservice architecture conceived to meet the requirements of a company to serve multiple customer applications (tenants). By reporting the migration and modern-ization of a monolith legacy architecture towards microservices, this paper discusses how a multi-tenant microservice architecture could benefit scalability, management, and third-party system integration. This paper also presents empirical results of a scalability evaluation to assess the adoption of multi-tenancy in the proposed architecture and quantify its impact on the system's performance.",Towards a Multi-Tenant Microservice Architecture: An Industrial Experience,"Academia and industry have recently acknowledged the many benefits of architecting with microservices. Nonethe-less, adopting a microservice architecture does not immediately guarantee the achievements promised by such an architectural style. A crucial architectural decision is why and where multi-tenancy should be adopted in microservice architectures. This paper presents a multi-tenant microservice architecture conceived to meet the requirements of a company to serve multiple customer applications (tenants). By reporting the migration and modern-ization of a monolith legacy architecture towards microservices, this paper discusses how a multi-tenant microservice architecture could benefit scalability, management, and third-party system integration. This paper also presents empirical results of a scalability evaluation to assess the adoption of multi-tenancy in the proposed architecture and quantify its impact on the system's performance.",IEEE conference,no,"['towards', 'industrial', 'experience', 'academia', 'industry', 'recently', 'many', 'benefit', 'architecting', 'adopting', 'guarantee', 'architectural', 'style', 'crucial', 'architectural', 'decision', 'adopted', 'paper', 'present', 'meet', 'requirement', 'company', 'serve', 'multiple', 'customer', 'tenant', 'migration', 'monolith', 'legacy', 'towards', 'paper', 'discusses', 'could', 'benefit', 'scalability', 'management', 'integration', 'paper', 'also', 'present', 'empirical', 'result', 'scalability', 'evaluation', 'assess', 'adoption', 'proposed', 'quantify', 'impact', 'performance']"
"Optimizing HR Monolithic Systems to Modern HR Systems using Microservices Architecture Human Recourse (HR) are a vital function of any organization because it manages the most valuable resource of the company. However, traditional HR systems are generally monolithic, complex, and inflexible, which penalizes their ability to adapt to changing business needs and employee expectations. In this paper, we have proposed a new approach to optimize HRs processes using microservice architecture. Microservices offer many benefits to modern HRs systems, such as scalability, flexibility, reliability, and security. We will provide a prototype of an HR system designed using microservice architecture. The prototype shows microservices facilitate rapid development, testing, and deployment of HRs system capable of meeting evolving organizational needs. Through rigorous testing and evaluation, the prototype demonstrated substantial improvements in delivery time, resource utilization, and system modularity compared to monolithic HRs systems, making this a promising option for modern HRs management in diverse organizational structures.",Optimizing HR Monolithic Systems to Modern HR Systems using Microservices Architecture,"Human Recourse (HR) are a vital function of any organization because it manages the most valuable resource of the company. However, traditional HR systems are generally monolithic, complex, and inflexible, which penalizes their ability to adapt to changing business needs and employee expectations. In this paper, we have proposed a new approach to optimize HRs processes using microservice architecture. Microservices offer many benefits to modern HRs systems, such as scalability, flexibility, reliability, and security. We will provide a prototype of an HR system designed using microservice architecture. The prototype shows microservices facilitate rapid development, testing, and deployment of HRs system capable of meeting evolving organizational needs. Through rigorous testing and evaluation, the prototype demonstrated substantial improvements in delivery time, resource utilization, and system modularity compared to monolithic HRs systems, making this a promising option for modern HRs management in diverse organizational structures.",IEEE conference,no,"['optimizing', 'hr', 'monolithic', 'modern', 'hr', 'using', 'human', 'hr', 'vital', 'function', 'organization', 'manages', 'valuable', 'resource', 'company', 'however', 'traditional', 'hr', 'generally', 'monolithic', 'complex', 'ability', 'adapt', 'changing', 'business', 'need', 'expectation', 'paper', 'proposed', 'new', 'optimize', 'hr', 'process', 'using', 'offer', 'many', 'benefit', 'modern', 'hr', 'scalability', 'flexibility', 'reliability', 'security', 'provide', 'prototype', 'hr', 'designed', 'using', 'prototype', 'show', 'facilitate', 'rapid', 'development', 'testing', 'deployment', 'hr', 'capable', 'meeting', 'evolving', 'organizational', 'need', 'testing', 'evaluation', 'prototype', 'demonstrated', 'substantial', 'improvement', 'delivery', 'time', 'resource', 'utilization', 'modularity', 'compared', 'monolithic', 'hr', 'making', 'promising', 'option', 'modern', 'hr', 'management', 'diverse', 'organizational', 'structure']"
"Evaluating Frameworks Assemblies In Microservices-based Systems Using Imperfect Information Microservices is an architectural style that promotes the facility to build and maintain systems by breaking down its business capabilities into smaller and distributed services. Often, practitioners commonly use frameworks to provide generic functionalities to address recurring quality attribute concerns on microservices-based systems. Nevertheless, in practical settings, frameworks information is incomplete, imprecise, and changing as well as requirements. More realistically deployable approaches combine the exploration of candidate architectures with their evaluation regarding requirements satisfaction and the fuzziness and incompleteness available frameworks information. This article outlines a novel technique, called μAzimut, whose purpose is to generate, evaluate, and compare frameworks assemblies using potentially incomplete, imprecise, and changing descriptions of non-functional requirements and frameworks. The frameworks assemblies evaluation is based on a support score which allows modeling imperfect architectural knowledge. The technique is evaluated in an industrial case study. The results point out that μAzimut generates solutions that are close to those solutions that an architect selects for designing microservices architectures.",Evaluating Frameworks Assemblies In Microservices-based Systems Using Imperfect Information,"Microservices is an architectural style that promotes the facility to build and maintain systems by breaking down its business capabilities into smaller and distributed services. Often, practitioners commonly use frameworks to provide generic functionalities to address recurring quality attribute concerns on microservices-based systems. Nevertheless, in practical settings, frameworks information is incomplete, imprecise, and changing as well as requirements. More realistically deployable approaches combine the exploration of candidate architectures with their evaluation regarding requirements satisfaction and the fuzziness and incompleteness available frameworks information. This article outlines a novel technique, called μAzimut, whose purpose is to generate, evaluate, and compare frameworks assemblies using potentially incomplete, imprecise, and changing descriptions of non-functional requirements and frameworks. The frameworks assemblies evaluation is based on a support score which allows modeling imperfect architectural knowledge. The technique is evaluated in an industrial case study. The results point out that μAzimut generates solutions that are close to those solutions that an architect selects for designing microservices architectures.",IEEE conference,no,"['evaluating', 'framework', 'assembly', 'using', 'information', 'architectural', 'style', 'promotes', 'facility', 'build', 'maintain', 'breaking', 'business', 'capability', 'smaller', 'distributed', 'often', 'practitioner', 'commonly', 'use', 'framework', 'provide', 'generic', 'functionality', 'address', 'recurring', 'quality', 'attribute', 'concern', 'nevertheless', 'practical', 'setting', 'framework', 'information', 'changing', 'well', 'requirement', 'deployable', 'combine', 'exploration', 'candidate', 'evaluation', 'regarding', 'requirement', 'available', 'framework', 'information', 'article', 'outline', 'novel', 'technique', 'called', 'whose', 'purpose', 'generate', 'evaluate', 'compare', 'framework', 'assembly', 'using', 'potentially', 'changing', 'description', 'requirement', 'framework', 'framework', 'assembly', 'evaluation', 'based', 'support', 'score', 'allows', 'modeling', 'architectural', 'knowledge', 'technique', 'evaluated', 'industrial', 'case', 'study', 'result', 'point', 'generates', 'solution', 'close', 'solution', 'architect', 'selects', 'designing']"
"A Microservice Architecture for Online Mobile App Optimization A large number of techniques for analyzing and optimizing mobile apps have emerged in the past decade. However, those techniques' components are notoriously difficult to extract and reuse outside their original tools. This paper introduces MAOMAO, a microservice-based reference architecture for reusing and integrating such components. MAOMAO's twin goals are (1) adoption of available app optimization techniques in practice and (2) improved construction and evaluation of new techniques. The paper uses several existing app optimization techniques to illustrate both the motivation behind MAOMAO and its potential to fundamentally alter the landscape in this area.",A Microservice Architecture for Online Mobile App Optimization,"A large number of techniques for analyzing and optimizing mobile apps have emerged in the past decade. However, those techniques' components are notoriously difficult to extract and reuse outside their original tools. This paper introduces MAOMAO, a microservice-based reference architecture for reusing and integrating such components. MAOMAO's twin goals are (1) adoption of available app optimization techniques in practice and (2) improved construction and evaluation of new techniques. The paper uses several existing app optimization techniques to illustrate both the motivation behind MAOMAO and its potential to fundamentally alter the landscape in this area.",IEEE conference,no,"['online', 'mobile', 'app', 'optimization', 'large', 'number', 'technique', 'analyzing', 'optimizing', 'mobile', 'apps', 'emerged', 'past', 'decade', 'however', 'technique', 'difficult', 'extract', 'reuse', 'outside', 'original', 'tool', 'paper', 'introduces', 'maomao', 'reference', 'reusing', 'integrating', 'maomao', 'twin', 'goal', 'adoption', 'available', 'app', 'optimization', 'technique', 'practice', 'improved', 'construction', 'evaluation', 'new', 'technique', 'paper', 'us', 'several', 'existing', 'app', 'optimization', 'technique', 'illustrate', 'motivation', 'behind', 'maomao', 'potential', 'landscape', 'area']"
"Event Model Algorithm with Microservice Architecture Implementation The Event-driven architectures (EDA) are gaining popularity for a reason. Scalability in building isolated microservices is a paradigm that many businesses are constantly striving for, and event-driven architecture is built with that in mind. With innovative tools such as Kafka and RabbitMQ, event-driven architectures are becoming more flexible, versatile, and robust to satisfy a wide range of business needs. However, powerful tool also comes at a price: a high learning curve and rather complicated initial setup. However, once such a structure is in place, the benefits are clear as data is transmitted with lower latency and higher throughput. So why not use an event-driven architecture? In the work, an algorithm for transition to the use of EDA is proposed for a successful transition to such an architecture.",Event Model Algorithm with Microservice Architecture Implementation,"The Event-driven architectures (EDA) are gaining popularity for a reason. Scalability in building isolated microservices is a paradigm that many businesses are constantly striving for, and event-driven architecture is built with that in mind. With innovative tools such as Kafka and RabbitMQ, event-driven architectures are becoming more flexible, versatile, and robust to satisfy a wide range of business needs. However, powerful tool also comes at a price: a high learning curve and rather complicated initial setup. However, once such a structure is in place, the benefits are clear as data is transmitted with lower latency and higher throughput. So why not use an event-driven architecture? In the work, an algorithm for transition to the use of EDA is proposed for a successful transition to such an architecture.",IEEE conference,no,"['event', 'model', 'algorithm', 'implementation', 'eda', 'gaining', 'popularity', 'reason', 'scalability', 'building', 'isolated', 'paradigm', 'many', 'business', 'constantly', 'built', 'mind', 'innovative', 'tool', 'kafka', 'rabbitmq', 'becoming', 'flexible', 'versatile', 'robust', 'satisfy', 'wide', 'range', 'business', 'need', 'however', 'powerful', 'tool', 'also', 'come', 'price', 'high', 'learning', 'rather', 'complicated', 'initial', 'setup', 'however', 'structure', 'place', 'benefit', 'clear', 'lower', 'latency', 'higher', 'throughput', 'use', 'work', 'algorithm', 'transition', 'use', 'eda', 'proposed', 'successful', 'transition']"
"A Comparative Analysis of Communication Efficiency: REST vs. gRPC in Microservice- Based Ecosystems This study investigates the practical aspects of evaluating the efficiency and performance of Representational State Transfer (REST) and gRPC communication protocols in microservice-based systems. Microservices revolutionize software architecture by enabling scalable applications through independently deployable services. However, effective communication between these services is crucial for maintaining system responsiveness and reliability. The paper takes a hands-on approach, drawing insights from real-world implementations and experiments. It offers a pragmatic overview of microservices architecture, highlighting the pivotal role of communication protocols in facilitating seamless interactions among distributed components. Furthermore, the study delves into the technical intricacies of REST and gRPC, exploring aspects such as message formats, serialization mechanisms, and transport protocols. Through empirical analysis, the paper evaluates the latency performance of REST and gRPC across various communication tasks under different workloads and network conditions. These insights provide practical guidance for developers and architects in selecting the most suitable communication protocol based on specific project requirements and performance constraints, ultimately enhancing microservice communication efficiency and reliability.",A Comparative Analysis of Communication Efficiency: REST vs. gRPC in Microservice- Based Ecosystems,"This study investigates the practical aspects of evaluating the efficiency and performance of Representational State Transfer (REST) and gRPC communication protocols in microservice-based systems. Microservices revolutionize software architecture by enabling scalable applications through independently deployable services. However, effective communication between these services is crucial for maintaining system responsiveness and reliability. The paper takes a hands-on approach, drawing insights from real-world implementations and experiments. It offers a pragmatic overview of microservices architecture, highlighting the pivotal role of communication protocols in facilitating seamless interactions among distributed components. Furthermore, the study delves into the technical intricacies of REST and gRPC, exploring aspects such as message formats, serialization mechanisms, and transport protocols. Through empirical analysis, the paper evaluates the latency performance of REST and gRPC across various communication tasks under different workloads and network conditions. These insights provide practical guidance for developers and architects in selecting the most suitable communication protocol based on specific project requirements and performance constraints, ultimately enhancing microservice communication efficiency and reliability.",IEEE conference,no,"['comparative', 'analysis', 'communication', 'efficiency', 'rest', 'grpc', 'based', 'ecosystem', 'study', 'investigates', 'practical', 'aspect', 'evaluating', 'efficiency', 'performance', 'state', 'transfer', 'rest', 'grpc', 'communication', 'protocol', 'enabling', 'scalable', 'independently', 'deployable', 'however', 'effective', 'communication', 'crucial', 'maintaining', 'reliability', 'paper', 'take', 'insight', 'implementation', 'experiment', 'offer', 'pragmatic', 'overview', 'highlighting', 'pivotal', 'role', 'communication', 'protocol', 'facilitating', 'seamless', 'interaction', 'among', 'distributed', 'furthermore', 'study', 'delf', 'technical', 'intricacy', 'rest', 'grpc', 'exploring', 'aspect', 'message', 'format', 'serialization', 'mechanism', 'transport', 'protocol', 'empirical', 'analysis', 'paper', 'latency', 'performance', 'rest', 'grpc', 'across', 'various', 'communication', 'task', 'different', 'workload', 'network', 'condition', 'insight', 'provide', 'practical', 'guidance', 'developer', 'architect', 'selecting', 'suitable', 'communication', 'protocol', 'based', 'specific', 'project', 'requirement', 'performance', 'constraint', 'enhancing', 'communication', 'efficiency', 'reliability']"
"Case for Microservices Orchestration Using Workflow Engines Microservices have become the de-facto software architecture for cloud-native applications. A contentious architectural decision in microservices is to compose them using choreography or orchestration. In choreography, every service works independently, whereas, in orchestration, there is a controller that coordinates service interactions. This paper makes a case for orchestration. The promise of microservices is that each microservice can be independently developed, deployed, tested, upgraded, and scaled. This makes them suitable for systems running on cloud infrastructures. However, microservice-based systems become complicated due to the complex interactions of various services, concurrent events, failing components, developers’ lack of global view, and configurations of the environment. This makes maintaining and debugging such systems very challenging. We hypothesize that orchestrated services are easier to debug and to test this we ported the largest publicly available microservices’ benchmark TrainTicket [24], which is implemented using choreography, to a fault-oblivious stateful workflow framework Temporal [19]. We report our experience in porting the code from traditional choreographed microservice architecture to one orchestrated by Temporal and present our initial findings of time to debug the 22 bugs present in the benchmark. Our findings suggest that an effort towards making a transition to orchestrated approach is worthwhile, making the ported code easier to debug.",Case for Microservices Orchestration Using Workflow Engines,"Microservices have become the de-facto software architecture for cloud-native applications. A contentious architectural decision in microservices is to compose them using choreography or orchestration. In choreography, every service works independently, whereas, in orchestration, there is a controller that coordinates service interactions. This paper makes a case for orchestration. The promise of microservices is that each microservice can be independently developed, deployed, tested, upgraded, and scaled. This makes them suitable for systems running on cloud infrastructures. However, microservice-based systems become complicated due to the complex interactions of various services, concurrent events, failing components, developers’ lack of global view, and configurations of the environment. This makes maintaining and debugging such systems very challenging. We hypothesize that orchestrated services are easier to debug and to test this we ported the largest publicly available microservices’ benchmark TrainTicket [24], which is implemented using choreography, to a fault-oblivious stateful workflow framework Temporal [19]. We report our experience in porting the code from traditional choreographed microservice architecture to one orchestrated by Temporal and present our initial findings of time to debug the 22 bugs present in the benchmark. Our findings suggest that an effort towards making a transition to orchestrated approach is worthwhile, making the ported code easier to debug.",IEEE conference,no,"['case', 'orchestration', 'using', 'workflow', 'engine', 'become', 'architectural', 'decision', 'compose', 'using', 'choreography', 'orchestration', 'choreography', 'every', 'work', 'independently', 'whereas', 'orchestration', 'controller', 'coordinate', 'interaction', 'paper', 'make', 'case', 'orchestration', 'promise', 'independently', 'developed', 'deployed', 'tested', 'upgraded', 'scaled', 'make', 'suitable', 'running', 'infrastructure', 'however', 'become', 'complicated', 'due', 'complex', 'interaction', 'various', 'concurrent', 'event', 'developer', 'lack', 'global', 'view', 'configuration', 'environment', 'make', 'maintaining', 'debugging', 'challenging', 'orchestrated', 'easier', 'debug', 'test', 'largest', 'publicly', 'available', 'benchmark', 'implemented', 'using', 'choreography', 'stateful', 'workflow', 'framework', 'temporal', 'report', 'experience', 'code', 'traditional', 'one', 'orchestrated', 'temporal', 'present', 'initial', 'finding', 'time', 'debug', 'bug', 'present', 'benchmark', 'finding', 'suggest', 'effort', 'towards', 'making', 'transition', 'orchestrated', 'making', 'code', 'easier', 'debug']"
"Object-Aware Identification of Microservices Microservices is an architectural style inspired by service-oriented computing that structures an application as a collection of cohesive and loosely coupled components, which implement business capabilities. One of today's problems in designing microservice architectures is to decompose a system into cohesive, loosely coupled, and fine-grained microservices. Identification of microservices is usually performed intuitively, based on the experience of the system designers, however, if the functionalities of a system are highly interconnected, it is a challenging task to decompose the system into appropriate microservices. To tackle this challenge, we present a microservice identification method that decomposes a system using clustering technique. To this end, we model a system as a set of business processes and take two aspects of structural dependency and data object dependency of functionalities into account. Furthermore, we conduct a study to evaluate the effect of process characteristics on the accuracy of identification approaches.",Object-Aware Identification of Microservices,"Microservices is an architectural style inspired by service-oriented computing that structures an application as a collection of cohesive and loosely coupled components, which implement business capabilities. One of today's problems in designing microservice architectures is to decompose a system into cohesive, loosely coupled, and fine-grained microservices. Identification of microservices is usually performed intuitively, based on the experience of the system designers, however, if the functionalities of a system are highly interconnected, it is a challenging task to decompose the system into appropriate microservices. To tackle this challenge, we present a microservice identification method that decomposes a system using clustering technique. To this end, we model a system as a set of business processes and take two aspects of structural dependency and data object dependency of functionalities into account. Furthermore, we conduct a study to evaluate the effect of process characteristics on the accuracy of identification approaches.",IEEE conference,no,"['identification', 'architectural', 'style', 'inspired', 'computing', 'structure', 'collection', 'cohesive', 'loosely', 'coupled', 'implement', 'business', 'capability', 'one', 'today', 'problem', 'designing', 'decompose', 'cohesive', 'loosely', 'coupled', 'identification', 'usually', 'performed', 'based', 'experience', 'designer', 'however', 'functionality', 'highly', 'interconnected', 'challenging', 'task', 'decompose', 'appropriate', 'tackle', 'challenge', 'present', 'identification', 'method', 'decomposes', 'using', 'clustering', 'technique', 'end', 'model', 'set', 'business', 'process', 'take', 'two', 'aspect', 'structural', 'dependency', 'object', 'dependency', 'functionality', 'account', 'furthermore', 'conduct', 'study', 'evaluate', 'effect', 'process', 'characteristic', 'accuracy', 'identification']"
"Evaluating Cloud Microservices with DIRECTOR Software ecosystems are now emerging in the cloud, allowing actors to contribute, but also commercialize their own solutions, by reusing software assets provided through the platforms - popularly in the shape of microservices. With so many alternatives, an open challenge for software architects is to find the most adequate asset given a set of requirements and priorities. In this context, we propose DIRECTOR: A cloud microservice selection framework based on technical, social and semantical perspectives, i.e., objective analysis, reputation and artificial intelligence, respectively. Results indicate that it can support software acquisition via discovery, evaluation and comparison of microservices, being able to recommend the fittest among hundreds of candidates in multiple cloud platforms.",Evaluating Cloud Microservices with DIRECTOR,"Software ecosystems are now emerging in the cloud, allowing actors to contribute, but also commercialize their own solutions, by reusing software assets provided through the platforms - popularly in the shape of microservices. With so many alternatives, an open challenge for software architects is to find the most adequate asset given a set of requirements and priorities. In this context, we propose DIRECTOR: A cloud microservice selection framework based on technical, social and semantical perspectives, i.e., objective analysis, reputation and artificial intelligence, respectively. Results indicate that it can support software acquisition via discovery, evaluation and comparison of microservices, being able to recommend the fittest among hundreds of candidates in multiple cloud platforms.",IEEE conference,no,"['evaluating', 'director', 'ecosystem', 'emerging', 'allowing', 'contribute', 'also', 'solution', 'reusing', 'asset', 'provided', 'platform', 'shape', 'many', 'alternative', 'open', 'challenge', 'architect', 'find', 'adequate', 'asset', 'given', 'set', 'requirement', 'priority', 'context', 'propose', 'director', 'selection', 'framework', 'based', 'technical', 'social', 'perspective', 'objective', 'analysis', 'artificial', 'intelligence', 'respectively', 'result', 'indicate', 'support', 'acquisition', 'via', 'discovery', 'evaluation', 'comparison', 'able', 'recommend', 'among', 'hundred', 'candidate', 'multiple', 'platform']"
"Key Lessons from Microservices for Data Mesh Adoption Data Mesh constitutes an architectural blueprint tailored to facilitate the execution of enterprise data platforms within expansive and intricate organizations. Its design aims to propel the broad adoption of analytics beyond a single platform and solitary implementation team. This research delves into the convergence of Microservices and Data Mesh structures, pinpointing vital learnings from Microservices that can inform and ease the transition to Data Mesh architecture. Several critical components like Domain-Driven Design, data consistency, team autonomy, technology selection, and scalability are included in this investigation, each with significant implications for the successful implementation of a Data Mesh.",Key Lessons from Microservices for Data Mesh Adoption,"Data Mesh constitutes an architectural blueprint tailored to facilitate the execution of enterprise data platforms within expansive and intricate organizations. Its design aims to propel the broad adoption of analytics beyond a single platform and solitary implementation team. This research delves into the convergence of Microservices and Data Mesh structures, pinpointing vital learnings from Microservices that can inform and ease the transition to Data Mesh architecture. Several critical components like Domain-Driven Design, data consistency, team autonomy, technology selection, and scalability are included in this investigation, each with significant implications for the successful implementation of a Data Mesh.",IEEE conference,no,"['key', 'lesson', 'mesh', 'adoption', 'mesh', 'architectural', 'blueprint', 'tailored', 'facilitate', 'execution', 'enterprise', 'platform', 'within', 'intricate', 'organization', 'design', 'aim', 'broad', 'adoption', 'analytics', 'beyond', 'single', 'platform', 'implementation', 'team', 'research', 'delf', 'mesh', 'structure', 'pinpointing', 'vital', 'learning', 'inform', 'ease', 'transition', 'mesh', 'several', 'critical', 'like', 'design', 'consistency', 'team', 'autonomy', 'technology', 'selection', 'scalability', 'included', 'investigation', 'significant', 'implication', 'successful', 'implementation', 'mesh']"
"An Exploratory Case Study: Using Petri Nets for Modelling Microservice-based Systems The rapid evolution of cloud technology has led to the development of highly responsive and flexible applications. Microservice-based Architecture (MSbA) is a popular approach for creating cloud-compatible applications. However, MSbA presents challenges in system verification and analysis. This paper explores using Petri nets for modelling microservice-based systems. The proposed method utilises abstraction and composition techniques to model complex systems using 1-safe Petri nets. A case study on Banking as a Service (BaaS) demonstrates the suitability of Petri nets for modelling, analysis and verification of microservice-based systems.",An Exploratory Case Study: Using Petri Nets for Modelling Microservice-based Systems,"The rapid evolution of cloud technology has led to the development of highly responsive and flexible applications. Microservice-based Architecture (MSbA) is a popular approach for creating cloud-compatible applications. However, MSbA presents challenges in system verification and analysis. This paper explores using Petri nets for modelling microservice-based systems. The proposed method utilises abstraction and composition techniques to model complex systems using 1-safe Petri nets. A case study on Banking as a Service (BaaS) demonstrates the suitability of Petri nets for modelling, analysis and verification of microservice-based systems.",IEEE conference,no,"['exploratory', 'case', 'study', 'using', 'petri', 'net', 'modelling', 'rapid', 'evolution', 'technology', 'led', 'development', 'highly', 'responsive', 'flexible', 'popular', 'creating', 'however', 'present', 'challenge', 'verification', 'analysis', 'paper', 'explores', 'using', 'petri', 'net', 'modelling', 'proposed', 'method', 'abstraction', 'composition', 'technique', 'model', 'complex', 'using', 'petri', 'net', 'case', 'study', 'banking', 'demonstrates', 'petri', 'net', 'modelling', 'analysis', 'verification']"
"A Digital Enterprise Architecture based on Cloud-Based Services and Digital Signatures Digital Enterprise (DE) is defined as an organization that uses digital technologies in its operations to gain a competitive advantage. Starting from reshaping infrastructure and operations using information technology, businesses have evolved into a digital transformation, including, and adopting digital solutions throughout the organization. The paper presents two particular DE component services: Document Management (DMS) and Electronic Archiving (EA). These services are offered by reusing some functionalities provided by the microservices that compose the middleware developed within the project. Also, the services offered by CBS (Cloud-Based Signature) and OCC (Online Content Certification) products, resulting from the performance of previous project activities, are also integrated within the DE. The design and implementation of the DMS, respectively EA components started from the SDK (Software Development Kit) developed in the DE's middleware. It contains a set of auxiliary subcomponents that define the data structure (models’ area) and common behavior (services area).",A Digital Enterprise Architecture based on Cloud-Based Services and Digital Signatures,"Digital Enterprise (DE) is defined as an organization that uses digital technologies in its operations to gain a competitive advantage. Starting from reshaping infrastructure and operations using information technology, businesses have evolved into a digital transformation, including, and adopting digital solutions throughout the organization. The paper presents two particular DE component services: Document Management (DMS) and Electronic Archiving (EA). These services are offered by reusing some functionalities provided by the microservices that compose the middleware developed within the project. Also, the services offered by CBS (Cloud-Based Signature) and OCC (Online Content Certification) products, resulting from the performance of previous project activities, are also integrated within the DE. The design and implementation of the DMS, respectively EA components started from the SDK (Software Development Kit) developed in the DE's middleware. It contains a set of auxiliary subcomponents that define the data structure (models’ area) and common behavior (services area).",IEEE conference,no,"['digital', 'enterprise', 'based', 'digital', 'digital', 'enterprise', 'de', 'defined', 'organization', 'us', 'digital', 'technology', 'operation', 'gain', 'competitive', 'advantage', 'starting', 'reshaping', 'infrastructure', 'operation', 'using', 'information', 'technology', 'business', 'evolved', 'digital', 'transformation', 'including', 'adopting', 'digital', 'solution', 'throughout', 'organization', 'paper', 'present', 'two', 'particular', 'de', 'document', 'management', 'electronic', 'ea', 'offered', 'reusing', 'functionality', 'provided', 'compose', 'middleware', 'developed', 'within', 'project', 'also', 'offered', 'online', 'content', 'certification', 'product', 'resulting', 'performance', 'previous', 'project', 'activity', 'also', 'integrated', 'within', 'de', 'design', 'implementation', 'respectively', 'ea', 'started', 'development', 'kit', 'developed', 'de', 'middleware', 'contains', 'set', 'define', 'structure', 'model', 'area', 'common', 'behavior', 'area']"
"We Need to Talk About Microservices: an Analysis from the Discussions on StackOverflow Microservices are a new and rapidly growing architectural model aimed at developing highly scalable software solutions based on independently deployable and evolvable components. Due to its novelty, microservice-related discussions are increasing in Q&A websites, such as StackOverflow (SO). In order to understand what is being discussed by the microservice community, this work has applied mining techniques and topic modelling to a manually-curated dataset of 1,043 microservice-related posts from StackOverflow. As a result, we found that 13.68% of microservice technical posts on SO discuss a single technology: Netflix Eureka. Moreover, buzzwords in the microservice ecosystem, e.g., blue/green deployment, were not identified as relevant subjects of discussion on SO. Finally, we show how a high discussion rate on SO may not reflect the popularity of a certain subject within the microservice community.",We Need to Talk About Microservices: an Analysis from the Discussions on StackOverflow,"Microservices are a new and rapidly growing architectural model aimed at developing highly scalable software solutions based on independently deployable and evolvable components. Due to its novelty, microservice-related discussions are increasing in Q&A websites, such as StackOverflow (SO). In order to understand what is being discussed by the microservice community, this work has applied mining techniques and topic modelling to a manually-curated dataset of 1,043 microservice-related posts from StackOverflow. As a result, we found that 13.68% of microservice technical posts on SO discuss a single technology: Netflix Eureka. Moreover, buzzwords in the microservice ecosystem, e.g., blue/green deployment, were not identified as relevant subjects of discussion on SO. Finally, we show how a high discussion rate on SO may not reflect the popularity of a certain subject within the microservice community.",IEEE conference,no,"['need', 'talk', 'analysis', 'discussion', 'stackoverflow', 'new', 'rapidly', 'growing', 'architectural', 'model', 'aimed', 'developing', 'highly', 'scalable', 'solution', 'based', 'independently', 'deployable', 'due', 'discussion', 'increasing', 'website', 'stackoverflow', 'order', 'understand', 'discussed', 'community', 'work', 'applied', 'mining', 'technique', 'topic', 'modelling', 'dataset', 'post', 'stackoverflow', 'result', 'found', 'technical', 'post', 'discus', 'single', 'technology', 'netflix', 'moreover', 'ecosystem', 'deployment', 'identified', 'relevant', 'subject', 'discussion', 'finally', 'show', 'high', 'discussion', 'rate', 'may', 'popularity', 'certain', 'subject', 'within', 'community']"
"Reactive Microservices in Commodity Resources A microservice is a cohesive, independent process that communicates via messages. Reactive microservices consist of isolated components in an event stream that can react independently or in concert with other microservices to arrive at the final states of the event. n this paper, we present a microservice architecture which is based on event streams and has a decentralized framework for microservice coordination. The architecture allows microservices to enrich content in an event stream without any time or mobility constraints. Final states are construed as acceptable and incrementally stackable for event updates that occur at different time slots. The event coordinator platform establishes the coordination within a microservice using the event registry. We present how we horizontally scaled the platform with multiple parallelism strategies and show the platform performance results.",Reactive Microservices in Commodity Resources,"A microservice is a cohesive, independent process that communicates via messages. Reactive microservices consist of isolated components in an event stream that can react independently or in concert with other microservices to arrive at the final states of the event. n this paper, we present a microservice architecture which is based on event streams and has a decentralized framework for microservice coordination. The architecture allows microservices to enrich content in an event stream without any time or mobility constraints. Final states are construed as acceptable and incrementally stackable for event updates that occur at different time slots. The event coordinator platform establishes the coordination within a microservice using the event registry. We present how we horizontally scaled the platform with multiple parallelism strategies and show the platform performance results.",IEEE conference,no,"['reactive', 'commodity', 'resource', 'cohesive', 'independent', 'process', 'via', 'message', 'reactive', 'consist', 'isolated', 'event', 'stream', 'react', 'independently', 'final', 'state', 'event', 'paper', 'present', 'based', 'event', 'stream', 'decentralized', 'framework', 'coordination', 'allows', 'content', 'event', 'stream', 'without', 'time', 'mobility', 'constraint', 'final', 'state', 'event', 'update', 'occur', 'different', 'time', 'event', 'platform', 'coordination', 'within', 'using', 'event', 'registry', 'present', 'scaled', 'platform', 'multiple', 'parallelism', 'strategy', 'show', 'platform', 'performance', 'result']"
"Automatic Dependency Tracking in Microservice-based Systems Using Static Analysis in Helm Charts In this paper, we aim to show the power of static analysis when it comes to understanding the relationships between microservice components of a software. We have developed an algorithm that models the conventional rules in Helm that describe the dependencies between microservices to discover the architectural design of microservice-based systems. We implemented the algorithm as a new plugin in CodeCompass (open source code comprehension tool: https://github.com/Ericsson/CodeCompass) that parses YAML files, automatically identifies microservices and dependencies between them, and graphically visualizes the microservice architecture of the software. We present the challenges and strength of the static analysis approach and we demonstrate how the solution helps software architects via an example.",Automatic Dependency Tracking in Microservice-based Systems Using Static Analysis in Helm Charts,"In this paper, we aim to show the power of static analysis when it comes to understanding the relationships between microservice components of a software. We have developed an algorithm that models the conventional rules in Helm that describe the dependencies between microservices to discover the architectural design of microservice-based systems. We implemented the algorithm as a new plugin in CodeCompass (open source code comprehension tool: https://github.com/Ericsson/CodeCompass) that parses YAML files, automatically identifies microservices and dependencies between them, and graphically visualizes the microservice architecture of the software. We present the challenges and strength of the static analysis approach and we demonstrate how the solution helps software architects via an example.",IEEE conference,no,"['automatic', 'dependency', 'tracking', 'using', 'static', 'analysis', 'paper', 'aim', 'show', 'power', 'static', 'analysis', 'come', 'understanding', 'relationship', 'developed', 'algorithm', 'model', 'conventional', 'rule', 'describe', 'dependency', 'discover', 'architectural', 'design', 'implemented', 'algorithm', 'new', 'open', 'source', 'code', 'comprehension', 'tool', 'file', 'automatically', 'identifies', 'dependency', 'present', 'challenge', 'strength', 'static', 'analysis', 'demonstrate', 'solution', 'help', 'architect', 'via', 'example']"
"Extraction of Microservices from Monolithic Software Architectures Driven by developments such as mobile computing, cloud computing infrastructure, DevOps and elastic computing, the microservice architectural style has emerged as a new alternative to the monolithic style for designing large software systems. Monolithic legacy applications in industry undergo a migration to microservice-oriented architectures. A key challenge in this context is the extraction of microservices from existing monolithic code bases. While informal migration patterns and techniques exist, there is a lack of formal models and automated support tools in that area. This paper tackles that challenge by presenting a formal microservice extraction model to allow algorithmic recommendation of microservice candidates in a refactoring and migration scenario. The formal model is implemented in a web-based prototype. A performance evaluation demonstrates that the presented approach provides adequate performance. The recommendation quality is evaluated quantitatively by custom microservice-specific metrics. The results show that the produced microservice candidates lower the average development team size down to half of the original size or lower. Furthermore, the size of recommended microservice conforms with microservice sizing reported by empirical surveys and the domain-specific redundancy among different microservices is kept at a low rate.",Extraction of Microservices from Monolithic Software Architectures,"Driven by developments such as mobile computing, cloud computing infrastructure, DevOps and elastic computing, the microservice architectural style has emerged as a new alternative to the monolithic style for designing large software systems. Monolithic legacy applications in industry undergo a migration to microservice-oriented architectures. A key challenge in this context is the extraction of microservices from existing monolithic code bases. While informal migration patterns and techniques exist, there is a lack of formal models and automated support tools in that area. This paper tackles that challenge by presenting a formal microservice extraction model to allow algorithmic recommendation of microservice candidates in a refactoring and migration scenario. The formal model is implemented in a web-based prototype. A performance evaluation demonstrates that the presented approach provides adequate performance. The recommendation quality is evaluated quantitatively by custom microservice-specific metrics. The results show that the produced microservice candidates lower the average development team size down to half of the original size or lower. Furthermore, the size of recommended microservice conforms with microservice sizing reported by empirical surveys and the domain-specific redundancy among different microservices is kept at a low rate.",IEEE conference,no,"['extraction', 'monolithic', 'driven', 'development', 'mobile', 'computing', 'computing', 'infrastructure', 'devops', 'elastic', 'computing', 'architectural', 'style', 'emerged', 'new', 'alternative', 'monolithic', 'style', 'designing', 'large', 'monolithic', 'legacy', 'industry', 'migration', 'key', 'challenge', 'context', 'extraction', 'existing', 'monolithic', 'code', 'base', 'migration', 'pattern', 'technique', 'exist', 'lack', 'formal', 'model', 'automated', 'support', 'tool', 'area', 'paper', 'tackle', 'challenge', 'presenting', 'formal', 'extraction', 'model', 'allow', 'recommendation', 'candidate', 'refactoring', 'migration', 'scenario', 'formal', 'model', 'implemented', 'prototype', 'performance', 'evaluation', 'demonstrates', 'presented', 'provides', 'adequate', 'performance', 'recommendation', 'quality', 'evaluated', 'quantitatively', 'custom', 'metric', 'result', 'show', 'produced', 'candidate', 'lower', 'average', 'development', 'team', 'size', 'original', 'size', 'lower', 'furthermore', 'size', 'reported', 'empirical', 'survey', 'redundancy', 'among', 'different', 'kept', 'low', 'rate']"
"Is it Worth Migrating a Monolith to Microservices? An Experience Report on Performance, Availability and Energy Usage The microservice architecture (MSA) emerged as an evolution of existing architectural styles with the promise of improving software quality by decomposing an app into modules that can be maintained, deployed, and scaled independently. However, the transition from a monolithic to a microservice architecture is fraught with difficulties, especially when it comes to assessing qualitative aspects, as controversial results can arise. In this paper, we present an experience report on the migration of a monolithic web application and use performance, availability and energy efficiency as quality attributes to shed light on such an architectural transition. Horizontal scaling, i.e., distributing the workload across several service instances, is applied and we study its impact.Our main findings are: i) when no app component is replicated, MSA outperforms the monolithic architecture; ii) the monolithic architecture shows performance and availability improvement when replicating the entire app; iii) the replicated MSA version reaches a ceiling when not replicating its routing part (i.e., the API gateway), showing worse response times compared to the replicated monolith; iv) when replicating the API gateway, the MSA version reaches optimal performance with fewer replicates than the monolith; v) when not replicating services, MSA consumes more CPU resources than the monolithic architecture; vi) when scaling up, the MSA version is more efficient than the replicated monolith in terms of memory usage, and it can better exploit CPU resources; vii) when not replicating services, MSA consumes more energy than the monolithic architecture, whereas when scaling up, the MSA version is more efficient than the replicated monolith; MSA version reaches a good balance between CPU and memory usage.","Is it Worth Migrating a Monolith to Microservices? An Experience Report on Performance, Availability and Energy Usage","The microservice architecture (MSA) emerged as an evolution of existing architectural styles with the promise of improving software quality by decomposing an app into modules that can be maintained, deployed, and scaled independently. However, the transition from a monolithic to a microservice architecture is fraught with difficulties, especially when it comes to assessing qualitative aspects, as controversial results can arise. In this paper, we present an experience report on the migration of a monolithic web application and use performance, availability and energy efficiency as quality attributes to shed light on such an architectural transition. Horizontal scaling, i.e., distributing the workload across several service instances, is applied and we study its impact.Our main findings are: i) when no app component is replicated, MSA outperforms the monolithic architecture; ii) the monolithic architecture shows performance and availability improvement when replicating the entire app; iii) the replicated MSA version reaches a ceiling when not replicating its routing part (i.e., the API gateway), showing worse response times compared to the replicated monolith; iv) when replicating the API gateway, the MSA version reaches optimal performance with fewer replicates than the monolith; v) when not replicating services, MSA consumes more CPU resources than the monolithic architecture; vi) when scaling up, the MSA version is more efficient than the replicated monolith in terms of memory usage, and it can better exploit CPU resources; vii) when not replicating services, MSA consumes more energy than the monolithic architecture, whereas when scaling up, the MSA version is more efficient than the replicated monolith; MSA version reaches a good balance between CPU and memory usage.",IEEE conference,no,"['migrating', 'monolith', 'experience', 'report', 'performance', 'availability', 'energy', 'usage', 'msa', 'emerged', 'evolution', 'existing', 'architectural', 'style', 'promise', 'improving', 'quality', 'decomposing', 'app', 'module', 'deployed', 'scaled', 'independently', 'however', 'transition', 'monolithic', 'difficulty', 'especially', 'come', 'assessing', 'qualitative', 'aspect', 'result', 'arise', 'paper', 'present', 'experience', 'report', 'migration', 'monolithic', 'web', 'use', 'performance', 'availability', 'energy', 'efficiency', 'quality', 'attribute', 'light', 'architectural', 'transition', 'horizontal', 'scaling', 'distributing', 'workload', 'across', 'several', 'instance', 'applied', 'study', 'main', 'finding', 'app', 'replicated', 'msa', 'outperforms', 'monolithic', 'ii', 'monolithic', 'show', 'performance', 'availability', 'improvement', 'replicating', 'entire', 'app', 'iii', 'replicated', 'msa', 'version', 'reach', 'replicating', 'routing', 'part', 'api', 'gateway', 'showing', 'response', 'time', 'compared', 'replicated', 'monolith', 'replicating', 'api', 'gateway', 'msa', 'version', 'reach', 'optimal', 'performance', 'fewer', 'monolith', 'v', 'replicating', 'msa', 'consumes', 'cpu', 'resource', 'monolithic', 'scaling', 'msa', 'version', 'efficient', 'replicated', 'monolith', 'term', 'memory', 'usage', 'better', 'exploit', 'cpu', 'resource', 'replicating', 'msa', 'consumes', 'energy', 'monolithic', 'whereas', 'scaling', 'msa', 'version', 'efficient', 'replicated', 'monolith', 'msa', 'version', 'reach', 'good', 'balance', 'cpu', 'memory', 'usage']"
"Magnet: Method-Based Approach Using Graph Neural Network for Microservices Identification Monolithic software systems face significant challenges in terms of maintenance, scalability, and portability. To address these challenges, many companies are embracing the microservices architectural style as a more flexible alternative to their monoliths. Microservices structure systems into modular, independent components, enabling easier development, deployment, and maintenance. However, the migration from a monolith to microservices is challenging due to the laborious task of manually identifying and decomposing a system into microservices. Several earlier studies focused on developing approaches to facilitate the migration process. However, the reliance on domain experts to define various parameters and thresholds restricted their use. In this paper, we introduce Magnet, a fully automated microservice identification approach, based on graph neural networks (GNNs). Magnet integrates a GNN model with a fine-grained method-based graph enriched with semantic and static features of the system. It enables accurate microservices identification while simultaneously promoting microservice cohesion and reducing microservice coupling. To validate the accuracy of Magnet, we performed extensive experiments using a set of open-source systems. Quantitatively, we use a set of quality metrics to assess the resulting microservices quality. We also compare our results to established ground truths. Empirical evidence suggests that our fully-automated approach Magnet achieves precision and recall rates of 56% and 68%. Qualitatively, we assess the modularity and functional independence of the resulting microservices by examining their relationships and semantic integrity. This evaluation demonstrates that our fully automated approach yields promising results, underlining its effectiveness in creating modular and coherent microservices.",Magnet: Method-Based Approach Using Graph Neural Network for Microservices Identification,"Monolithic software systems face significant challenges in terms of maintenance, scalability, and portability. To address these challenges, many companies are embracing the microservices architectural style as a more flexible alternative to their monoliths. Microservices structure systems into modular, independent components, enabling easier development, deployment, and maintenance. However, the migration from a monolith to microservices is challenging due to the laborious task of manually identifying and decomposing a system into microservices. Several earlier studies focused on developing approaches to facilitate the migration process. However, the reliance on domain experts to define various parameters and thresholds restricted their use. In this paper, we introduce Magnet, a fully automated microservice identification approach, based on graph neural networks (GNNs). Magnet integrates a GNN model with a fine-grained method-based graph enriched with semantic and static features of the system. It enables accurate microservices identification while simultaneously promoting microservice cohesion and reducing microservice coupling. To validate the accuracy of Magnet, we performed extensive experiments using a set of open-source systems. Quantitatively, we use a set of quality metrics to assess the resulting microservices quality. We also compare our results to established ground truths. Empirical evidence suggests that our fully-automated approach Magnet achieves precision and recall rates of 56% and 68%. Qualitatively, we assess the modularity and functional independence of the resulting microservices by examining their relationships and semantic integrity. This evaluation demonstrates that our fully automated approach yields promising results, underlining its effectiveness in creating modular and coherent microservices.",IEEE conference,no,"['magnet', 'using', 'graph', 'neural', 'network', 'identification', 'monolithic', 'face', 'significant', 'challenge', 'term', 'maintenance', 'scalability', 'portability', 'address', 'challenge', 'many', 'company', 'architectural', 'style', 'flexible', 'alternative', 'monolith', 'structure', 'modular', 'independent', 'enabling', 'easier', 'development', 'deployment', 'maintenance', 'however', 'migration', 'monolith', 'challenging', 'due', 'task', 'manually', 'identifying', 'decomposing', 'several', 'earlier', 'study', 'focused', 'developing', 'facilitate', 'migration', 'process', 'however', 'domain', 'expert', 'define', 'various', 'parameter', 'threshold', 'use', 'paper', 'introduce', 'magnet', 'fully', 'automated', 'identification', 'based', 'graph', 'neural', 'network', 'magnet', 'integrates', 'gnn', 'model', 'graph', 'semantic', 'static', 'feature', 'enables', 'accurate', 'identification', 'simultaneously', 'promoting', 'cohesion', 'reducing', 'coupling', 'validate', 'accuracy', 'magnet', 'performed', 'extensive', 'experiment', 'using', 'set', 'quantitatively', 'use', 'set', 'quality', 'metric', 'assess', 'resulting', 'quality', 'also', 'compare', 'result', 'established', 'ground', 'truth', 'empirical', 'evidence', 'suggests', 'magnet', 'achieves', 'precision', 'recall', 'rate', 'assess', 'modularity', 'functional', 'independence', 'resulting', 'examining', 'relationship', 'semantic', 'integrity', 'evaluation', 'demonstrates', 'fully', 'automated', 'yield', 'promising', 'result', 'effectiveness', 'creating', 'modular']"
"Sharing platform of digital specimen of wood canker based on WebGIS in Xinjiang province: architecture, design and implementation The collection, integration, analysis and sharing of digital specimens of wood canker is an important basic work for conducting relevant scientific research, education and teaching. In this study, for all kinds of users, such as scientific research, education, experts and the public, the architecture of Sharing platform of digital specimen of wood canker in Xinjiang province was designed by microservice architecture, the microservice function tree was constructed by domain-driven design method, the microservice cluster was built by using Spring Cloud technology components, and 8 kinds of microservices were developed based on WebGIS technology. The application results show that the platform is easy to use, provides data sharing and services through visualization and interactivity, and can provide decision-making data resources support for scientific research, education, monitoring, quarantine and prevention of wood canker.","Sharing platform of digital specimen of wood canker based on WebGIS in Xinjiang province: architecture, design and implementation","The collection, integration, analysis and sharing of digital specimens of wood canker is an important basic work for conducting relevant scientific research, education and teaching. In this study, for all kinds of users, such as scientific research, education, experts and the public, the architecture of Sharing platform of digital specimen of wood canker in Xinjiang province was designed by microservice architecture, the microservice function tree was constructed by domain-driven design method, the microservice cluster was built by using Spring Cloud technology components, and 8 kinds of microservices were developed based on WebGIS technology. The application results show that the platform is easy to use, provides data sharing and services through visualization and interactivity, and can provide decision-making data resources support for scientific research, education, monitoring, quarantine and prevention of wood canker.",IEEE conference,no,"['sharing', 'platform', 'digital', 'specimen', 'wood', 'canker', 'based', 'design', 'implementation', 'collection', 'integration', 'analysis', 'sharing', 'digital', 'specimen', 'wood', 'canker', 'important', 'basic', 'work', 'conducting', 'relevant', 'scientific', 'research', 'education', 'teaching', 'study', 'kind', 'user', 'scientific', 'research', 'education', 'expert', 'public', 'sharing', 'platform', 'digital', 'specimen', 'wood', 'canker', 'designed', 'function', 'tree', 'constructed', 'design', 'method', 'cluster', 'built', 'using', 'spring', 'technology', 'kind', 'developed', 'based', 'technology', 'result', 'show', 'platform', 'easy', 'use', 'provides', 'sharing', 'visualization', 'provide', 'resource', 'support', 'scientific', 'research', 'education', 'monitoring', 'prevention', 'wood', 'canker']"
"Enhancing microservices architectures using data-driven service discovery and QoS guarantees Microservices promise the benefits of services with an efficient granularity using dynamically allocated resources. In the current evolving architectures, data producers and consumers are created as decoupled components that support different data objects and quality of service. Actual implementations of service meshes lack support for data-driven paradigms, and focus on goal-based approaches designed to fulfill the general system goal. This diversity of available components demands the integration of users requirements and data products into the discovery mechanism. This paper proposes a data-driven service discovery framework based on profile matching using data-centric service descriptions. We have designed and evaluated a microservices architecture for providing service meshes with a standalone set of components that manages data profiles and resources allocations over multiple geographical zones. Moreover, we demonstrated an adaptation scheme to provide quality of service guarantees. Evaluation of the implementation on a real life testbed shows effectiveness of this approach with stable and fluctuating request incoming rates.",Enhancing microservices architectures using data-driven service discovery and QoS guarantees,"Microservices promise the benefits of services with an efficient granularity using dynamically allocated resources. In the current evolving architectures, data producers and consumers are created as decoupled components that support different data objects and quality of service. Actual implementations of service meshes lack support for data-driven paradigms, and focus on goal-based approaches designed to fulfill the general system goal. This diversity of available components demands the integration of users requirements and data products into the discovery mechanism. This paper proposes a data-driven service discovery framework based on profile matching using data-centric service descriptions. We have designed and evaluated a microservices architecture for providing service meshes with a standalone set of components that manages data profiles and resources allocations over multiple geographical zones. Moreover, we demonstrated an adaptation scheme to provide quality of service guarantees. Evaluation of the implementation on a real life testbed shows effectiveness of this approach with stable and fluctuating request incoming rates.",IEEE conference,no,"['enhancing', 'using', 'discovery', 'qos', 'guarantee', 'promise', 'benefit', 'efficient', 'granularity', 'using', 'dynamically', 'allocated', 'resource', 'current', 'evolving', 'producer', 'consumer', 'created', 'decoupled', 'support', 'different', 'object', 'quality', 'actual', 'implementation', 'mesh', 'lack', 'support', 'paradigm', 'focus', 'designed', 'fulfill', 'general', 'goal', 'diversity', 'available', 'demand', 'integration', 'user', 'requirement', 'product', 'discovery', 'mechanism', 'paper', 'proposes', 'discovery', 'framework', 'based', 'profile', 'matching', 'using', 'description', 'designed', 'evaluated', 'providing', 'mesh', 'set', 'manages', 'profile', 'resource', 'allocation', 'multiple', 'zone', 'moreover', 'demonstrated', 'adaptation', 'scheme', 'provide', 'quality', 'guarantee', 'evaluation', 'implementation', 'real', 'life', 'testbed', 'show', 'effectiveness', 'stable', 'fluctuating', 'request', 'incoming', 'rate']"
"Automatic Measurement of Microservice Architecture Quality with Cohesion, Coupling, and Complexity Metrics Microservice architecture has gained popularity as a solution to overcome challenges associated with a monolithic architecture, providing benefits such as ease of large-scale development and scalability. However, the quality of microservices is still overlooked, with current measurements primarily focused on the migration phase from monolithic systems. Furthermore, the dynamic nature of microservices causes the quality of its architecture to fluctuate. Therefore, there is a need for an automated process to measure the quality of microservices during development and maintenance. Based on these issues, this paper proposes a tool named MicroQA that automates the measurement of microservice quality that perform static analysis and dynamic analysis on the system based on cohesion, coupling, and complexity metric with CI/CD integration. By comparing the values of each quality aspect, it is possible to determine the improvement or decline in quality during development.","Automatic Measurement of Microservice Architecture Quality with Cohesion, Coupling, and Complexity Metrics","Microservice architecture has gained popularity as a solution to overcome challenges associated with a monolithic architecture, providing benefits such as ease of large-scale development and scalability. However, the quality of microservices is still overlooked, with current measurements primarily focused on the migration phase from monolithic systems. Furthermore, the dynamic nature of microservices causes the quality of its architecture to fluctuate. Therefore, there is a need for an automated process to measure the quality of microservices during development and maintenance. Based on these issues, this paper proposes a tool named MicroQA that automates the measurement of microservice quality that perform static analysis and dynamic analysis on the system based on cohesion, coupling, and complexity metric with CI/CD integration. By comparing the values of each quality aspect, it is possible to determine the improvement or decline in quality during development.",IEEE conference,no,"['automatic', 'measurement', 'quality', 'cohesion', 'coupling', 'complexity', 'metric', 'gained', 'popularity', 'solution', 'overcome', 'challenge', 'associated', 'monolithic', 'providing', 'benefit', 'ease', 'development', 'scalability', 'however', 'quality', 'still', 'current', 'measurement', 'primarily', 'focused', 'migration', 'phase', 'monolithic', 'furthermore', 'dynamic', 'nature', 'cause', 'quality', 'therefore', 'need', 'automated', 'process', 'measure', 'quality', 'development', 'maintenance', 'based', 'issue', 'paper', 'proposes', 'tool', 'named', 'automates', 'measurement', 'quality', 'perform', 'static', 'analysis', 'dynamic', 'analysis', 'based', 'cohesion', 'coupling', 'complexity', 'metric', 'integration', 'comparing', 'value', 'quality', 'aspect', 'possible', 'determine', 'improvement', 'quality', 'development']"
"A Cloud-Based Service for Digitally Certifying Online Content The paper presents a cloud-based prototype service for digitally signing online-available content. This is a functionality that can be incorporated within particular online scenarios in which the processed information needs to be traceable and proved genuine. The solution for the digital certification of (text-type) contents available online (OCC) consists of two elements that complement each other: the Portal which represents a web interface through which users interact with the system and the Portal. API which implements the actual logic ensuring the necessary functionalities. Given the existence of a set of microservices that expose certain basic functionalities, the Portal. API component will use them (by transmitting operation request events and consuming response events through the central communication component – which is a Kafka-based event bus), thus becoming independent of their implementation. With this approach, the established functionalities are decomposed into smaller functionalities, already exposed by microservices in the cloud-based middleware architecture, and so, the Portal. API has the exclusive role of using and integrating them. Next, the most important UML diagrams associated with the Portal. API component will be presented. They contain the logic on which the certification service for content available online is based.",A Cloud-Based Service for Digitally Certifying Online Content,"The paper presents a cloud-based prototype service for digitally signing online-available content. This is a functionality that can be incorporated within particular online scenarios in which the processed information needs to be traceable and proved genuine. The solution for the digital certification of (text-type) contents available online (OCC) consists of two elements that complement each other: the Portal which represents a web interface through which users interact with the system and the Portal. API which implements the actual logic ensuring the necessary functionalities. Given the existence of a set of microservices that expose certain basic functionalities, the Portal. API component will use them (by transmitting operation request events and consuming response events through the central communication component – which is a Kafka-based event bus), thus becoming independent of their implementation. With this approach, the established functionalities are decomposed into smaller functionalities, already exposed by microservices in the cloud-based middleware architecture, and so, the Portal. API has the exclusive role of using and integrating them. Next, the most important UML diagrams associated with the Portal. API component will be presented. They contain the logic on which the certification service for content available online is based.",IEEE conference,no,"['online', 'content', 'paper', 'present', 'prototype', 'content', 'functionality', 'within', 'particular', 'online', 'scenario', 'processed', 'information', 'need', 'proved', 'solution', 'digital', 'certification', 'content', 'available', 'online', 'consists', 'two', 'element', 'complement', 'portal', 'represents', 'web', 'interface', 'user', 'interact', 'portal', 'api', 'implement', 'actual', 'logic', 'ensuring', 'necessary', 'functionality', 'given', 'existence', 'set', 'expose', 'certain', 'basic', 'functionality', 'portal', 'api', 'use', 'operation', 'request', 'event', 'consuming', 'response', 'event', 'central', 'communication', 'event', 'bus', 'thus', 'becoming', 'independent', 'implementation', 'established', 'functionality', 'decomposed', 'smaller', 'functionality', 'already', 'exposed', 'middleware', 'portal', 'api', 'exclusive', 'role', 'using', 'integrating', 'next', 'important', 'uml', 'diagram', 'associated', 'portal', 'api', 'presented', 'contain', 'logic', 'certification', 'content', 'available', 'online', 'based']"
"Synthetic Runtime Monitoring of Microservices Software Architecture This paper describes Pink, a framework for synthetic runtime monitoring of microservices software systems which allows developers to specify the interactions of services using a UML component diagram, the assertions for the global properties of the microservices using OCL specifications, and the steps for interactions using UML sequence diagrams. Pink generates from the component diagram a set of object diagrams, selects them according to the OCL specifications and synthesises monitoring scripts by using the sequence diagrams as templates referencing to the objects. Pink supports monitoring of microservices for their operability regarding a range of non-functional properties such as session management, caching and security.",Synthetic Runtime Monitoring of Microservices Software Architecture,"This paper describes Pink, a framework for synthetic runtime monitoring of microservices software systems which allows developers to specify the interactions of services using a UML component diagram, the assertions for the global properties of the microservices using OCL specifications, and the steps for interactions using UML sequence diagrams. Pink generates from the component diagram a set of object diagrams, selects them according to the OCL specifications and synthesises monitoring scripts by using the sequence diagrams as templates referencing to the objects. Pink supports monitoring of microservices for their operability regarding a range of non-functional properties such as session management, caching and security.",IEEE conference,no,"['synthetic', 'runtime', 'monitoring', 'paper', 'describes', 'pink', 'framework', 'synthetic', 'runtime', 'monitoring', 'allows', 'developer', 'specify', 'interaction', 'using', 'uml', 'diagram', 'assertion', 'global', 'property', 'using', 'specification', 'step', 'interaction', 'using', 'uml', 'sequence', 'diagram', 'pink', 'generates', 'diagram', 'set', 'object', 'diagram', 'selects', 'according', 'specification', 'synthesis', 'monitoring', 'script', 'using', 'sequence', 'diagram', 'template', 'object', 'pink', 'support', 'monitoring', 'regarding', 'range', 'property', 'session', 'management', 'caching', 'security']"
"A Lightweight Architecture Analysis of a Monolithic Messaging Gateway Background: The Enterprise Messaging Gateway (EMG) from Infoflex Connect (ICAB) is a monolithic system used to deliver mobile text messages (SMS) world-wide. The companies using it have diverse requirements on both functionality and quality attributes and would thus benefit from more versatile customizations, e.g. regarding authorization and data replication. Objective: ICAB needed help in assessing the current architecture of EMG in order to find candidates for architectural changes as well as fulfilling the needs of variability in meeting the wide range of customer requirements. Method: We analysed EMG using a lightweight version of ATAM (Architectural Trade-off Analysis Method) to get a better understanding of how different architectural decisions would affect the trade-offs between the quality requirements from the identified stakeholders. Result: Using the results of this structured approach, it was easy for ICAB to identify the functionality that needed to be improved. It also became clear that the selected component should be converted into a set of microservices, each one optimized for a specific set of customers. Limitation: The stakeholder requirements were gathered intermittently during a long period of continuous engagement, but there is a chance some of their requirements were still not communicated to us. Conclusion: Even though this ATAM study was performed internally at ICAB without direct involvement from any external stakeholders, documenting elicited quality attribute requirements and relating them to the EMG architecture provided new, unexpected, and valuable understandings of the system with a rather small effort.",A Lightweight Architecture Analysis of a Monolithic Messaging Gateway,"Background: The Enterprise Messaging Gateway (EMG) from Infoflex Connect (ICAB) is a monolithic system used to deliver mobile text messages (SMS) world-wide. The companies using it have diverse requirements on both functionality and quality attributes and would thus benefit from more versatile customizations, e.g. regarding authorization and data replication. Objective: ICAB needed help in assessing the current architecture of EMG in order to find candidates for architectural changes as well as fulfilling the needs of variability in meeting the wide range of customer requirements. Method: We analysed EMG using a lightweight version of ATAM (Architectural Trade-off Analysis Method) to get a better understanding of how different architectural decisions would affect the trade-offs between the quality requirements from the identified stakeholders. Result: Using the results of this structured approach, it was easy for ICAB to identify the functionality that needed to be improved. It also became clear that the selected component should be converted into a set of microservices, each one optimized for a specific set of customers. Limitation: The stakeholder requirements were gathered intermittently during a long period of continuous engagement, but there is a chance some of their requirements were still not communicated to us. Conclusion: Even though this ATAM study was performed internally at ICAB without direct involvement from any external stakeholders, documenting elicited quality attribute requirements and relating them to the EMG architecture provided new, unexpected, and valuable understandings of the system with a rather small effort.",IEEE conference,no,"['lightweight', 'analysis', 'monolithic', 'messaging', 'gateway', 'background', 'enterprise', 'messaging', 'gateway', 'emg', 'connect', 'icab', 'monolithic', 'used', 'deliver', 'mobile', 'text', 'message', 'company', 'using', 'diverse', 'requirement', 'functionality', 'quality', 'attribute', 'would', 'thus', 'benefit', 'versatile', 'regarding', 'authorization', 'replication', 'objective', 'icab', 'needed', 'help', 'assessing', 'current', 'emg', 'order', 'find', 'candidate', 'architectural', 'change', 'well', 'fulfilling', 'need', 'variability', 'meeting', 'wide', 'range', 'customer', 'requirement', 'method', 'analysed', 'emg', 'using', 'lightweight', 'version', 'architectural', 'analysis', 'method', 'get', 'better', 'understanding', 'different', 'architectural', 'decision', 'would', 'affect', 'quality', 'requirement', 'identified', 'stakeholder', 'result', 'using', 'result', 'structured', 'easy', 'icab', 'identify', 'functionality', 'needed', 'improved', 'also', 'became', 'clear', 'selected', 'set', 'one', 'optimized', 'specific', 'set', 'customer', 'limitation', 'stakeholder', 'requirement', 'long', 'period', 'continuous', 'chance', 'requirement', 'still', 'u', 'conclusion', 'even', 'though', 'study', 'performed', 'icab', 'without', 'direct', 'involvement', 'external', 'stakeholder', 'quality', 'attribute', 'requirement', 'emg', 'provided', 'new', 'unexpected', 'valuable', 'understanding', 'rather', 'small', 'effort']"
"Supply Chain Data Management for Web Services Supply chain management is extremely importantin today's environment. The modern supply chain mustevolve to meet new demands and challenges. Consumerdemands, additional market channels, internationalproblems and other factors will lead to significant challengesin supply chain network. However, some components of thesupply chain are opaque, limiting agility and decisionmaking. Millions of dollars are lost due to poor data quality. The lack of governance rules and transparency raises thedanger. As a result, consumer's trust and loyalty aredependent on sustainable sourcing and traceability. Ourproject proposes a microservice based data managementsystem for optimizing the supply chain management in anefficient way. The major goal is to store data in the mostefficient and cost-effective way possible so that productionand maintenance costs are kept low. The proposed researchwork has utilized seven major domains, which are developedby using microservice based approach and Java Springframework with Mongo Atlas as its database. MicrosoftAzure is used as a cloud service to deploy the APIs and userinterface through GIT actions. Different testing andmonitoring strategies are performed to keep the app up andrunning under extreme conditions. Design patterns and bestpractises are followed during the development.",Supply Chain Data Management for Web Services,"Supply chain management is extremely importantin today's environment. The modern supply chain mustevolve to meet new demands and challenges. Consumerdemands, additional market channels, internationalproblems and other factors will lead to significant challengesin supply chain network. However, some components of thesupply chain are opaque, limiting agility and decisionmaking. Millions of dollars are lost due to poor data quality. The lack of governance rules and transparency raises thedanger. As a result, consumer's trust and loyalty aredependent on sustainable sourcing and traceability. Ourproject proposes a microservice based data managementsystem for optimizing the supply chain management in anefficient way. The major goal is to store data in the mostefficient and cost-effective way possible so that productionand maintenance costs are kept low. The proposed researchwork has utilized seven major domains, which are developedby using microservice based approach and Java Springframework with Mongo Atlas as its database. MicrosoftAzure is used as a cloud service to deploy the APIs and userinterface through GIT actions. Different testing andmonitoring strategies are performed to keep the app up andrunning under extreme conditions. Design patterns and bestpractises are followed during the development.",IEEE conference,no,"['supply', 'chain', 'management', 'web', 'supply', 'chain', 'management', 'extremely', 'today', 'environment', 'modern', 'supply', 'chain', 'meet', 'new', 'demand', 'challenge', 'additional', 'market', 'channel', 'factor', 'lead', 'significant', 'supply', 'chain', 'network', 'however', 'chain', 'limiting', 'agility', 'million', 'lost', 'due', 'poor', 'quality', 'lack', 'governance', 'rule', 'raise', 'result', 'consumer', 'trust', 'sustainable', 'sourcing', 'traceability', 'proposes', 'based', 'optimizing', 'supply', 'chain', 'management', 'way', 'major', 'goal', 'store', 'way', 'possible', 'maintenance', 'cost', 'kept', 'low', 'proposed', 'utilized', 'major', 'domain', 'using', 'based', 'java', 'database', 'used', 'deploy', 'apis', 'action', 'different', 'testing', 'strategy', 'performed', 'keep', 'app', 'condition', 'design', 'pattern', 'followed', 'development']"
"Design and implementation of a decentralized message bus for microservices A new software architecture, known as microservices, becomes rapidly popular recently. Microservices could help developers cope well with the problems of software complexity and demands on an adaptive development process that needs to respond to changes quickly. In this architecture, a single monolithic large application would be divided into small multiple isolated services. They are separately deployed and communicated to other services via remote calls. This architectural style allows any changes on one service not affecting the others. However, if services directly make remote calls, it would create interdependencies and tight couplings between them. To remove such problem, this paper proposes a decentralized message bus to use as a communication tool between services. Our message bus provides a framework for services to collaborate. It divides into four main components, public API, message bus, messaging and service discovery. The API uses the HTTP and RESTful style of communication. We use decentralized service discovery to avoid a single point of failure of the system. The messaging uses a simple TCP connection with only a header and body in its message. We also define three necessary communication messages for the services, viz. request/response, notification and publish/subscribe. The proposed framework is implemented and tested with a real-world scenario. It works correctly without any problem. Also, to realize how it could be scaled, we run the system continuously with incremental services and traffics. From the observation on the resource consumption of CPU, memory and network I/O, we found that the network consumption grows linearly while the CPU and memory usages have little change in consumption.",Design and implementation of a decentralized message bus for microservices,"A new software architecture, known as microservices, becomes rapidly popular recently. Microservices could help developers cope well with the problems of software complexity and demands on an adaptive development process that needs to respond to changes quickly. In this architecture, a single monolithic large application would be divided into small multiple isolated services. They are separately deployed and communicated to other services via remote calls. This architectural style allows any changes on one service not affecting the others. However, if services directly make remote calls, it would create interdependencies and tight couplings between them. To remove such problem, this paper proposes a decentralized message bus to use as a communication tool between services. Our message bus provides a framework for services to collaborate. It divides into four main components, public API, message bus, messaging and service discovery. The API uses the HTTP and RESTful style of communication. We use decentralized service discovery to avoid a single point of failure of the system. The messaging uses a simple TCP connection with only a header and body in its message. We also define three necessary communication messages for the services, viz. request/response, notification and publish/subscribe. The proposed framework is implemented and tested with a real-world scenario. It works correctly without any problem. Also, to realize how it could be scaled, we run the system continuously with incremental services and traffics. From the observation on the resource consumption of CPU, memory and network I/O, we found that the network consumption grows linearly while the CPU and memory usages have little change in consumption.",IEEE conference,no,"['design', 'implementation', 'decentralized', 'message', 'bus', 'new', 'known', 'becomes', 'rapidly', 'popular', 'recently', 'could', 'help', 'developer', 'cope', 'well', 'problem', 'complexity', 'demand', 'adaptive', 'development', 'process', 'need', 'respond', 'change', 'quickly', 'single', 'monolithic', 'large', 'would', 'divided', 'small', 'multiple', 'isolated', 'separately', 'deployed', 'via', 'remote', 'call', 'architectural', 'style', 'allows', 'change', 'one', 'affecting', 'others', 'however', 'directly', 'make', 'remote', 'call', 'would', 'create', 'interdependency', 'coupling', 'problem', 'paper', 'proposes', 'decentralized', 'message', 'bus', 'use', 'communication', 'tool', 'message', 'bus', 'provides', 'framework', 'collaborate', 'divide', 'four', 'main', 'public', 'api', 'message', 'bus', 'messaging', 'discovery', 'api', 'us', 'http', 'restful', 'style', 'communication', 'use', 'decentralized', 'discovery', 'avoid', 'single', 'point', 'failure', 'messaging', 'us', 'simple', 'tcp', 'connection', 'body', 'message', 'also', 'define', 'three', 'necessary', 'communication', 'message', 'viz', 'proposed', 'framework', 'implemented', 'tested', 'scenario', 'work', 'correctly', 'without', 'problem', 'also', 'realize', 'could', 'scaled', 'run', 'continuously', 'traffic', 'observation', 'resource', 'consumption', 'cpu', 'memory', 'network', 'found', 'network', 'consumption', 'grows', 'cpu', 'memory', 'usage', 'little', 'change', 'consumption']"
"Implementation of Serverless E-Commerce Mobile Application In recent years, the internet ecosystem has improved many folds giving rise to multiple avenues for businesses to reach their customers. Technology adoption in the global arena has exponentially increased due to the evolution of smartphones. Due to the above-mentioned factors, E-Commerce has become one of the most widely used transaction methods worldwide to purchase products and services. Traditional Established Businesses can manage E-Commerce without a technology team with the help of EaaS (E-Commerce as a Service) Providers like Shopify, WooCommerce, BigCommerce and Magento which have very high development, subscription and ongoing cloud costs. Small and Medium Scale businesses need a cost-effective, high-performance solution to build the business. To build such a system we have performed research and analysis on available technology paradigms (monolith vs microservices) and Cloud paradigm (IaaS vs PaaS) for finalizing the architecture of the E-Commerce application. In this paper, we showcase the analysis results and elaborate on the implementation of our E-Commerce Application.",Implementation of Serverless E-Commerce Mobile Application,"In recent years, the internet ecosystem has improved many folds giving rise to multiple avenues for businesses to reach their customers. Technology adoption in the global arena has exponentially increased due to the evolution of smartphones. Due to the above-mentioned factors, E-Commerce has become one of the most widely used transaction methods worldwide to purchase products and services. Traditional Established Businesses can manage E-Commerce without a technology team with the help of EaaS (E-Commerce as a Service) Providers like Shopify, WooCommerce, BigCommerce and Magento which have very high development, subscription and ongoing cloud costs. Small and Medium Scale businesses need a cost-effective, high-performance solution to build the business. To build such a system we have performed research and analysis on available technology paradigms (monolith vs microservices) and Cloud paradigm (IaaS vs PaaS) for finalizing the architecture of the E-Commerce application. In this paper, we showcase the analysis results and elaborate on the implementation of our E-Commerce Application.",IEEE conference,no,"['implementation', 'serverless', 'mobile', 'recent', 'year', 'internet', 'ecosystem', 'improved', 'many', 'giving', 'rise', 'multiple', 'business', 'reach', 'customer', 'technology', 'adoption', 'global', 'increased', 'due', 'evolution', 'due', 'factor', 'become', 'one', 'widely', 'used', 'transaction', 'method', 'product', 'traditional', 'established', 'business', 'manage', 'without', 'technology', 'team', 'help', 'provider', 'like', 'high', 'development', 'ongoing', 'cost', 'small', 'medium', 'scale', 'business', 'need', 'solution', 'build', 'business', 'build', 'performed', 'research', 'analysis', 'available', 'technology', 'paradigm', 'monolith', 'v', 'paradigm', 'iaa', 'v', 'paas', 'paper', 'showcase', 'analysis', 'result', 'elaborate', 'implementation']"
"Microservices-based software architecture and approaches In the last few years, a revised software architecture style has been developed to design new software applications. This architecture style is particularly suited for use cases in the aerospace industry, from an independently deployable software service. The microservices architectural style develops a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms. These services are built around business and mission capabilities and independently deployable by fully automated machinery. With microservices, some types of applications become easier to build and maintain when they are broken down into smaller, composable pieces that work together. Each component is then developed separately, and the application is then simply the sum of its constituent components. This is in contrast to a traditional, “monolithic” application which is all developed in one piece. This paper will discuss, several aspects of microservices-based architecture, including several potential use cases for the aerospace industry. The characteristics of microservice-based architecture such as componentization, organization, endpoints and messaging mechanisms. The technical implementation of microservices by reviewing containerization, services communication and related architectural components. Specific open source projects and components that can be utilized to build microservices-based architecture. A sample set of use cases.",Microservices-based software architecture and approaches,"In the last few years, a revised software architecture style has been developed to design new software applications. This architecture style is particularly suited for use cases in the aerospace industry, from an independently deployable software service. The microservices architectural style develops a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms. These services are built around business and mission capabilities and independently deployable by fully automated machinery. With microservices, some types of applications become easier to build and maintain when they are broken down into smaller, composable pieces that work together. Each component is then developed separately, and the application is then simply the sum of its constituent components. This is in contrast to a traditional, “monolithic” application which is all developed in one piece. This paper will discuss, several aspects of microservices-based architecture, including several potential use cases for the aerospace industry. The characteristics of microservice-based architecture such as componentization, organization, endpoints and messaging mechanisms. The technical implementation of microservices by reviewing containerization, services communication and related architectural components. Specific open source projects and components that can be utilized to build microservices-based architecture. A sample set of use cases.",IEEE conference,no,"['last', 'year', 'style', 'developed', 'design', 'new', 'style', 'particularly', 'suited', 'use', 'case', 'aerospace', 'industry', 'independently', 'deployable', 'architectural', 'style', 'develops', 'single', 'suite', 'small', 'running', 'process', 'communicating', 'lightweight', 'mechanism', 'built', 'around', 'business', 'mission', 'capability', 'independently', 'deployable', 'fully', 'automated', 'type', 'become', 'easier', 'build', 'maintain', 'smaller', 'piece', 'work', 'together', 'developed', 'separately', 'simply', 'constituent', 'contrast', 'traditional', 'monolithic', 'developed', 'one', 'piece', 'paper', 'discus', 'several', 'aspect', 'including', 'several', 'potential', 'use', 'case', 'aerospace', 'industry', 'characteristic', 'componentization', 'organization', 'endpoint', 'messaging', 'mechanism', 'technical', 'implementation', 'containerization', 'communication', 'related', 'architectural', 'specific', 'open', 'source', 'project', 'utilized', 'build', 'sample', 'set', 'use', 'case']"
"Visualization Tool for Designing Microservices with the Monolith-First Approach The microservice architecture is essential for agile development and deployment of the application components; however, designing microservices for a web application is not a straight-forward task. One of the best ways to design microservices is to decompose a monolithic prototype of an application into microservices on the basis of both the complexity in engineering and the component boundaries of the application in the early phase of development. We propose a visualization tool allowing developers to interactively design microservice applications on the basis of the characteristics of source codes and the behaviors of a monolithic prototype. This visualization tool first constructs a calling-context tree from profile data taken in a dry-run of the application. Next, it generates an initial microservice design while considering keyword features in the source codes or amount of function calls between components. Developers can interactively refine this design via this visual interface by taking four-choice actions to revise boundaries of microservices while considering expected communications between them. This interaction will have a significant impact on runtime performance. Case studies of two open-source benchmark applications demonstrate the proposed tool enables interactive design of microservices. The results of the demonstration show that compared to the official microservice designs of the applications, the proposed tool can effectively design microservice applications.",Visualization Tool for Designing Microservices with the Monolith-First Approach,"The microservice architecture is essential for agile development and deployment of the application components; however, designing microservices for a web application is not a straight-forward task. One of the best ways to design microservices is to decompose a monolithic prototype of an application into microservices on the basis of both the complexity in engineering and the component boundaries of the application in the early phase of development. We propose a visualization tool allowing developers to interactively design microservice applications on the basis of the characteristics of source codes and the behaviors of a monolithic prototype. This visualization tool first constructs a calling-context tree from profile data taken in a dry-run of the application. Next, it generates an initial microservice design while considering keyword features in the source codes or amount of function calls between components. Developers can interactively refine this design via this visual interface by taking four-choice actions to revise boundaries of microservices while considering expected communications between them. This interaction will have a significant impact on runtime performance. Case studies of two open-source benchmark applications demonstrate the proposed tool enables interactive design of microservices. The results of the demonstration show that compared to the official microservice designs of the applications, the proposed tool can effectively design microservice applications.",IEEE conference,no,"['visualization', 'tool', 'designing', 'essential', 'agile', 'development', 'deployment', 'however', 'designing', 'web', 'task', 'one', 'best', 'way', 'design', 'decompose', 'monolithic', 'prototype', 'basis', 'complexity', 'engineering', 'boundary', 'early', 'phase', 'development', 'propose', 'visualization', 'tool', 'allowing', 'developer', 'design', 'basis', 'characteristic', 'source', 'code', 'behavior', 'monolithic', 'prototype', 'visualization', 'tool', 'first', 'construct', 'tree', 'profile', 'taken', 'next', 'generates', 'initial', 'design', 'considering', 'feature', 'source', 'code', 'amount', 'function', 'call', 'developer', 'refine', 'design', 'via', 'visual', 'interface', 'taking', 'action', 'boundary', 'considering', 'expected', 'communication', 'interaction', 'significant', 'impact', 'runtime', 'performance', 'case', 'study', 'two', 'benchmark', 'demonstrate', 'proposed', 'tool', 'enables', 'interactive', 'design', 'result', 'demonstration', 'show', 'compared', 'design', 'proposed', 'tool', 'effectively', 'design']"
"MicroMatic: Fully Automated Microservices Identification Approach from Monolithic Systems The Internet of Things (IoT) revolution is transforming system interactions and functionalities, necessitating more adaptable, scalable, and responsive systems architectures. These IoT systems build on recent advances in software architectures, particularly Microservices Architecture (MSA), enabling scalability, facilitating cloud deployment, and supporting seamless integration with DevOps practices. While new IoT applications can seamlessly integrate Microservices Architecture from their design, the migration of existing mono-lithic IoT systems to MSA is essential to leverage its benefits yet it remains a challenging and costly process. To facilitate this migration, we propose Micromatic, a tooled fully automated microser-vices identification approach that is based on static-relationship analyses between code elements as well as semantic analyses of the source code. Our approach relies on Machine Learning (ML) techniques and uses service types to guide the identification of microservices from IoT monolithic systems. We validate the effectiveness of our tool through a detailed case study, comparing our results with established ground truths. This process included a quantitative evaluation of the microservices generated, focusing on their business capabilities. Our findings demonstrate the efficiency of Micromatic in automating one of the most labour-intensive aspects of migrating legacy systems to a microservices framework, successfully identifying architecturally significant microservices with 62.5% precision and 45.5% recall.",MicroMatic: Fully Automated Microservices Identification Approach from Monolithic Systems,"The Internet of Things (IoT) revolution is transforming system interactions and functionalities, necessitating more adaptable, scalable, and responsive systems architectures. These IoT systems build on recent advances in software architectures, particularly Microservices Architecture (MSA), enabling scalability, facilitating cloud deployment, and supporting seamless integration with DevOps practices. While new IoT applications can seamlessly integrate Microservices Architecture from their design, the migration of existing mono-lithic IoT systems to MSA is essential to leverage its benefits yet it remains a challenging and costly process. To facilitate this migration, we propose Micromatic, a tooled fully automated microser-vices identification approach that is based on static-relationship analyses between code elements as well as semantic analyses of the source code. Our approach relies on Machine Learning (ML) techniques and uses service types to guide the identification of microservices from IoT monolithic systems. We validate the effectiveness of our tool through a detailed case study, comparing our results with established ground truths. This process included a quantitative evaluation of the microservices generated, focusing on their business capabilities. Our findings demonstrate the efficiency of Micromatic in automating one of the most labour-intensive aspects of migrating legacy systems to a microservices framework, successfully identifying architecturally significant microservices with 62.5% precision and 45.5% recall.",IEEE conference,no,"['micromatic', 'fully', 'automated', 'identification', 'monolithic', 'internet', 'thing', 'iot', 'transforming', 'interaction', 'functionality', 'necessitating', 'adaptable', 'scalable', 'responsive', 'iot', 'build', 'recent', 'advance', 'particularly', 'msa', 'enabling', 'scalability', 'facilitating', 'deployment', 'supporting', 'seamless', 'integration', 'devops', 'practice', 'new', 'iot', 'seamlessly', 'integrate', 'design', 'migration', 'existing', 'iot', 'msa', 'essential', 'leverage', 'benefit', 'yet', 'remains', 'challenging', 'costly', 'process', 'facilitate', 'migration', 'propose', 'micromatic', 'fully', 'automated', 'identification', 'based', 'analysis', 'code', 'element', 'well', 'semantic', 'analysis', 'source', 'code', 'relies', 'machine', 'learning', 'ml', 'technique', 'us', 'type', 'guide', 'identification', 'iot', 'monolithic', 'validate', 'effectiveness', 'tool', 'detailed', 'case', 'study', 'comparing', 'result', 'established', 'ground', 'truth', 'process', 'included', 'quantitative', 'evaluation', 'generated', 'focusing', 'business', 'capability', 'finding', 'demonstrate', 'efficiency', 'micromatic', 'automating', 'one', 'aspect', 'migrating', 'legacy', 'framework', 'successfully', 'identifying', 'significant', 'precision', 'recall']"
"Granularity Cost Analysis for Function Block as a Service The main challenge of exposing IEC61499 or IEC61131-3 Function Blocks as a service remains in adopting service-oriented concepts in function block programming. Implementing an IEC61499 or IEC61131-3 Function Block that is being accessed via service-oriented protocols is straight forward. The main challenge remains in modeling a Function Block as a service. Adopting service-oriented concepts like Service Oriented Architecture or Microservice Architecture requires tackling challenges like service granularity, (de)composition, etc. For instance, too coarse-grained services could lead to significant drawbacks, while too fine-grained services could increase the system's overall complexity, introducing semantic tight coupling and bringing about communication overhead. Therefore, understanding whether a service (de)composition is adding any value could help us to identify the best service granularity. Finding the best service granularity means knowing how many Function Blocks could be exposed into one service. This could undeniable lead to improvement in resource consumption especially in constraint environments. In this paper we design a cost analysis function for calculating the overhead of service decomposition. This work will help to answer one of the most important aspects of the service-oriented approach, called service granularity in the scope of Function Block as a Service.",Granularity Cost Analysis for Function Block as a Service,"The main challenge of exposing IEC61499 or IEC61131-3 Function Blocks as a service remains in adopting service-oriented concepts in function block programming. Implementing an IEC61499 or IEC61131-3 Function Block that is being accessed via service-oriented protocols is straight forward. The main challenge remains in modeling a Function Block as a service. Adopting service-oriented concepts like Service Oriented Architecture or Microservice Architecture requires tackling challenges like service granularity, (de)composition, etc. For instance, too coarse-grained services could lead to significant drawbacks, while too fine-grained services could increase the system's overall complexity, introducing semantic tight coupling and bringing about communication overhead. Therefore, understanding whether a service (de)composition is adding any value could help us to identify the best service granularity. Finding the best service granularity means knowing how many Function Blocks could be exposed into one service. This could undeniable lead to improvement in resource consumption especially in constraint environments. In this paper we design a cost analysis function for calculating the overhead of service decomposition. This work will help to answer one of the most important aspects of the service-oriented approach, called service granularity in the scope of Function Block as a Service.",IEEE conference,no,"['granularity', 'cost', 'analysis', 'function', 'block', 'main', 'challenge', 'exposing', 'function', 'block', 'remains', 'adopting', 'concept', 'function', 'block', 'programming', 'implementing', 'function', 'block', 'accessed', 'via', 'protocol', 'forward', 'main', 'challenge', 'remains', 'modeling', 'function', 'block', 'adopting', 'concept', 'like', 'oriented', 'requires', 'challenge', 'like', 'granularity', 'de', 'composition', 'etc', 'instance', 'could', 'lead', 'significant', 'drawback', 'could', 'increase', 'overall', 'complexity', 'introducing', 'semantic', 'coupling', 'bringing', 'communication', 'overhead', 'therefore', 'understanding', 'whether', 'de', 'composition', 'adding', 'value', 'could', 'help', 'u', 'identify', 'best', 'granularity', 'finding', 'best', 'granularity', 'mean', 'many', 'function', 'block', 'could', 'exposed', 'one', 'could', 'lead', 'improvement', 'resource', 'consumption', 'especially', 'constraint', 'environment', 'paper', 'design', 'cost', 'analysis', 'function', 'overhead', 'decomposition', 'work', 'help', 'answer', 'one', 'important', 'aspect', 'called', 'granularity', 'scope', 'function', 'block']"
"Web APIs Structures and Data Models Analysis Microservice architectures emphasize keeping components small, to foster autonomy, low coupling and independent evolution. In this large-scale empirical study we measure the size of Web API specifications mined from open source repositories. These APIs are modeled using the OpenAPI Specification (OAS), which, in addition to documenting the offered operations, also contain schemas definitions for the data exchanged with the API request and response message payloads. This study has as a goal to build empirical knowledge about: (1) How big and diverse are real-world web APIs both in terms of their operations and data, (2) How different API structures use and reuse schema definitions. By mining public software repositories on Github, we gathered 42,194 valid OAS specifications published between 2014-2021. These specifications include descriptions of Web APIs of well-known services providers such as Google, VMware (Avi Networks), Twilio, Amazon. After measuring the size of API structures and their data model schemas, we found that most APIs are rather small. Also there is a medium correlation between the size of the APIs’ functional structures and their data models. API developers do reuse schema definitions within the same API model.",Web APIs Structures and Data Models Analysis,"Microservice architectures emphasize keeping components small, to foster autonomy, low coupling and independent evolution. In this large-scale empirical study we measure the size of Web API specifications mined from open source repositories. These APIs are modeled using the OpenAPI Specification (OAS), which, in addition to documenting the offered operations, also contain schemas definitions for the data exchanged with the API request and response message payloads. This study has as a goal to build empirical knowledge about: (1) How big and diverse are real-world web APIs both in terms of their operations and data, (2) How different API structures use and reuse schema definitions. By mining public software repositories on Github, we gathered 42,194 valid OAS specifications published between 2014-2021. These specifications include descriptions of Web APIs of well-known services providers such as Google, VMware (Avi Networks), Twilio, Amazon. After measuring the size of API structures and their data model schemas, we found that most APIs are rather small. Also there is a medium correlation between the size of the APIs’ functional structures and their data models. API developers do reuse schema definitions within the same API model.",IEEE conference,no,"['web', 'apis', 'structure', 'model', 'analysis', 'keeping', 'small', 'foster', 'autonomy', 'low', 'coupling', 'independent', 'evolution', 'empirical', 'study', 'measure', 'size', 'web', 'api', 'specification', 'open', 'source', 'repository', 'apis', 'modeled', 'using', 'openapi', 'specification', 'addition', 'offered', 'operation', 'also', 'contain', 'schema', 'definition', 'api', 'request', 'response', 'message', 'study', 'goal', 'build', 'empirical', 'knowledge', 'big', 'diverse', 'web', 'apis', 'term', 'operation', 'different', 'api', 'structure', 'use', 'reuse', 'schema', 'definition', 'mining', 'public', 'repository', 'github', 'specification', 'published', 'specification', 'include', 'description', 'web', 'apis', 'provider', 'google', 'network', 'amazon', 'measuring', 'size', 'api', 'structure', 'model', 'schema', 'found', 'apis', 'rather', 'small', 'also', 'medium', 'correlation', 'size', 'apis', 'functional', 'structure', 'model', 'api', 'developer', 'reuse', 'schema', 'definition', 'within', 'api', 'model']"
"Webalyt: Implemetation of architecture for capturing web user behaviours with feedback propagation In the world of the Internet where people are consuming web-content, more and more emphasis is placed on user friendliness of web-pages. It means increasing web-page usability and better user-experience. Increasing quality of user-experience (UX) is the task of UX developers. They should always base their work on the best practices and research. Each webpage has its own specificity and it leads to new challenges for the UX developers. One of the biggest issues is the problematic view of a web-page on specific devices with specific web-browser versions. Tools for capturing user behaviour are available, but there are issues with data ownership and with the development of new functionality. Actually, there are no free easily scalable and extendable products for user data gathering on the market. In this paper, implementation of architecture (based on Spring Boot microservices) for capturing web user behaviours with feedback propagation is introduced. Architecture implementation is easily scalable and extendable. All of the components are described in detail. At the end of this paper, summary and limitation of created architecture is discussed. Webalyt is helpful for understanding user behaviour and improving user-experience.",Webalyt: Implemetation of architecture for capturing web user behaviours with feedback propagation,"In the world of the Internet where people are consuming web-content, more and more emphasis is placed on user friendliness of web-pages. It means increasing web-page usability and better user-experience. Increasing quality of user-experience (UX) is the task of UX developers. They should always base their work on the best practices and research. Each webpage has its own specificity and it leads to new challenges for the UX developers. One of the biggest issues is the problematic view of a web-page on specific devices with specific web-browser versions. Tools for capturing user behaviour are available, but there are issues with data ownership and with the development of new functionality. Actually, there are no free easily scalable and extendable products for user data gathering on the market. In this paper, implementation of architecture (based on Spring Boot microservices) for capturing web user behaviours with feedback propagation is introduced. Architecture implementation is easily scalable and extendable. All of the components are described in detail. At the end of this paper, summary and limitation of created architecture is discussed. Webalyt is helpful for understanding user behaviour and improving user-experience.",IEEE conference,no,"['capturing', 'web', 'user', 'behaviour', 'feedback', 'propagation', 'world', 'internet', 'people', 'consuming', 'emphasis', 'placed', 'user', 'mean', 'increasing', 'usability', 'better', 'increasing', 'quality', 'ux', 'task', 'ux', 'developer', 'always', 'base', 'work', 'best', 'practice', 'research', 'specificity', 'lead', 'new', 'challenge', 'ux', 'developer', 'one', 'issue', 'view', 'specific', 'device', 'specific', 'version', 'tool', 'capturing', 'user', 'behaviour', 'available', 'issue', 'ownership', 'development', 'new', 'functionality', 'actually', 'free', 'easily', 'scalable', 'extendable', 'product', 'user', 'gathering', 'market', 'paper', 'implementation', 'based', 'spring', 'boot', 'capturing', 'web', 'user', 'behaviour', 'feedback', 'propagation', 'introduced', 'implementation', 'easily', 'scalable', 'extendable', 'described', 'detail', 'end', 'paper', 'limitation', 'created', 'discussed', 'helpful', 'understanding', 'user', 'behaviour', 'improving']"
"A Systematic Review of the Software Architectures for the Development of Mobile Applications in Education Currently, mobile devices have gone from being objects of entertainment and socialization, to become work tools, powered by applications that facilitate the fulfillment of these tasks. This means not only understanding the problem to be solved, but also the schematization of the software components that will be involved. For this purpose, there are software architectures, which are guidelines that allow organizing and structuring the construction of applications for different devices and environments. Following this context, the following review article will evaluate the most used architectures in educational environments that implement technologies such as cloud, microservices, networks and others. Using the methodology proposed by Barbara Kitchenham and Okoli for literature extraction, from which 11 scientific articles were obtained, who talk about architectures such as n-tier, for augmented reality, client-server, cloud and microservices. As a result, of the 5 architectures that were implemented in the educational projects, the one with the highest rate of development is the client-server with 36.36% of implementations, while the least developed is the microservices with 9.09%, not leaving aside the possibility of combining these structures to achieve a better framework for the construction and development of mobile applications.",A Systematic Review of the Software Architectures for the Development of Mobile Applications in Education,"Currently, mobile devices have gone from being objects of entertainment and socialization, to become work tools, powered by applications that facilitate the fulfillment of these tasks. This means not only understanding the problem to be solved, but also the schematization of the software components that will be involved. For this purpose, there are software architectures, which are guidelines that allow organizing and structuring the construction of applications for different devices and environments. Following this context, the following review article will evaluate the most used architectures in educational environments that implement technologies such as cloud, microservices, networks and others. Using the methodology proposed by Barbara Kitchenham and Okoli for literature extraction, from which 11 scientific articles were obtained, who talk about architectures such as n-tier, for augmented reality, client-server, cloud and microservices. As a result, of the 5 architectures that were implemented in the educational projects, the one with the highest rate of development is the client-server with 36.36% of implementations, while the least developed is the microservices with 9.09%, not leaving aside the possibility of combining these structures to achieve a better framework for the construction and development of mobile applications.",IEEE conference,no,"['systematic', 'review', 'development', 'mobile', 'education', 'currently', 'mobile', 'device', 'object', 'become', 'work', 'tool', 'facilitate', 'task', 'mean', 'understanding', 'problem', 'solved', 'also', 'involved', 'purpose', 'guideline', 'allow', 'construction', 'different', 'device', 'environment', 'following', 'context', 'following', 'review', 'article', 'evaluate', 'used', 'educational', 'environment', 'implement', 'technology', 'network', 'others', 'using', 'methodology', 'proposed', 'literature', 'extraction', 'scientific', 'article', 'obtained', 'talk', 'reality', 'result', 'implemented', 'educational', 'project', 'one', 'highest', 'rate', 'development', 'implementation', 'least', 'developed', 'leaving', 'possibility', 'combining', 'structure', 'achieve', 'better', 'framework', 'construction', 'development', 'mobile']"
"Process Implications of Executable Domain Models for Microservices Development Microservice architecture has been recognized as an important enabler for continuous development of many cloud-based systems. Code generation has been tried in the tool chain of building microservices. However, most existing tools generally do not consider the risks from continuous development.We have been developing a toolkit which generates microservices from application domain models. Our approach aligns development process to this toolkit and coordinates domain modeling activity over project life cycles. In this paper, we describe its framework and corresponding development process which eliminates delays brought by the uncertainty of a project at a relatively early stage. Several minimum viable products have been built upon the proposed approach during the past years, including automated generation of code from domain decomposition. Our result shows 10% saving of effort and fewer issues. Effort saving increases to 30% under an extreme condition with high-rate personnel turnover. We also discuss our findings on running these projects and raise discussion and questions for future enhancement.",Process Implications of Executable Domain Models for Microservices Development,"Microservice architecture has been recognized as an important enabler for continuous development of many cloud-based systems. Code generation has been tried in the tool chain of building microservices. However, most existing tools generally do not consider the risks from continuous development.We have been developing a toolkit which generates microservices from application domain models. Our approach aligns development process to this toolkit and coordinates domain modeling activity over project life cycles. In this paper, we describe its framework and corresponding development process which eliminates delays brought by the uncertainty of a project at a relatively early stage. Several minimum viable products have been built upon the proposed approach during the past years, including automated generation of code from domain decomposition. Our result shows 10% saving of effort and fewer issues. Effort saving increases to 30% under an extreme condition with high-rate personnel turnover. We also discuss our findings on running these projects and raise discussion and questions for future enhancement.",IEEE conference,no,"['process', 'implication', 'executable', 'domain', 'model', 'development', 'recognized', 'important', 'enabler', 'continuous', 'development', 'many', 'code', 'generation', 'tried', 'tool', 'chain', 'building', 'however', 'existing', 'tool', 'generally', 'consider', 'risk', 'continuous', 'developing', 'toolkit', 'generates', 'domain', 'model', 'development', 'process', 'toolkit', 'coordinate', 'domain', 'modeling', 'activity', 'project', 'life', 'cycle', 'paper', 'describe', 'framework', 'corresponding', 'development', 'process', 'delay', 'brought', 'uncertainty', 'project', 'relatively', 'early', 'stage', 'several', 'minimum', 'viable', 'product', 'built', 'upon', 'proposed', 'past', 'year', 'including', 'automated', 'generation', 'code', 'domain', 'decomposition', 'result', 'show', 'saving', 'effort', 'fewer', 'issue', 'effort', 'saving', 'increase', 'condition', 'personnel', 'also', 'discus', 'finding', 'running', 'project', 'raise', 'discussion', 'question', 'future', 'enhancement']"
"MicroValid: A Validation Framework for Automatically Decomposed Microservices In a dynamic world of software development, the architectural styles are continuously evolving, adapting to new technologies and trends. Microservice architecture (MSA) is gaining adoption among industry practitioners due to its advantages compared to the monolithic architecture. Although MSA builds on the core concepts of Service Oriented Architecture (SOA), it pushes for a finer granularity, with stricter boundaries. Due to cost rationale, numerous companies choose to migrate from the monolithic style instead of developing from scratch. Recently, semi-automatic decomposition tools assist the migration process, yet a crucial part is still missing: validation. The current study focuses on providing a validation framework for microservices decomposed from monolithic applications and complete the puzzle of architectural migrations. From previous work we select quality attributes of microservices that may be assessed using static analysis. We then provide an implementation specification of the validation framework. We use five applications to evaluate our approach, and the results show that our solution is scalable while providing insightful measurements of the assessed quality attributes of microservices.",MicroValid: A Validation Framework for Automatically Decomposed Microservices,"In a dynamic world of software development, the architectural styles are continuously evolving, adapting to new technologies and trends. Microservice architecture (MSA) is gaining adoption among industry practitioners due to its advantages compared to the monolithic architecture. Although MSA builds on the core concepts of Service Oriented Architecture (SOA), it pushes for a finer granularity, with stricter boundaries. Due to cost rationale, numerous companies choose to migrate from the monolithic style instead of developing from scratch. Recently, semi-automatic decomposition tools assist the migration process, yet a crucial part is still missing: validation. The current study focuses on providing a validation framework for microservices decomposed from monolithic applications and complete the puzzle of architectural migrations. From previous work we select quality attributes of microservices that may be assessed using static analysis. We then provide an implementation specification of the validation framework. We use five applications to evaluate our approach, and the results show that our solution is scalable while providing insightful measurements of the assessed quality attributes of microservices.",IEEE conference,no,"['validation', 'framework', 'automatically', 'decomposed', 'dynamic', 'world', 'development', 'architectural', 'style', 'continuously', 'evolving', 'adapting', 'new', 'technology', 'trend', 'msa', 'gaining', 'adoption', 'among', 'industry', 'practitioner', 'due', 'advantage', 'compared', 'monolithic', 'although', 'msa', 'build', 'core', 'concept', 'oriented', 'soa', 'push', 'finer', 'granularity', 'boundary', 'due', 'cost', 'numerous', 'company', 'choose', 'migrate', 'monolithic', 'style', 'instead', 'developing', 'scratch', 'recently', 'decomposition', 'tool', 'assist', 'migration', 'process', 'yet', 'crucial', 'part', 'still', 'missing', 'validation', 'current', 'study', 'focus', 'providing', 'validation', 'framework', 'decomposed', 'monolithic', 'complete', 'architectural', 'migration', 'previous', 'work', 'select', 'quality', 'attribute', 'may', 'assessed', 'using', 'static', 'analysis', 'provide', 'implementation', 'specification', 'validation', 'framework', 'use', 'five', 'evaluate', 'result', 'show', 'solution', 'scalable', 'providing', 'measurement', 'assessed', 'quality', 'attribute']"
"Intelligent Software Mining with Business Intelligence Tools for Automation of Micro services in SOA: A Use Case for Analytics Business Intelligence as a platform is of great assistance to software engineers for analyzing and amassing data to search for information through queries. Object oriented business engineering advances reusability by considering reusable components at the business level. Systematic reuse is the major factor governing the success of an object-oriented software business. Software mining or mining of software engineering data is the successful mining of software engineering data. The integration of mining of software engineering data and Business Intelligence tools gives rise to automation of software services at business level. Automation is the key to Industry 4.0 that we witness today. Therefore, automation of software intelligence is the need of the hour for service delivery. Today's cloud-based applications are working on delivery of Anything as a Service (XaaS) that accounts for provision of anything as a service like database, software, microservices, security on the cloud platform. Service-oriented Architecture (SoA) is based on Software as a Service (SaaS) of the cloud computing. Software intelligence is the form of artificial intelligence which automates the process of mining software engineering data for useful business applications. Not only it integrates the amalgamation of the above fields but at the same time associates the field with industry standards. The aim of this paper is to analyze the various Business Intelligence tools available for promoting intelligence at the business level with benefits to the SoA services particularly microservices for the cloud platform. With the analysis the goal of Business Oriented Software Engineering is enhanced with the analysis and proper usage of business intelligence tools at all the levels of software development process.",Intelligent Software Mining with Business Intelligence Tools for Automation of Micro services in SOA: A Use Case for Analytics,"Business Intelligence as a platform is of great assistance to software engineers for analyzing and amassing data to search for information through queries. Object oriented business engineering advances reusability by considering reusable components at the business level. Systematic reuse is the major factor governing the success of an object-oriented software business. Software mining or mining of software engineering data is the successful mining of software engineering data. The integration of mining of software engineering data and Business Intelligence tools gives rise to automation of software services at business level. Automation is the key to Industry 4.0 that we witness today. Therefore, automation of software intelligence is the need of the hour for service delivery. Today's cloud-based applications are working on delivery of Anything as a Service (XaaS) that accounts for provision of anything as a service like database, software, microservices, security on the cloud platform. Service-oriented Architecture (SoA) is based on Software as a Service (SaaS) of the cloud computing. Software intelligence is the form of artificial intelligence which automates the process of mining software engineering data for useful business applications. Not only it integrates the amalgamation of the above fields but at the same time associates the field with industry standards. The aim of this paper is to analyze the various Business Intelligence tools available for promoting intelligence at the business level with benefits to the SoA services particularly microservices for the cloud platform. With the analysis the goal of Business Oriented Software Engineering is enhanced with the analysis and proper usage of business intelligence tools at all the levels of software development process.",IEEE conference,no,"['intelligent', 'mining', 'business', 'intelligence', 'tool', 'automation', 'micro', 'soa', 'use', 'case', 'analytics', 'business', 'intelligence', 'platform', 'great', 'engineer', 'analyzing', 'search', 'information', 'query', 'object', 'oriented', 'business', 'engineering', 'advance', 'reusability', 'considering', 'reusable', 'business', 'level', 'systematic', 'reuse', 'major', 'factor', 'success', 'business', 'mining', 'mining', 'engineering', 'successful', 'mining', 'engineering', 'integration', 'mining', 'engineering', 'business', 'intelligence', 'tool', 'give', 'rise', 'automation', 'business', 'level', 'automation', 'key', 'industry', 'today', 'therefore', 'automation', 'intelligence', 'need', 'hour', 'delivery', 'today', 'working', 'delivery', 'xaas', 'account', 'provision', 'like', 'database', 'security', 'platform', 'soa', 'based', 'saas', 'computing', 'intelligence', 'form', 'artificial', 'intelligence', 'automates', 'process', 'mining', 'engineering', 'useful', 'business', 'integrates', 'field', 'time', 'field', 'industry', 'standard', 'aim', 'paper', 'analyze', 'various', 'business', 'intelligence', 'tool', 'available', 'promoting', 'intelligence', 'business', 'level', 'benefit', 'soa', 'particularly', 'platform', 'analysis', 'goal', 'business', 'oriented', 'engineering', 'enhanced', 'analysis', 'proper', 'usage', 'business', 'intelligence', 'tool', 'level', 'development', 'process']"
"Extracting Micro Service Dependencies Using Log Analysis Microservice architecture is an architectural style that supports the design and implementation of very scalable systems by distributing complex functionality to highly granular components. These highly granular components are referred to as microservices and can be dynamically deployed on Docker containers. These microservice architecture systems are very extensible since new microservices can be added or replaced as the system evolves. In such highly granular architectures, a major challenge that arises is how to quickly identify whether any changes in the system’s structure violates any policies or design constraints. Examples of policies and design constraints include whether a microservice can call or pass data to another microservice, and whether data handled by one microservice can be stored in a specific database. In order to perform such type of analysis a model that denotes call and data dependencies between microservices must be constructed. In this paper, we present a technique that is based on log analysis and probabilistic reasoning to yield a labeled, typed, directed multigraph that represents call and data exchanges between microservices in a given deployment. This dependency graph can serve as input to analysis engines to be used for identifying design and policy violations as the system evolves or being updated. The proposed dependency graph creation approach has been applied to a medium size open source microservice system with very promising results.",Extracting Micro Service Dependencies Using Log Analysis,"Microservice architecture is an architectural style that supports the design and implementation of very scalable systems by distributing complex functionality to highly granular components. These highly granular components are referred to as microservices and can be dynamically deployed on Docker containers. These microservice architecture systems are very extensible since new microservices can be added or replaced as the system evolves. In such highly granular architectures, a major challenge that arises is how to quickly identify whether any changes in the system’s structure violates any policies or design constraints. Examples of policies and design constraints include whether a microservice can call or pass data to another microservice, and whether data handled by one microservice can be stored in a specific database. In order to perform such type of analysis a model that denotes call and data dependencies between microservices must be constructed. In this paper, we present a technique that is based on log analysis and probabilistic reasoning to yield a labeled, typed, directed multigraph that represents call and data exchanges between microservices in a given deployment. This dependency graph can serve as input to analysis engines to be used for identifying design and policy violations as the system evolves or being updated. The proposed dependency graph creation approach has been applied to a medium size open source microservice system with very promising results.",IEEE conference,no,"['micro', 'dependency', 'using', 'log', 'analysis', 'architectural', 'style', 'support', 'design', 'implementation', 'scalable', 'distributing', 'complex', 'functionality', 'highly', 'granular', 'highly', 'granular', 'referred', 'dynamically', 'deployed', 'docker', 'container', 'extensible', 'since', 'new', 'added', 'replaced', 'evolves', 'highly', 'granular', 'major', 'challenge', 'arises', 'quickly', 'identify', 'whether', 'change', 'structure', 'policy', 'design', 'constraint', 'example', 'policy', 'design', 'constraint', 'include', 'whether', 'call', 'another', 'whether', 'handled', 'one', 'stored', 'specific', 'database', 'order', 'perform', 'type', 'analysis', 'model', 'call', 'dependency', 'must', 'constructed', 'paper', 'present', 'technique', 'based', 'log', 'analysis', 'probabilistic', 'reasoning', 'yield', 'represents', 'call', 'exchange', 'given', 'deployment', 'dependency', 'graph', 'serve', 'input', 'analysis', 'engine', 'used', 'identifying', 'design', 'policy', 'violation', 'evolves', 'updated', 'proposed', 'dependency', 'graph', 'creation', 'applied', 'medium', 'size', 'open', 'source', 'promising', 'result']"
"Linked Data Architecture for Plan Execution in Distributed CPS Future cyber-physical systems (CPS) require their components to perform autonomously. To do that safely and efficiently, CPS components will need access to the global state of the whole CPS. These components will require near real-time updates to a subset of the global state to react to changes in the environment. A particular challenge is to monitor state updates from the distributed CPS components: one needs to ensure that only states consistent with the PDDL plan execution semantics can be observed within the system. In order to guarantee that, a component to monitor plan execution is proposed. Microservices based on Linked Data technologies are used to provide a uniform way to access component states, represented as Resource Description Framework (RDF) resources. To ensure the correct ordering of state updates, we present an extension of the OASIS OSLC TRS protocol. Specifically, we strengthen the ordering guarantees of state change events and introduce inlining of the state with the events to prevent state mismatch at the dereferencing stage.",Linked Data Architecture for Plan Execution in Distributed CPS,"Future cyber-physical systems (CPS) require their components to perform autonomously. To do that safely and efficiently, CPS components will need access to the global state of the whole CPS. These components will require near real-time updates to a subset of the global state to react to changes in the environment. A particular challenge is to monitor state updates from the distributed CPS components: one needs to ensure that only states consistent with the PDDL plan execution semantics can be observed within the system. In order to guarantee that, a component to monitor plan execution is proposed. Microservices based on Linked Data technologies are used to provide a uniform way to access component states, represented as Resource Description Framework (RDF) resources. To ensure the correct ordering of state updates, we present an extension of the OASIS OSLC TRS protocol. Specifically, we strengthen the ordering guarantees of state change events and introduce inlining of the state with the events to prevent state mismatch at the dereferencing stage.",IEEE conference,no,"['linked', 'plan', 'execution', 'distributed', 'cps', 'future', 'cps', 'require', 'perform', 'autonomously', 'efficiently', 'cps', 'need', 'access', 'global', 'state', 'whole', 'cps', 'require', 'near', 'update', 'subset', 'global', 'state', 'react', 'change', 'environment', 'particular', 'challenge', 'monitor', 'state', 'update', 'distributed', 'cps', 'one', 'need', 'ensure', 'state', 'consistent', 'plan', 'execution', 'observed', 'within', 'order', 'guarantee', 'monitor', 'plan', 'execution', 'proposed', 'based', 'linked', 'technology', 'used', 'provide', 'uniform', 'way', 'access', 'state', 'resource', 'description', 'framework', 'resource', 'ensure', 'correct', 'state', 'update', 'present', 'extension', 'protocol', 'specifically', 'guarantee', 'state', 'change', 'event', 'introduce', 'state', 'event', 'prevent', 'state', 'stage']"
"Weighing the Evidence: On Relationship Types in Microservice Extraction The microservice-based architecture - a SOA-inspired principle of dividing systems into components that communicate with each other using language-agnostic APIs - has gained increased popularity in industry. Yet, migrating a monolithic application to microservices is a challenging task. A number of automated microservice extraction techniques have been proposed to help developers with the migration complexity. These techniques, at large, construct a graph-based representation of an application and cluster its elements into service candidates. The techniques vary by their decomposition goals and, subsequently, types of relationships between application elements that they consider - structural, semantic term similarity, and evolutionary - with each technique utilizing a fixed subset and weighting of these relationship types.In this paper, we perform a multi-method exploratory study with 10 industrial practitioners to investigate (1) the applicability and usefulness of different relationships types during the microservice extraction process and (2) expectations practitioners have for tools utilizing such relationships. Our results show that practitioners often need a ""what-if"" analysis tool that simultaneously considers multiple relationship types during the extraction process and that there is no fixed way to weight these relationships. Our study also identifies organization- and application-specific considerations that lead practitioners to prefer certain relationship types over others, e.g., the age of the codebase and languages spoken in the organization. It outlines possible strategies to help developers during the extraction process, e.g., the ability to iteratively filter and customize relationships.",Weighing the Evidence: On Relationship Types in Microservice Extraction,"The microservice-based architecture - a SOA-inspired principle of dividing systems into components that communicate with each other using language-agnostic APIs - has gained increased popularity in industry. Yet, migrating a monolithic application to microservices is a challenging task. A number of automated microservice extraction techniques have been proposed to help developers with the migration complexity. These techniques, at large, construct a graph-based representation of an application and cluster its elements into service candidates. The techniques vary by their decomposition goals and, subsequently, types of relationships between application elements that they consider - structural, semantic term similarity, and evolutionary - with each technique utilizing a fixed subset and weighting of these relationship types.In this paper, we perform a multi-method exploratory study with 10 industrial practitioners to investigate (1) the applicability and usefulness of different relationships types during the microservice extraction process and (2) expectations practitioners have for tools utilizing such relationships. Our results show that practitioners often need a ""what-if"" analysis tool that simultaneously considers multiple relationship types during the extraction process and that there is no fixed way to weight these relationships. Our study also identifies organization- and application-specific considerations that lead practitioners to prefer certain relationship types over others, e.g., the age of the codebase and languages spoken in the organization. It outlines possible strategies to help developers during the extraction process, e.g., the ability to iteratively filter and customize relationships.",IEEE conference,no,"['evidence', 'relationship', 'type', 'extraction', 'principle', 'dividing', 'communicate', 'using', 'apis', 'gained', 'increased', 'popularity', 'industry', 'yet', 'migrating', 'monolithic', 'challenging', 'task', 'number', 'automated', 'extraction', 'technique', 'proposed', 'help', 'developer', 'migration', 'complexity', 'technique', 'large', 'construct', 'representation', 'cluster', 'element', 'candidate', 'technique', 'vary', 'decomposition', 'goal', 'subsequently', 'type', 'relationship', 'element', 'consider', 'structural', 'semantic', 'term', 'similarity', 'evolutionary', 'technique', 'utilizing', 'fixed', 'subset', 'relationship', 'paper', 'perform', 'exploratory', 'study', 'industrial', 'practitioner', 'investigate', 'applicability', 'different', 'relationship', 'type', 'extraction', 'process', 'expectation', 'practitioner', 'tool', 'utilizing', 'relationship', 'result', 'show', 'practitioner', 'often', 'need', 'analysis', 'tool', 'simultaneously', 'considers', 'multiple', 'relationship', 'type', 'extraction', 'process', 'fixed', 'way', 'weight', 'relationship', 'study', 'also', 'identifies', 'consideration', 'lead', 'practitioner', 'certain', 'relationship', 'type', 'others', 'age', 'codebase', 'language', 'organization', 'outline', 'possible', 'strategy', 'help', 'developer', 'extraction', 'process', 'ability', 'filter', 'customize', 'relationship']"
"A Survey of Publish/Subscribe Middleware Systems for Microservice Communication In today's industrial and academic research area, the publish/subscribe (pub/sub) communication paradigm is gaining attention. Due to its capacity to decouple communication entities in time, space, and synchronization, it is a useful interaction mechanism for large-scale distributed systems. Rather than interacting directly with one another, services in the pub/sub pattern can communicate through a message broker. This approach separates the concerns of publishers and subscribers, allowing publishers to concentrate just on publishing and subscribers to concentrate solely on the publications to which they are subscribed. The resulting structure enables asynchronous message sending and receiving by a task-specific broker, which is one of the various approaches to construct event-based systems. Because of their unique qualities, including data-centricity, dynamicity, and many-to-many communications, the decoupling properties are well-suited for Microservices. Components of a monolithic application call each other using language-level method or function calls. A microservices-based application, on the other hand, is a distributed system that runs on numerous machines. Typically, each service instance is a process. There are numerous advantages to using the Microservices Architecture design. It begins by addressing the issue of complexity. It breaks down what would otherwise be a massive monolithic application into a series of services. While the overall functionality of the application has not changed, it has been divided into digestible parts or services. A significant disadvantage of microservices is the increased complexity that comes with being a distributed system. Developers must choose and implement a messaging or Remote procedure call-based interprocess communication mechanism. As a result, services must communicate through the interprocess communication (IPC) method. The Pub/Sub communication model, a powerful interprocess communication technique has been utilized in several studies. We examine the Pub/Sub interaction paradigm in the context of Communication for Microservices in this study.",A Survey of Publish/Subscribe Middleware Systems for Microservice Communication,"In today's industrial and academic research area, the publish/subscribe (pub/sub) communication paradigm is gaining attention. Due to its capacity to decouple communication entities in time, space, and synchronization, it is a useful interaction mechanism for large-scale distributed systems. Rather than interacting directly with one another, services in the pub/sub pattern can communicate through a message broker. This approach separates the concerns of publishers and subscribers, allowing publishers to concentrate just on publishing and subscribers to concentrate solely on the publications to which they are subscribed. The resulting structure enables asynchronous message sending and receiving by a task-specific broker, which is one of the various approaches to construct event-based systems. Because of their unique qualities, including data-centricity, dynamicity, and many-to-many communications, the decoupling properties are well-suited for Microservices. Components of a monolithic application call each other using language-level method or function calls. A microservices-based application, on the other hand, is a distributed system that runs on numerous machines. Typically, each service instance is a process. There are numerous advantages to using the Microservices Architecture design. It begins by addressing the issue of complexity. It breaks down what would otherwise be a massive monolithic application into a series of services. While the overall functionality of the application has not changed, it has been divided into digestible parts or services. A significant disadvantage of microservices is the increased complexity that comes with being a distributed system. Developers must choose and implement a messaging or Remote procedure call-based interprocess communication mechanism. As a result, services must communicate through the interprocess communication (IPC) method. The Pub/Sub communication model, a powerful interprocess communication technique has been utilized in several studies. We examine the Pub/Sub interaction paradigm in the context of Communication for Microservices in this study.",IEEE conference,no,"['survey', 'middleware', 'communication', 'today', 'industrial', 'academic', 'research', 'area', 'communication', 'paradigm', 'gaining', 'attention', 'due', 'capacity', 'decouple', 'communication', 'entity', 'time', 'space', 'synchronization', 'useful', 'interaction', 'mechanism', 'distributed', 'rather', 'interacting', 'directly', 'one', 'another', 'pattern', 'communicate', 'message', 'broker', 'separate', 'concern', 'subscriber', 'allowing', 'concentrate', 'subscriber', 'concentrate', 'solely', 'resulting', 'structure', 'enables', 'asynchronous', 'message', 'broker', 'one', 'various', 'construct', 'unique', 'quality', 'including', 'dynamicity', 'communication', 'decoupling', 'property', 'monolithic', 'call', 'using', 'method', 'function', 'call', 'hand', 'distributed', 'run', 'numerous', 'machine', 'typically', 'instance', 'process', 'numerous', 'advantage', 'using', 'design', 'begin', 'addressing', 'issue', 'complexity', 'break', 'would', 'massive', 'monolithic', 'series', 'overall', 'functionality', 'changed', 'divided', 'part', 'significant', 'disadvantage', 'increased', 'complexity', 'come', 'distributed', 'developer', 'must', 'choose', 'implement', 'messaging', 'remote', 'procedure', 'interprocess', 'communication', 'mechanism', 'result', 'must', 'communicate', 'interprocess', 'communication', 'method', 'communication', 'model', 'powerful', 'interprocess', 'communication', 'technique', 'utilized', 'several', 'study', 'examine', 'interaction', 'paradigm', 'context', 'communication', 'study']"
"Formalization and Verification of RocketMQ Using CSP With the development of cloud serverless and microservices architectures, RocketMQ recently has emerged as a compelling pattern of service-to-service communication for them. Nowadays, due to its features of high performance, high reliability, low latency, many companies use the open source version of RocketMQ in their business. The existing works are mainly the applications of RocketMQ to realize the program communications, however there are few formalized models for RocketMQ. It is essential to model and verify the RocketMQ system abstracted from its architecture in a formal method to ensure the messaging reliability. In this paper, we focus on the data messaging in production and consumption mechanism to facilitate the overall modeling. Six communication components are extracted including Producer, Consumer, Master Broker, Slave Broker, NameServer, and Clock for describing the temporal process. Then we formalize and model the RocketMQ system using Communicating Sequential Processes (CSP) to describe communicating process among those components. Furthermore, we implement the model of RocketMQ and verify six properties, such as Deadlock Freedom, Consistency, Parallelism, Fault Tolerance, Sequentiality and HeartBeat Mechanism based on the model checker Process Analysis Toolkit (PAT). Finally, our verification results show that the model can satisfy these properties, indicating its messaging reliability can be guaranteed.",Formalization and Verification of RocketMQ Using CSP,"With the development of cloud serverless and microservices architectures, RocketMQ recently has emerged as a compelling pattern of service-to-service communication for them. Nowadays, due to its features of high performance, high reliability, low latency, many companies use the open source version of RocketMQ in their business. The existing works are mainly the applications of RocketMQ to realize the program communications, however there are few formalized models for RocketMQ. It is essential to model and verify the RocketMQ system abstracted from its architecture in a formal method to ensure the messaging reliability. In this paper, we focus on the data messaging in production and consumption mechanism to facilitate the overall modeling. Six communication components are extracted including Producer, Consumer, Master Broker, Slave Broker, NameServer, and Clock for describing the temporal process. Then we formalize and model the RocketMQ system using Communicating Sequential Processes (CSP) to describe communicating process among those components. Furthermore, we implement the model of RocketMQ and verify six properties, such as Deadlock Freedom, Consistency, Parallelism, Fault Tolerance, Sequentiality and HeartBeat Mechanism based on the model checker Process Analysis Toolkit (PAT). Finally, our verification results show that the model can satisfy these properties, indicating its messaging reliability can be guaranteed.",IEEE conference,no,"['verification', 'rocketmq', 'using', 'csp', 'development', 'serverless', 'rocketmq', 'recently', 'emerged', 'pattern', 'communication', 'nowadays', 'due', 'feature', 'high', 'performance', 'high', 'reliability', 'low', 'latency', 'many', 'company', 'use', 'open', 'source', 'version', 'rocketmq', 'business', 'existing', 'work', 'mainly', 'rocketmq', 'realize', 'program', 'communication', 'however', 'model', 'rocketmq', 'essential', 'model', 'verify', 'rocketmq', 'formal', 'method', 'ensure', 'messaging', 'reliability', 'paper', 'focus', 'messaging', 'production', 'consumption', 'mechanism', 'facilitate', 'overall', 'modeling', 'six', 'communication', 'extracted', 'including', 'producer', 'consumer', 'master', 'broker', 'broker', 'describing', 'temporal', 'process', 'model', 'rocketmq', 'using', 'communicating', 'sequential', 'process', 'csp', 'describe', 'communicating', 'process', 'among', 'furthermore', 'implement', 'model', 'rocketmq', 'verify', 'six', 'property', 'consistency', 'parallelism', 'fault', 'tolerance', 'mechanism', 'based', 'model', 'process', 'analysis', 'toolkit', 'finally', 'verification', 'result', 'show', 'model', 'satisfy', 'property', 'indicating', 'messaging', 'reliability', 'guaranteed']"
"An Empirical Study of Scalability Frameworks in Open Source Microservices-based Systems Microservice-based systems (MBS) are distributed systems consistent of smaller components (possibly developed by separate teams using different technologies) that use lightweight mechanisms to communicate with each other. One of the main quality attributes that motivate MBS is scalability, and there are several available frameworks to face scalability challenges in MBS. However, there is still little empirical data about the architectural concerns of using these frameworks to support the scalability dimensions. This article builds upon a previous study that defined a pattern language for MBS scalability, and aims to identify and analyze which MBS frameworks are actually used in open source MBS projects to address the scalability dimensions. Results show that (1) nine common frameworks satisfy the scalability dimensions defined in the pattern language, (2) frameworks produce trade-offs among scalability dimensions, and (3) few frameworks address several scalability dimensions at once. Finally, we identify five reusable design decisions to address scalability requirements and propose them as microservices architectural tactics.",An Empirical Study of Scalability Frameworks in Open Source Microservices-based Systems,"Microservice-based systems (MBS) are distributed systems consistent of smaller components (possibly developed by separate teams using different technologies) that use lightweight mechanisms to communicate with each other. One of the main quality attributes that motivate MBS is scalability, and there are several available frameworks to face scalability challenges in MBS. However, there is still little empirical data about the architectural concerns of using these frameworks to support the scalability dimensions. This article builds upon a previous study that defined a pattern language for MBS scalability, and aims to identify and analyze which MBS frameworks are actually used in open source MBS projects to address the scalability dimensions. Results show that (1) nine common frameworks satisfy the scalability dimensions defined in the pattern language, (2) frameworks produce trade-offs among scalability dimensions, and (3) few frameworks address several scalability dimensions at once. Finally, we identify five reusable design decisions to address scalability requirements and propose them as microservices architectural tactics.",IEEE conference,no,"['empirical', 'study', 'scalability', 'framework', 'open', 'source', 'mb', 'distributed', 'consistent', 'smaller', 'possibly', 'developed', 'separate', 'team', 'using', 'different', 'technology', 'use', 'lightweight', 'mechanism', 'communicate', 'one', 'main', 'quality', 'attribute', 'motivate', 'mb', 'scalability', 'several', 'available', 'framework', 'face', 'scalability', 'challenge', 'mb', 'however', 'still', 'little', 'empirical', 'architectural', 'concern', 'using', 'framework', 'support', 'scalability', 'dimension', 'article', 'build', 'upon', 'previous', 'study', 'defined', 'pattern', 'language', 'mb', 'scalability', 'aim', 'identify', 'analyze', 'mb', 'framework', 'actually', 'used', 'open', 'source', 'mb', 'project', 'address', 'scalability', 'dimension', 'result', 'show', 'common', 'framework', 'satisfy', 'scalability', 'dimension', 'defined', 'pattern', 'language', 'framework', 'produce', 'among', 'scalability', 'dimension', 'framework', 'address', 'several', 'scalability', 'dimension', 'finally', 'identify', 'five', 'reusable', 'design', 'decision', 'address', 'scalability', 'requirement', 'propose', 'architectural', 'tactic']"
"Microservice Decomposition Techniques: An Independent Tool Comparison The microservice-based architecture – a SOA-inspired principle of dividing systems into components that communicate with each other using language-agnostic APIs – has gained increased popularity in industry. Yet, migrating a monolithic application into microservices is a challenging task. A number of automated microservice decomposition techniques have been proposed in industry and academia to help developers with the migration complexity. Each of the techniques is usually evaluated on its own set of case study applications and evaluation criteria, making it difficult to compare the techniques to each other and assess the real progress in this field. To fill this gap, this paper performs an independent study comparing eight microservice decomposition tools that implement a wide range of different decomposition principles with each other on a set of four carefully selected benchmark applications. We evaluate the tools both quantitatively and qualitatively, and further interview developers behind two of the selected benchmark applications. Our analysis highlights strengths and weaknesses of existing approaches, and provides suggestions for future research, e.g., to provide differential treatment of application elements of different types, to customize the decomposition strategy and granularity per specific application, and more.",Microservice Decomposition Techniques: An Independent Tool Comparison,"The microservice-based architecture – a SOA-inspired principle of dividing systems into components that communicate with each other using language-agnostic APIs – has gained increased popularity in industry. Yet, migrating a monolithic application into microservices is a challenging task. A number of automated microservice decomposition techniques have been proposed in industry and academia to help developers with the migration complexity. Each of the techniques is usually evaluated on its own set of case study applications and evaluation criteria, making it difficult to compare the techniques to each other and assess the real progress in this field. To fill this gap, this paper performs an independent study comparing eight microservice decomposition tools that implement a wide range of different decomposition principles with each other on a set of four carefully selected benchmark applications. We evaluate the tools both quantitatively and qualitatively, and further interview developers behind two of the selected benchmark applications. Our analysis highlights strengths and weaknesses of existing approaches, and provides suggestions for future research, e.g., to provide differential treatment of application elements of different types, to customize the decomposition strategy and granularity per specific application, and more.",IEEE conference,no,"['decomposition', 'technique', 'independent', 'tool', 'comparison', 'principle', 'dividing', 'communicate', 'using', 'apis', 'gained', 'increased', 'popularity', 'industry', 'yet', 'migrating', 'monolithic', 'challenging', 'task', 'number', 'automated', 'decomposition', 'technique', 'proposed', 'industry', 'academia', 'help', 'developer', 'migration', 'complexity', 'technique', 'usually', 'evaluated', 'set', 'case', 'study', 'evaluation', 'criterion', 'making', 'difficult', 'compare', 'technique', 'assess', 'real', 'progress', 'field', 'fill', 'gap', 'paper', 'performs', 'independent', 'study', 'comparing', 'eight', 'decomposition', 'tool', 'implement', 'wide', 'range', 'different', 'decomposition', 'principle', 'set', 'four', 'carefully', 'selected', 'benchmark', 'evaluate', 'tool', 'quantitatively', 'developer', 'behind', 'two', 'selected', 'benchmark', 'analysis', 'highlight', 'strength', 'existing', 'provides', 'suggestion', 'future', 'research', 'provide', 'treatment', 'element', 'different', 'type', 'customize', 'decomposition', 'strategy', 'granularity', 'per', 'specific']"
"Approach for Fast Growing Software Systems using layered architecture : Scaling an architecture with minimal refactoring Currently, the market imposes several demands on software throughout its development cycle, such as the rapid availability of a minimum viable product, the ability to deal with rapid growth in the volume of data and in the number of users, the ability to provide new features or changes, easy adaptability of new developers, among many others. Choosing a software architecture is something that will impact the entire software development lifecycle (SDLC) and, as such, should be seen as an extremely important task. A monolithic architecture enables a fast initial development, however there are several limits after a certain point. A microservices architecture is highly scalable and can handle many clients simultaneously, but it is too complex to be used at an early stage of software development. If the software grows, it will have to scale, and an architecture migration may be necessary. This paper presents an architectural approach for this migration to be done with minimal refactoring and keeping infrastructure and implementation costs low.",Approach for Fast Growing Software Systems using layered architecture : Scaling an architecture with minimal refactoring,"Currently, the market imposes several demands on software throughout its development cycle, such as the rapid availability of a minimum viable product, the ability to deal with rapid growth in the volume of data and in the number of users, the ability to provide new features or changes, easy adaptability of new developers, among many others. Choosing a software architecture is something that will impact the entire software development lifecycle (SDLC) and, as such, should be seen as an extremely important task. A monolithic architecture enables a fast initial development, however there are several limits after a certain point. A microservices architecture is highly scalable and can handle many clients simultaneously, but it is too complex to be used at an early stage of software development. If the software grows, it will have to scale, and an architecture migration may be necessary. This paper presents an architectural approach for this migration to be done with minimal refactoring and keeping infrastructure and implementation costs low.",IEEE conference,no,"['fast', 'growing', 'using', 'layered', 'scaling', 'minimal', 'refactoring', 'currently', 'market', 'several', 'demand', 'throughout', 'development', 'cycle', 'rapid', 'availability', 'minimum', 'viable', 'product', 'ability', 'deal', 'rapid', 'growth', 'volume', 'number', 'user', 'ability', 'provide', 'new', 'feature', 'change', 'easy', 'adaptability', 'new', 'developer', 'among', 'many', 'others', 'choosing', 'impact', 'entire', 'development', 'lifecycle', 'sdlc', 'seen', 'extremely', 'important', 'task', 'monolithic', 'enables', 'fast', 'initial', 'development', 'however', 'several', 'limit', 'certain', 'point', 'highly', 'scalable', 'handle', 'many', 'client', 'simultaneously', 'complex', 'used', 'early', 'stage', 'development', 'grows', 'scale', 'migration', 'may', 'necessary', 'paper', 'present', 'architectural', 'migration', 'done', 'minimal', 'refactoring', 'keeping', 'infrastructure', 'implementation', 'cost', 'low']"
"Service Discovery Mechanism for Micro Services in Cloud Computing: Comparative Study Cloud computing is an online service that is provided as services over the internet. Finding and using the services that are available, which is a crucial component for service-oriented applications, is one of the major challenges in cloud computing. This paper ranks service discovery mechanisms into three major classes: centralized, decentralized, and hybrid. In order to determine and contrast the usefulness and efficiency of various service discovery techniques for cloud computing's microservices, this comparative study looks at several service discovery strategies. It examines existing research papers and studies in order to compare different approaches used for cloud service discovery.A comparison of these methods shows that the decentralized technique depends on a distributed network while the centralized relies on the central registry and the hybrid is a combination of both approaches. This review paper helps researchers who would like to compare analyses of service discovery mechanisms in cloud computing.",Service Discovery Mechanism for Micro Services in Cloud Computing: Comparative Study,"Cloud computing is an online service that is provided as services over the internet. Finding and using the services that are available, which is a crucial component for service-oriented applications, is one of the major challenges in cloud computing. This paper ranks service discovery mechanisms into three major classes: centralized, decentralized, and hybrid. In order to determine and contrast the usefulness and efficiency of various service discovery techniques for cloud computing's microservices, this comparative study looks at several service discovery strategies. It examines existing research papers and studies in order to compare different approaches used for cloud service discovery.A comparison of these methods shows that the decentralized technique depends on a distributed network while the centralized relies on the central registry and the hybrid is a combination of both approaches. This review paper helps researchers who would like to compare analyses of service discovery mechanisms in cloud computing.",IEEE conference,no,"['discovery', 'mechanism', 'micro', 'computing', 'comparative', 'study', 'computing', 'online', 'provided', 'internet', 'finding', 'using', 'available', 'crucial', 'one', 'major', 'challenge', 'computing', 'paper', 'rank', 'discovery', 'mechanism', 'three', 'major', 'class', 'centralized', 'decentralized', 'hybrid', 'order', 'determine', 'contrast', 'efficiency', 'various', 'discovery', 'technique', 'computing', 'comparative', 'study', 'look', 'several', 'discovery', 'strategy', 'examines', 'existing', 'research', 'paper', 'study', 'order', 'compare', 'different', 'used', 'comparison', 'method', 'show', 'decentralized', 'technique', 'depends', 'distributed', 'network', 'centralized', 'relies', 'central', 'registry', 'hybrid', 'combination', 'review', 'paper', 'help', 'researcher', 'would', 'like', 'compare', 'analysis', 'discovery', 'mechanism', 'computing']"
"Utilization of Three Software Size Measures for Effort Estimation in Agile World: A Case Study Functional size measurement (FSM) methods, by being systematic and repeatable, are beneficial in the early phases of the software life cycle for core project management activities such as effort, cost, and schedule estimation. However, in agile projects, requirements are kept minimal in the early phases and are detailed over time as the project progresses. This situation makes it challenging to identify measurement components of FSM methods from requirements in the early phases, hence complicates applying FSM in agile projects. In addition, the existing FSM methods are not fully compatible with today’s architectural styles, which are evolving into event-driven decentralized structures. In this study, we present the results of a case study to compare the effectiveness of different size measures: functional -COSMIC Function Points (CFP)-, event-based - Event Points-, and code length-based - Line of Code (LOC)-on projects that were developed with agile methods and utilized a microservice-based architecture. For this purpose, we measured the size of the project and created effort estimation models based on three methods. It is found that the event-based method estimated effort with better accuracy than the CFP and LOC-based methods.",Utilization of Three Software Size Measures for Effort Estimation in Agile World: A Case Study,"Functional size measurement (FSM) methods, by being systematic and repeatable, are beneficial in the early phases of the software life cycle for core project management activities such as effort, cost, and schedule estimation. However, in agile projects, requirements are kept minimal in the early phases and are detailed over time as the project progresses. This situation makes it challenging to identify measurement components of FSM methods from requirements in the early phases, hence complicates applying FSM in agile projects. In addition, the existing FSM methods are not fully compatible with today’s architectural styles, which are evolving into event-driven decentralized structures. In this study, we present the results of a case study to compare the effectiveness of different size measures: functional -COSMIC Function Points (CFP)-, event-based - Event Points-, and code length-based - Line of Code (LOC)-on projects that were developed with agile methods and utilized a microservice-based architecture. For this purpose, we measured the size of the project and created effort estimation models based on three methods. It is found that the event-based method estimated effort with better accuracy than the CFP and LOC-based methods.",IEEE conference,no,"['utilization', 'three', 'size', 'measure', 'effort', 'estimation', 'agile', 'world', 'case', 'study', 'functional', 'size', 'measurement', 'fsm', 'method', 'systematic', 'repeatable', 'beneficial', 'early', 'phase', 'life', 'cycle', 'core', 'project', 'management', 'activity', 'effort', 'cost', 'schedule', 'estimation', 'however', 'agile', 'project', 'requirement', 'kept', 'minimal', 'early', 'phase', 'detailed', 'time', 'project', 'progress', 'situation', 'make', 'challenging', 'identify', 'measurement', 'fsm', 'method', 'requirement', 'early', 'phase', 'hence', 'applying', 'fsm', 'agile', 'project', 'addition', 'existing', 'fsm', 'method', 'fully', 'compatible', 'today', 'architectural', 'style', 'evolving', 'decentralized', 'structure', 'study', 'present', 'result', 'case', 'study', 'compare', 'effectiveness', 'different', 'size', 'measure', 'functional', 'function', 'point', 'event', 'code', 'line', 'code', 'project', 'developed', 'agile', 'method', 'utilized', 'purpose', 'measured', 'size', 'project', 'created', 'effort', 'estimation', 'model', 'based', 'three', 'method', 'found', 'method', 'effort', 'better', 'accuracy', 'method']"
"μ Viz: Visualization of Microservices Microservice architectures have become very popular and widely adopted by the industry, because of the benefits they bring to the software development process and resulting systems, such as parallel development, modularity and scalability. However, as interfaces become more fine-grained and systems grown in size, complexity is moved from the component services to their interactions, eventually leading to intricate workflows that are hard to observe, visualize, and understand. This problem is compounded by the typically high workloads that produce intractable amounts of observation data. To deal with these challenges, operators need support from tools able to take in observation data, in particular tracing, and provide a fast and intuitive understanding of which components or workflows require attention and how are they affecting a module, service, instance, or the whole application. In this paper, we present the design of a microservice visualization application that can fill a gap that exists in leveraging tracing data, aggregating and navigating it in ways that are actionable for operators. Our application provides multiple views of the system and uses spatial and hierarchical navigation using flip zoom to simplify their exploration, while preserving context. Our application can provide a better understanding of the system than existing applications that lack navigability and do not preserve context when switching between different services, layers or views.",μ Viz: Visualization of Microservices,"Microservice architectures have become very popular and widely adopted by the industry, because of the benefits they bring to the software development process and resulting systems, such as parallel development, modularity and scalability. However, as interfaces become more fine-grained and systems grown in size, complexity is moved from the component services to their interactions, eventually leading to intricate workflows that are hard to observe, visualize, and understand. This problem is compounded by the typically high workloads that produce intractable amounts of observation data. To deal with these challenges, operators need support from tools able to take in observation data, in particular tracing, and provide a fast and intuitive understanding of which components or workflows require attention and how are they affecting a module, service, instance, or the whole application. In this paper, we present the design of a microservice visualization application that can fill a gap that exists in leveraging tracing data, aggregating and navigating it in ways that are actionable for operators. Our application provides multiple views of the system and uses spatial and hierarchical navigation using flip zoom to simplify their exploration, while preserving context. Our application can provide a better understanding of the system than existing applications that lack navigability and do not preserve context when switching between different services, layers or views.",IEEE conference,no,"['viz', 'visualization', 'become', 'popular', 'widely', 'adopted', 'industry', 'benefit', 'bring', 'development', 'process', 'resulting', 'parallel', 'development', 'modularity', 'scalability', 'however', 'interface', 'become', 'size', 'complexity', 'moved', 'interaction', 'eventually', 'leading', 'intricate', 'workflow', 'hard', 'observe', 'visualize', 'understand', 'problem', 'typically', 'high', 'workload', 'produce', 'amount', 'observation', 'deal', 'challenge', 'operator', 'need', 'support', 'tool', 'able', 'take', 'observation', 'particular', 'tracing', 'provide', 'fast', 'intuitive', 'understanding', 'workflow', 'require', 'attention', 'affecting', 'module', 'instance', 'whole', 'paper', 'present', 'design', 'visualization', 'fill', 'gap', 'exists', 'leveraging', 'tracing', 'way', 'operator', 'provides', 'multiple', 'view', 'us', 'spatial', 'hierarchical', 'using', 'simplify', 'exploration', 'preserving', 'context', 'provide', 'better', 'understanding', 'existing', 'lack', 'preserve', 'context', 'different', 'layer', 'view']"
"Performance evaluation in the migration process from a monolithic application to microservices Microservices are considered as a software architecture that allows the decomposition of a system, its components or its functionalities into a set of small services, which are implemented, deployed and managed independently. In this study, the models that allow migrating a Monolith to Microservices such as NGINX and IBM are analyzed. From these models, activities that allow such migration are carefully selected and identified. In order to implement and evaluate the activities proposed in those models, an application that initially does not have any structure at the design and coding level (using PHP programming language) is applied. Then, the application's coding language changes to Java and the classes and libraries are distributed into packages. Subsequently, as it is suggested in the models, services are identified and implemented using RESTful Web Services to finally implement the microservices using technologies such as Spring Boot, Eureka, and Zuul. In the migration process, the application under study is modified at the code and design level, including patterns such as Singleton, Façade, Strangler, Single Service per Host, Service Discovery, and API Gateway, which are used to evaluate performance as a quality attribute in each migration phase. In order to obtain the performance related metrics and to analyze the advantages and disadvantages of each migration phase, Apache JMeter as tool is used. This tool is set up to generate results regarding the use of resources such as CPU, memory, network, and database access. Finally, the results show scenarios of several concurrent users who access to consult records in the database that uses the aforementioned application in each migration phase.",Performance evaluation in the migration process from a monolithic application to microservices,"Microservices are considered as a software architecture that allows the decomposition of a system, its components or its functionalities into a set of small services, which are implemented, deployed and managed independently. In this study, the models that allow migrating a Monolith to Microservices such as NGINX and IBM are analyzed. From these models, activities that allow such migration are carefully selected and identified. In order to implement and evaluate the activities proposed in those models, an application that initially does not have any structure at the design and coding level (using PHP programming language) is applied. Then, the application's coding language changes to Java and the classes and libraries are distributed into packages. Subsequently, as it is suggested in the models, services are identified and implemented using RESTful Web Services to finally implement the microservices using technologies such as Spring Boot, Eureka, and Zuul. In the migration process, the application under study is modified at the code and design level, including patterns such as Singleton, Façade, Strangler, Single Service per Host, Service Discovery, and API Gateway, which are used to evaluate performance as a quality attribute in each migration phase. In order to obtain the performance related metrics and to analyze the advantages and disadvantages of each migration phase, Apache JMeter as tool is used. This tool is set up to generate results regarding the use of resources such as CPU, memory, network, and database access. Finally, the results show scenarios of several concurrent users who access to consult records in the database that uses the aforementioned application in each migration phase.",IEEE conference,no,"['performance', 'evaluation', 'migration', 'process', 'monolithic', 'considered', 'allows', 'decomposition', 'functionality', 'set', 'small', 'implemented', 'deployed', 'managed', 'independently', 'study', 'model', 'allow', 'migrating', 'monolith', 'nginx', 'analyzed', 'model', 'activity', 'allow', 'migration', 'carefully', 'selected', 'identified', 'order', 'implement', 'evaluate', 'activity', 'proposed', 'model', 'structure', 'design', 'coding', 'level', 'using', 'programming', 'language', 'applied', 'coding', 'language', 'change', 'java', 'class', 'library', 'distributed', 'subsequently', 'model', 'identified', 'implemented', 'using', 'restful', 'web', 'finally', 'implement', 'using', 'technology', 'spring', 'boot', 'migration', 'process', 'study', 'modified', 'code', 'design', 'level', 'including', 'pattern', 'single', 'per', 'host', 'discovery', 'api', 'gateway', 'used', 'evaluate', 'performance', 'quality', 'attribute', 'migration', 'phase', 'order', 'obtain', 'performance', 'related', 'metric', 'analyze', 'advantage', 'disadvantage', 'migration', 'phase', 'apache', 'tool', 'used', 'tool', 'set', 'generate', 'result', 'regarding', 'use', 'resource', 'cpu', 'memory', 'network', 'database', 'access', 'finally', 'result', 'show', 'scenario', 'several', 'concurrent', 'user', 'access', 'database', 'us', 'aforementioned', 'migration', 'phase']"
"Effort Prediction for Microservices: A Case Study Software size measurement is critical as an input to perform important project management processes such as effort, cost and schedule estimation. Functional size measurement (FSM) methods are beneficial in terms of being applicable in the early phases of the software life cycle over functional requirements and providing a systematic and repeatable method. However, in agile organizations, it can be challenging to seperate measurement components of FSM methods from requirements in the early phases as the documentation is kept to a minimum compared to traditional methods such as the Waterfall Model and is detailed as the project steps. In addition, the existing FSM methods are not fully compatible with today's architectural structures, which are from being data-driven and to evolve into a behaviour-oriented structure. In this study, we performed a case study which includes a project developed with agile methods and using microservice-based architecture to compare the effectiveness of COSMIC FSM and event-based software size measurement. For this purpose, we measured the size of the project and created effort estimation models based on two methods. The measurers had difficulty in applying both methods due to the limited detail level of the requirements in the project. However, the event-based method was found to estimate effort with less error than the COSMIC FSM method.",Effort Prediction for Microservices: A Case Study,"Software size measurement is critical as an input to perform important project management processes such as effort, cost and schedule estimation. Functional size measurement (FSM) methods are beneficial in terms of being applicable in the early phases of the software life cycle over functional requirements and providing a systematic and repeatable method. However, in agile organizations, it can be challenging to seperate measurement components of FSM methods from requirements in the early phases as the documentation is kept to a minimum compared to traditional methods such as the Waterfall Model and is detailed as the project steps. In addition, the existing FSM methods are not fully compatible with today's architectural structures, which are from being data-driven and to evolve into a behaviour-oriented structure. In this study, we performed a case study which includes a project developed with agile methods and using microservice-based architecture to compare the effectiveness of COSMIC FSM and event-based software size measurement. For this purpose, we measured the size of the project and created effort estimation models based on two methods. The measurers had difficulty in applying both methods due to the limited detail level of the requirements in the project. However, the event-based method was found to estimate effort with less error than the COSMIC FSM method.",IEEE conference,no,"['effort', 'prediction', 'case', 'study', 'size', 'measurement', 'critical', 'input', 'perform', 'important', 'project', 'management', 'process', 'effort', 'cost', 'schedule', 'estimation', 'functional', 'size', 'measurement', 'fsm', 'method', 'beneficial', 'term', 'applicable', 'early', 'phase', 'life', 'cycle', 'functional', 'requirement', 'providing', 'systematic', 'repeatable', 'method', 'however', 'agile', 'organization', 'challenging', 'measurement', 'fsm', 'method', 'requirement', 'early', 'phase', 'documentation', 'kept', 'minimum', 'compared', 'traditional', 'method', 'model', 'detailed', 'project', 'step', 'addition', 'existing', 'fsm', 'method', 'fully', 'compatible', 'today', 'architectural', 'structure', 'evolve', 'structure', 'study', 'performed', 'case', 'study', 'includes', 'project', 'developed', 'agile', 'method', 'using', 'compare', 'effectiveness', 'fsm', 'size', 'measurement', 'purpose', 'measured', 'size', 'project', 'created', 'effort', 'estimation', 'model', 'based', 'two', 'method', 'difficulty', 'applying', 'method', 'due', 'limited', 'detail', 'level', 'requirement', 'project', 'however', 'method', 'found', 'estimate', 'effort', 'less', 'error', 'fsm', 'method']"
"From Monolithic Architecture Style to Microservice one Based on a Semi-Automatic Approach Due to its tremendous advantages, microservice architectural style has become an essential element for the development of applications deployed on the cloud and for those adopting the DevOps practices. Nevertheless, while microservices can be used to develop new applications, there are monolithic ones, that are not well adapted neither to the cloud nor to DevOps. Migrating these applications towards microservices appears as a solution to adapt them to both. In this context, we propose an approach aiming to achieve this objective by focusing on the step of microservices identification. The proposed identification, in this paper, is based on an analysis of the relationships between source code elements, their relationships with the persistent data manipulated in this code and finally the knowledge, often partial, of the architect concerning the system to migrate. A function that measures the quality of a microservice based on its ability to provide consistent service and its interdependence with others microservice in the resulting architecture was defined. Moreover, the architect recommendations are used, when available, to guide the identification process. The conducted experiment shows the relevance of the obtained microservices by our approach.",From Monolithic Architecture Style to Microservice one Based on a Semi-Automatic Approach,"Due to its tremendous advantages, microservice architectural style has become an essential element for the development of applications deployed on the cloud and for those adopting the DevOps practices. Nevertheless, while microservices can be used to develop new applications, there are monolithic ones, that are not well adapted neither to the cloud nor to DevOps. Migrating these applications towards microservices appears as a solution to adapt them to both. In this context, we propose an approach aiming to achieve this objective by focusing on the step of microservices identification. The proposed identification, in this paper, is based on an analysis of the relationships between source code elements, their relationships with the persistent data manipulated in this code and finally the knowledge, often partial, of the architect concerning the system to migrate. A function that measures the quality of a microservice based on its ability to provide consistent service and its interdependence with others microservice in the resulting architecture was defined. Moreover, the architect recommendations are used, when available, to guide the identification process. The conducted experiment shows the relevance of the obtained microservices by our approach.",IEEE conference,no,"['monolithic', 'style', 'one', 'based', 'due', 'advantage', 'architectural', 'style', 'become', 'essential', 'element', 'development', 'deployed', 'adopting', 'devops', 'practice', 'nevertheless', 'used', 'develop', 'new', 'monolithic', 'one', 'well', 'adapted', 'devops', 'migrating', 'towards', 'solution', 'adapt', 'context', 'propose', 'aiming', 'achieve', 'objective', 'focusing', 'step', 'identification', 'proposed', 'identification', 'paper', 'based', 'analysis', 'relationship', 'source', 'code', 'element', 'relationship', 'code', 'finally', 'knowledge', 'often', 'architect', 'concerning', 'migrate', 'function', 'measure', 'quality', 'based', 'ability', 'provide', 'consistent', 'others', 'resulting', 'defined', 'moreover', 'architect', 'recommendation', 'used', 'available', 'guide', 'identification', 'process', 'conducted', 'experiment', 'show', 'relevance', 'obtained']"
"Dexmo Software Product Line and Product Composition Method With the spread of service-based software, software product lines where software components are services or even microservices have started to emerge. In this paper, the Dexmo software product line approach developed in this way at Univera is explained. Dexmo software product line is different from the classical software product lines. A novel marketing engineering process and a control tower application are added on top of domain and application engineering. Moreover, Dexmo software product line approach offers significant changes in both domain and application engineering compared to the classics. The software product composition method, one of the most important of these, is also explained in detail.",Dexmo Software Product Line and Product Composition Method,"With the spread of service-based software, software product lines where software components are services or even microservices have started to emerge. In this paper, the Dexmo software product line approach developed in this way at Univera is explained. Dexmo software product line is different from the classical software product lines. A novel marketing engineering process and a control tower application are added on top of domain and application engineering. Moreover, Dexmo software product line approach offers significant changes in both domain and application engineering compared to the classics. The software product composition method, one of the most important of these, is also explained in detail.",IEEE conference,no,"['dexmo', 'product', 'line', 'product', 'composition', 'method', 'spread', 'product', 'line', 'even', 'started', 'emerge', 'paper', 'dexmo', 'product', 'line', 'developed', 'way', 'explained', 'dexmo', 'product', 'line', 'different', 'classical', 'product', 'line', 'novel', 'marketing', 'engineering', 'process', 'control', 'added', 'top', 'domain', 'engineering', 'moreover', 'dexmo', 'product', 'line', 'offer', 'significant', 'change', 'domain', 'engineering', 'compared', 'classic', 'product', 'composition', 'method', 'one', 'important', 'also', 'explained', 'detail']"
"Trace Visualization within the Software City Metaphor: A Controlled Experiment on Program Comprehension Especially with the rise of microservice architectures, software is hard to understand when just the static dependencies are known. The reason is that the actual call paths and the dynamic behavior of the application is hidden behind network communication. To comprehend what is going on in the software the vast amount of runtime data (traces) needs to be reduced and visualized.DynaCity uses the city metaphor for visualization. Its novel trace visualization displays dynamic dependencies as arcs atop the city. To reduce the number of traces, DynaCity aggregates all requests between the same two components into one arc whose brightness reflects both the number and the total duration of the requests. DynaCity also encodes dynamic trace data in a heatmap that it uses to light up the building: the brighter a building is, the more active it is, i.e., the more and the longer the requests are that it receives and/or spawns.In a controlled experiment, we compare our approach with a traditional trace visualization built into the same Software City but showing all dependencies (without aggregation) as individual arcs and also disabling the heatmap. The study shows that professional software developers can solve typical software comprehension tasks faster (5.84%) and more correctly (11.7%) with the help of DynaCity and that they prefer our approach over the more traditional dynamic trace visualization.",Trace Visualization within the Software City Metaphor: A Controlled Experiment on Program Comprehension,"Especially with the rise of microservice architectures, software is hard to understand when just the static dependencies are known. The reason is that the actual call paths and the dynamic behavior of the application is hidden behind network communication. To comprehend what is going on in the software the vast amount of runtime data (traces) needs to be reduced and visualized.DynaCity uses the city metaphor for visualization. Its novel trace visualization displays dynamic dependencies as arcs atop the city. To reduce the number of traces, DynaCity aggregates all requests between the same two components into one arc whose brightness reflects both the number and the total duration of the requests. DynaCity also encodes dynamic trace data in a heatmap that it uses to light up the building: the brighter a building is, the more active it is, i.e., the more and the longer the requests are that it receives and/or spawns.In a controlled experiment, we compare our approach with a traditional trace visualization built into the same Software City but showing all dependencies (without aggregation) as individual arcs and also disabling the heatmap. The study shows that professional software developers can solve typical software comprehension tasks faster (5.84%) and more correctly (11.7%) with the help of DynaCity and that they prefer our approach over the more traditional dynamic trace visualization.",IEEE conference,no,"['trace', 'visualization', 'within', 'city', 'metaphor', 'controlled', 'experiment', 'program', 'comprehension', 'especially', 'rise', 'hard', 'understand', 'static', 'dependency', 'known', 'reason', 'actual', 'call', 'path', 'dynamic', 'behavior', 'behind', 'network', 'communication', 'comprehend', 'going', 'vast', 'amount', 'runtime', 'trace', 'need', 'reduced', 'us', 'city', 'metaphor', 'visualization', 'novel', 'trace', 'visualization', 'dynamic', 'dependency', 'arc', 'city', 'reduce', 'number', 'trace', 'dynacity', 'aggregate', 'request', 'two', 'one', 'arc', 'whose', 'number', 'total', 'duration', 'request', 'dynacity', 'also', 'dynamic', 'trace', 'us', 'light', 'building', 'building', 'active', 'longer', 'request', 'controlled', 'experiment', 'compare', 'traditional', 'trace', 'visualization', 'built', 'city', 'showing', 'dependency', 'without', 'aggregation', 'individual', 'arc', 'also', 'study', 'show', 'professional', 'developer', 'solve', 'typical', 'comprehension', 'task', 'faster', 'correctly', 'help', 'dynacity', 'traditional', 'dynamic', 'trace', 'visualization']"
"RESTful Web Services – A Question of Standards Roy Thomas Fielding defined the term REST as an architectural style for distributed hypermedia based systems in the year 2000. Since this initial definition, the term itself became a buzzword used in almost any web-related development. From simple, basic web applications, to highly complex web service/microservice-based solutions, almost everyone and everything talks REST and RESTful. Moreover, the Web context implies that these developments are usually realised over HTTP. In this paper, we first analyse the impact of this architectural style on distributed application development. A careless application of this model and its underlying HTTP standards could severely impact on the overall quality of any RESTful based solution. Following, we submit our own model for user data and session handling tasks to illustrate the correct approach to RESTful web service design techniques. This model offers all the advantages of the aforementioned architectural style while providing the required functionality for the authentication and authorisation components of all web based applications.",RESTful Web Services – A Question of Standards,"Roy Thomas Fielding defined the term REST as an architectural style for distributed hypermedia based systems in the year 2000. Since this initial definition, the term itself became a buzzword used in almost any web-related development. From simple, basic web applications, to highly complex web service/microservice-based solutions, almost everyone and everything talks REST and RESTful. Moreover, the Web context implies that these developments are usually realised over HTTP. In this paper, we first analyse the impact of this architectural style on distributed application development. A careless application of this model and its underlying HTTP standards could severely impact on the overall quality of any RESTful based solution. Following, we submit our own model for user data and session handling tasks to illustrate the correct approach to RESTful web service design techniques. This model offers all the advantages of the aforementioned architectural style while providing the required functionality for the authentication and authorisation components of all web based applications.",IEEE conference,no,"['restful', 'web', 'question', 'standard', 'defined', 'term', 'rest', 'architectural', 'style', 'distributed', 'based', 'year', 'since', 'initial', 'definition', 'term', 'became', 'used', 'almost', 'development', 'simple', 'basic', 'web', 'highly', 'complex', 'web', 'solution', 'almost', 'talk', 'rest', 'restful', 'moreover', 'web', 'context', 'development', 'usually', 'http', 'paper', 'first', 'analyse', 'impact', 'architectural', 'style', 'distributed', 'development', 'model', 'underlying', 'http', 'standard', 'could', 'impact', 'overall', 'quality', 'restful', 'based', 'solution', 'following', 'model', 'user', 'session', 'handling', 'task', 'illustrate', 'correct', 'restful', 'web', 'design', 'technique', 'model', 'offer', 'advantage', 'aforementioned', 'architectural', 'style', 'providing', 'required', 'functionality', 'authentication', 'web', 'based']"
"Pipekit: A Deployment Tool with Advanced Scheduling and Inter-Service Communication for Multi-Tier Applications Modern cloud applications are based on microservice architectures. The deployment of these microservice based applications often requires that every constituent service starts after all its dependencies are configured and running properly. It is also common that these dependencies generate dynamic data that needs to be supplied to other services too at starting time. More complex scenarios require additionally interchanging data in other phases of the microservices lifecycle. One alternative to solve these dependencies is to describe the deployment of microservice applications manually—using scripts—which allows IT operators to precisely define when a service is ready to start serving other components. However, synchronization by scripting is tedious, error prone and hard to maintain. Other solutions offer specific languages to describe service dependencies, along with tool support that interpret scripts in these languages to take care of starting services in the proper order. These tools are either very rich but complex to use, or fail in providing sophisticated ways to describe what it means for a service to be ready. Moreover, the communication layer between services, if supplied, is based on intermediate entities and non-trivial network protocols. This paper proposes pipekit as a solution, by offering a container orchestration language which focuses on simplicity (pipekit is similar to Docker Compose) and is equipped with directives to define when a service is ready. The pipekit tool provides a communication layer for moving data between services, implemented using shared storage. This shared storage provides a very simple interface to move artifacts between services, and greatly simplifies the synchronization logic of pipekit by using semaphores at the file system level.",Pipekit: A Deployment Tool with Advanced Scheduling and Inter-Service Communication for Multi-Tier Applications,"Modern cloud applications are based on microservice architectures. The deployment of these microservice based applications often requires that every constituent service starts after all its dependencies are configured and running properly. It is also common that these dependencies generate dynamic data that needs to be supplied to other services too at starting time. More complex scenarios require additionally interchanging data in other phases of the microservices lifecycle. One alternative to solve these dependencies is to describe the deployment of microservice applications manually—using scripts—which allows IT operators to precisely define when a service is ready to start serving other components. However, synchronization by scripting is tedious, error prone and hard to maintain. Other solutions offer specific languages to describe service dependencies, along with tool support that interpret scripts in these languages to take care of starting services in the proper order. These tools are either very rich but complex to use, or fail in providing sophisticated ways to describe what it means for a service to be ready. Moreover, the communication layer between services, if supplied, is based on intermediate entities and non-trivial network protocols. This paper proposes pipekit as a solution, by offering a container orchestration language which focuses on simplicity (pipekit is similar to Docker Compose) and is equipped with directives to define when a service is ready. The pipekit tool provides a communication layer for moving data between services, implemented using shared storage. This shared storage provides a very simple interface to move artifacts between services, and greatly simplifies the synchronization logic of pipekit by using semaphores at the file system level.",IEEE conference,no,"['pipekit', 'deployment', 'tool', 'advanced', 'scheduling', 'communication', 'modern', 'based', 'deployment', 'based', 'often', 'requires', 'every', 'constituent', 'start', 'dependency', 'running', 'properly', 'also', 'common', 'dependency', 'generate', 'dynamic', 'need', 'starting', 'time', 'complex', 'scenario', 'require', 'additionally', 'phase', 'lifecycle', 'one', 'alternative', 'solve', 'dependency', 'describe', 'deployment', 'allows', 'operator', 'precisely', 'define', 'ready', 'start', 'serving', 'however', 'synchronization', 'error', 'hard', 'maintain', 'solution', 'offer', 'specific', 'language', 'describe', 'dependency', 'along', 'tool', 'support', 'script', 'language', 'take', 'care', 'starting', 'proper', 'order', 'tool', 'either', 'rich', 'complex', 'use', 'fail', 'providing', 'sophisticated', 'way', 'describe', 'mean', 'ready', 'moreover', 'communication', 'layer', 'based', 'intermediate', 'entity', 'network', 'protocol', 'paper', 'proposes', 'pipekit', 'solution', 'offering', 'container', 'orchestration', 'language', 'focus', 'simplicity', 'pipekit', 'similar', 'docker', 'compose', 'equipped', 'define', 'ready', 'pipekit', 'tool', 'provides', 'communication', 'layer', 'moving', 'implemented', 'using', 'shared', 'storage', 'shared', 'storage', 'provides', 'simple', 'interface', 'move', 'artifact', 'greatly', 'simplifies', 'synchronization', 'logic', 'pipekit', 'using', 'file', 'level']"
"Microservices: Migration of a Mission Critical System An increasing interest is growing around the idea of microservices and the promise of improving scalability when compared to monolithic systems. Several companies are evaluating pros and cons of a complex migration. In particular, financial institutions are positioned in a difficult situation due to the economic climate and the appearance of agile competitors that can navigate in a more flexible legal framework and started their business since day one with more agile architectures and without being bounded to outdated technological standard. In this paper, we present a real world case study in order to demonstrate how scalability is positively affected by re-implementing a monolithic architecture (MA) into a microservices architecture (MSA). The case study is based on the FX Core system, a mission critical system of Danske Bank, the largest bank in Denmark and one of the leading financial institutions in Northern Europe. The technical problem that has been addressed and solved in this paper is the identification of a repeatable migration process that can be used to convert a real world Monolithic architecture into a Microservices architecture in the specific setting of financial domain, typically characterized by legacy systems and batch-based processing on heterogeneous data sources.",Microservices: Migration of a Mission Critical System,"An increasing interest is growing around the idea of microservices and the promise of improving scalability when compared to monolithic systems. Several companies are evaluating pros and cons of a complex migration. In particular, financial institutions are positioned in a difficult situation due to the economic climate and the appearance of agile competitors that can navigate in a more flexible legal framework and started their business since day one with more agile architectures and without being bounded to outdated technological standard. In this paper, we present a real world case study in order to demonstrate how scalability is positively affected by re-implementing a monolithic architecture (MA) into a microservices architecture (MSA). The case study is based on the FX Core system, a mission critical system of Danske Bank, the largest bank in Denmark and one of the leading financial institutions in Northern Europe. The technical problem that has been addressed and solved in this paper is the identification of a repeatable migration process that can be used to convert a real world Monolithic architecture into a Microservices architecture in the specific setting of financial domain, typically characterized by legacy systems and batch-based processing on heterogeneous data sources.",IEEE journal,no,"['migration', 'mission', 'critical', 'increasing', 'interest', 'growing', 'around', 'idea', 'promise', 'improving', 'scalability', 'compared', 'monolithic', 'several', 'company', 'evaluating', 'pro', 'con', 'complex', 'migration', 'particular', 'financial', 'institution', 'difficult', 'situation', 'due', 'economic', 'agile', 'flexible', 'framework', 'started', 'business', 'since', 'day', 'one', 'agile', 'without', 'bounded', 'technological', 'standard', 'paper', 'present', 'real', 'world', 'case', 'study', 'order', 'demonstrate', 'scalability', 'affected', 'monolithic', 'msa', 'case', 'study', 'based', 'core', 'mission', 'critical', 'bank', 'largest', 'bank', 'one', 'leading', 'financial', 'institution', 'technical', 'problem', 'addressed', 'solved', 'paper', 'identification', 'repeatable', 'migration', 'process', 'used', 'convert', 'real', 'world', 'monolithic', 'specific', 'setting', 'financial', 'domain', 'typically', 'characterized', 'legacy', 'processing', 'heterogeneous', 'source']"
"Detecting Inconsistencies in Microservice-Based Systems: An Annotation-Assisted Scenario-Oriented Approach Microservice architecture (MSA) has been widely adopted to develop various large-scale distributed systems. Microservice-based systems (MBSs) comprise a number of independently deployed microservices fulfilling the specific functionalities. Unique characteristics of microservices, such as independent and parallel development, rapid iteration, and distributed deployment, result in low observability and reliability of MBSs. A typical solution is to regulate system behavior in specifications of MBSs, and then develop and test MBSs based on these specifications. However, current microservice specifications focus on describing the APIs of microservices without describing the behavior expectation for an MBS. In this article, we propose an annotation-assisted and scenario-oriented approach, called MSA_Sighter, to detect behavior inconsistencies in MBSs. In MSA_Sighter, the details of an MBS are captured in a description model (MSDM), which can be extracted automatically from the functional services through annotation-assisted runtime component instance analysis and static program analysis. Given a specific business scenario, inconsistency detection is conducted by analyzing the actual behavior's conformance to the expected behavior, where the former is collected through distributed tracing while the latter is derived from the MSDM. We have developed a supporting tool called ConsChecker and evaluated MSA_Sighter's effectiveness on three open-source MBSs in GitHub. The experimental results have shown that MSA_Sighter can effectively detect inconsistencies in MBSs during system development and evolution.",Detecting Inconsistencies in Microservice-Based Systems: An Annotation-Assisted Scenario-Oriented Approach,"Microservice architecture (MSA) has been widely adopted to develop various large-scale distributed systems. Microservice-based systems (MBSs) comprise a number of independently deployed microservices fulfilling the specific functionalities. Unique characteristics of microservices, such as independent and parallel development, rapid iteration, and distributed deployment, result in low observability and reliability of MBSs. A typical solution is to regulate system behavior in specifications of MBSs, and then develop and test MBSs based on these specifications. However, current microservice specifications focus on describing the APIs of microservices without describing the behavior expectation for an MBS. In this article, we propose an annotation-assisted and scenario-oriented approach, called MSA_Sighter, to detect behavior inconsistencies in MBSs. In MSA_Sighter, the details of an MBS are captured in a description model (MSDM), which can be extracted automatically from the functional services through annotation-assisted runtime component instance analysis and static program analysis. Given a specific business scenario, inconsistency detection is conducted by analyzing the actual behavior's conformance to the expected behavior, where the former is collected through distributed tracing while the latter is derived from the MSDM. We have developed a supporting tool called ConsChecker and evaluated MSA_Sighter's effectiveness on three open-source MBSs in GitHub. The experimental results have shown that MSA_Sighter can effectively detect inconsistencies in MBSs during system development and evolution.",IEEE journal,no,"['detecting', 'inconsistency', 'msa', 'widely', 'adopted', 'develop', 'various', 'distributed', 'mbss', 'comprise', 'number', 'independently', 'deployed', 'fulfilling', 'specific', 'functionality', 'unique', 'characteristic', 'independent', 'parallel', 'development', 'rapid', 'iteration', 'distributed', 'deployment', 'result', 'low', 'observability', 'reliability', 'mbss', 'typical', 'solution', 'behavior', 'specification', 'mbss', 'develop', 'test', 'mbss', 'based', 'specification', 'however', 'current', 'specification', 'focus', 'describing', 'apis', 'without', 'describing', 'behavior', 'expectation', 'mb', 'article', 'propose', 'called', 'detect', 'behavior', 'inconsistency', 'mbss', 'detail', 'mb', 'captured', 'description', 'model', 'extracted', 'automatically', 'functional', 'runtime', 'instance', 'analysis', 'static', 'program', 'analysis', 'given', 'specific', 'business', 'scenario', 'inconsistency', 'detection', 'conducted', 'analyzing', 'actual', 'behavior', 'conformance', 'expected', 'behavior', 'collected', 'distributed', 'tracing', 'latter', 'derived', 'developed', 'supporting', 'tool', 'called', 'evaluated', 'effectiveness', 'three', 'mbss', 'github', 'experimental', 'result', 'shown', 'effectively', 'detect', 'inconsistency', 'mbss', 'development', 'evolution']"
"Servitization of Customized 3D Assets and Performance Comparison of Services and Microservices Implementations 3D models (or assets) that are present in many of modern software applications are first modeled by graphic designers using dedicated computer graphic tools and then integrated into such software applications or apps by software developers. This simple workflow/procedure requires developers to have a basic grounding in computer graphics, since 3D engines, libraries and third-party software are needed for this kind of integrations. Oftentimes, 3D designers are also required to customize or produce versions of a 3D model and thus, they must re-model all the assets before they are returned back to the developers for integration into the applications. This procedure also occurs whenever a modification or customization is requested. One possible significant improvement to this traditional, poorly automated workflow is to use services-oriented technology and features servitization to carry out the customization of 3D assets on-demand. In this article, we introduce $ \mu $μS3D, an open-source microservices-based platform designed to support features relating to the customization of 3D models. $ \mu $μS3D not only enables 3D assets to be customized without the need for computer graphic tools or designers, but also allows 3D models to be visualized through web technologies (e.g., HTML, Javascript and web component to visualize and interact with 3D models), thereby avoiding the development of computer graphics libraries or components in final software products. The article describes the elements that $ \mu $μS3D comprises, explains how it works and presents a series of load tests to compare the performance (time consumption, CPU and memory utilization) of $ \mu $μS3D when implemented and deployed as a microservices platform against a monolithic-based implementation, showing similar results with a low number of users (and requests) but reducing, on average, 64.32% the response time in the microservice-based implementation for a large number of users; reducing CPU utilization on microservice-based implementation and remaining the memory usage more or less constant in both implementations.",Servitization of Customized 3D Assets and Performance Comparison of Services and Microservices Implementations,"3D models (or assets) that are present in many of modern software applications are first modeled by graphic designers using dedicated computer graphic tools and then integrated into such software applications or apps by software developers. This simple workflow/procedure requires developers to have a basic grounding in computer graphics, since 3D engines, libraries and third-party software are needed for this kind of integrations. Oftentimes, 3D designers are also required to customize or produce versions of a 3D model and thus, they must re-model all the assets before they are returned back to the developers for integration into the applications. This procedure also occurs whenever a modification or customization is requested. One possible significant improvement to this traditional, poorly automated workflow is to use services-oriented technology and features servitization to carry out the customization of 3D assets on-demand. In this article, we introduce $ \mu $μS3D, an open-source microservices-based platform designed to support features relating to the customization of 3D models. $ \mu $μS3D not only enables 3D assets to be customized without the need for computer graphic tools or designers, but also allows 3D models to be visualized through web technologies (e.g., HTML, Javascript and web component to visualize and interact with 3D models), thereby avoiding the development of computer graphics libraries or components in final software products. The article describes the elements that $ \mu $μS3D comprises, explains how it works and presents a series of load tests to compare the performance (time consumption, CPU and memory utilization) of $ \mu $μS3D when implemented and deployed as a microservices platform against a monolithic-based implementation, showing similar results with a low number of users (and requests) but reducing, on average, 64.32% the response time in the microservice-based implementation for a large number of users; reducing CPU utilization on microservice-based implementation and remaining the memory usage more or less constant in both implementations.",IEEE journal,no,"['servitization', 'customized', 'asset', 'performance', 'comparison', 'implementation', 'model', 'asset', 'present', 'many', 'modern', 'first', 'modeled', 'graphic', 'designer', 'using', 'dedicated', 'computer', 'graphic', 'tool', 'integrated', 'apps', 'developer', 'simple', 'requires', 'developer', 'basic', 'computer', 'graphic', 'since', 'engine', 'library', 'needed', 'kind', 'integration', 'designer', 'also', 'required', 'customize', 'produce', 'version', 'model', 'thus', 'must', 'asset', 'back', 'developer', 'integration', 'procedure', 'also', 'occurs', 'modification', 'customization', 'requested', 'one', 'possible', 'significant', 'improvement', 'traditional', 'automated', 'workflow', 'use', 'technology', 'feature', 'servitization', 'carry', 'customization', 'asset', 'article', 'introduce', 'platform', 'designed', 'support', 'feature', 'customization', 'model', 'enables', 'asset', 'customized', 'without', 'need', 'computer', 'graphic', 'tool', 'designer', 'also', 'allows', 'model', 'web', 'technology', 'web', 'visualize', 'interact', 'model', 'thereby', 'avoiding', 'development', 'computer', 'graphic', 'library', 'final', 'product', 'article', 'describes', 'element', 'comprises', 'work', 'present', 'series', 'load', 'test', 'compare', 'performance', 'time', 'consumption', 'cpu', 'memory', 'utilization', 'implemented', 'deployed', 'platform', 'implementation', 'showing', 'similar', 'result', 'low', 'number', 'user', 'request', 'reducing', 'average', 'response', 'time', 'implementation', 'large', 'number', 'user', 'reducing', 'cpu', 'utilization', 'implementation', 'memory', 'usage', 'less', 'constant', 'implementation']"
"Advancing Static Code Analysis With Language-Agnostic Component Identification Static code analysis of software systems has proven beneficial for a broad range of domains, including security assessments, coding practice, error detection, and others. However, as modern systems have grown in complexity and heterogeneity over the past few decades, advances in development frameworks have dominated. Rather than involving low-level language constructs, these frameworks typically focus on software components, including data entities, controllers, and endpoints. As a result, current code analysis approaches have become unsuitable for analyzing these modern systems due to their focus on low-level constructs in a single language. Thus, code analysis has become a far more complicated endeavor thanks to the plethora of languages, frameworks, and design approaches in modern software development. This paper presents a novel approach to solving the problem of being tied to a single language and its low-level constructs. The system’s source code is transformed into an intermediate representation called a language-agnostic abstract-syntax tree. This system representation is then assessed by generalized component parsers that extract relevant high-level information, such as components, from low-level structures. The design of the approach is presented here in detail, along with its evaluation in a case study involving two large, heterogeneous, cloud-native system benchmarks (Java and C++ microservices). The study demonstrates a unified identification approach to determine system data entities and endpoints. Utilizing higher-level constructs, such as components, can advance the current practice of system analysis to better face broader problems introduced by modern system development practices.",Advancing Static Code Analysis With Language-Agnostic Component Identification,"Static code analysis of software systems has proven beneficial for a broad range of domains, including security assessments, coding practice, error detection, and others. However, as modern systems have grown in complexity and heterogeneity over the past few decades, advances in development frameworks have dominated. Rather than involving low-level language constructs, these frameworks typically focus on software components, including data entities, controllers, and endpoints. As a result, current code analysis approaches have become unsuitable for analyzing these modern systems due to their focus on low-level constructs in a single language. Thus, code analysis has become a far more complicated endeavor thanks to the plethora of languages, frameworks, and design approaches in modern software development. This paper presents a novel approach to solving the problem of being tied to a single language and its low-level constructs. The system’s source code is transformed into an intermediate representation called a language-agnostic abstract-syntax tree. This system representation is then assessed by generalized component parsers that extract relevant high-level information, such as components, from low-level structures. The design of the approach is presented here in detail, along with its evaluation in a case study involving two large, heterogeneous, cloud-native system benchmarks (Java and C++ microservices). The study demonstrates a unified identification approach to determine system data entities and endpoints. Utilizing higher-level constructs, such as components, can advance the current practice of system analysis to better face broader problems introduced by modern system development practices.",IEEE journal,no,"['static', 'code', 'analysis', 'identification', 'static', 'code', 'analysis', 'proven', 'beneficial', 'broad', 'range', 'domain', 'including', 'security', 'assessment', 'coding', 'practice', 'error', 'detection', 'others', 'however', 'modern', 'complexity', 'heterogeneity', 'past', 'decade', 'advance', 'development', 'framework', 'rather', 'involving', 'language', 'construct', 'framework', 'typically', 'focus', 'including', 'entity', 'controller', 'endpoint', 'result', 'current', 'code', 'analysis', 'become', 'analyzing', 'modern', 'due', 'focus', 'construct', 'single', 'language', 'thus', 'code', 'analysis', 'become', 'far', 'complicated', 'thanks', 'plethora', 'language', 'framework', 'design', 'modern', 'development', 'paper', 'present', 'novel', 'solving', 'problem', 'single', 'language', 'construct', 'source', 'code', 'transformed', 'intermediate', 'representation', 'called', 'tree', 'representation', 'assessed', 'extract', 'relevant', 'information', 'structure', 'design', 'presented', 'detail', 'along', 'evaluation', 'case', 'study', 'involving', 'two', 'large', 'heterogeneous', 'benchmark', 'java', 'study', 'demonstrates', 'unified', 'identification', 'determine', 'entity', 'endpoint', 'utilizing', 'construct', 'advance', 'current', 'practice', 'analysis', 'better', 'face', 'broader', 'problem', 'introduced', 'modern', 'development', 'practice']"
"On Code Analysis Opportunities and Challenges for Enterprise Systems and Microservices Code analysis brings excellent benefits to software development, maintenance, and quality assurance. Various tools can uncover code defects or even software bugs in a range of seconds. For many projects and developers, the code analysis tools became essential in their daily routines. However, how can code analysis help in an enterprise environment? Enterprise software solutions grow in scale and complexity. These solutions no longer involve only plain objects and basic language constructs but operate with various components and mechanisms simplifying the development of such systems. Enterprise software vendors have adopted various development and design standards; however, there is a gap between what constructs the enterprise frameworks use and what current code analysis tools recognize. This manuscript aims to challenge the mainstream research directions of code analysis and motivate for a transition towards code analysis of enterprise systems with interesting problems and opportunities. In particular, this manuscript addresses selected enterprise problems apparent for monolithic and distributed enterprise solutions. It also considers challenges related to the recent architectural push towards a microservice architecture. Along with open-source proof-of-concept prototypes to some of the challenges, this manuscript elaborates on code analysis directions and their categorization. Furthermore, it suggests one possible perspective of the problem area using aspect-oriented programming.",On Code Analysis Opportunities and Challenges for Enterprise Systems and Microservices,"Code analysis brings excellent benefits to software development, maintenance, and quality assurance. Various tools can uncover code defects or even software bugs in a range of seconds. For many projects and developers, the code analysis tools became essential in their daily routines. However, how can code analysis help in an enterprise environment? Enterprise software solutions grow in scale and complexity. These solutions no longer involve only plain objects and basic language constructs but operate with various components and mechanisms simplifying the development of such systems. Enterprise software vendors have adopted various development and design standards; however, there is a gap between what constructs the enterprise frameworks use and what current code analysis tools recognize. This manuscript aims to challenge the mainstream research directions of code analysis and motivate for a transition towards code analysis of enterprise systems with interesting problems and opportunities. In particular, this manuscript addresses selected enterprise problems apparent for monolithic and distributed enterprise solutions. It also considers challenges related to the recent architectural push towards a microservice architecture. Along with open-source proof-of-concept prototypes to some of the challenges, this manuscript elaborates on code analysis directions and their categorization. Furthermore, it suggests one possible perspective of the problem area using aspect-oriented programming.",IEEE journal,no,"['code', 'analysis', 'opportunity', 'challenge', 'enterprise', 'code', 'analysis', 'brings', 'excellent', 'benefit', 'development', 'maintenance', 'quality', 'assurance', 'various', 'tool', 'code', 'even', 'bug', 'range', 'second', 'many', 'project', 'developer', 'code', 'analysis', 'tool', 'became', 'essential', 'daily', 'however', 'code', 'analysis', 'help', 'enterprise', 'environment', 'enterprise', 'solution', 'grow', 'scale', 'complexity', 'solution', 'longer', 'involve', 'object', 'basic', 'language', 'construct', 'operate', 'various', 'mechanism', 'development', 'enterprise', 'vendor', 'adopted', 'various', 'development', 'design', 'standard', 'however', 'gap', 'construct', 'enterprise', 'framework', 'use', 'current', 'code', 'analysis', 'tool', 'manuscript', 'aim', 'challenge', 'research', 'direction', 'code', 'analysis', 'motivate', 'transition', 'towards', 'code', 'analysis', 'enterprise', 'problem', 'opportunity', 'particular', 'manuscript', 'address', 'selected', 'enterprise', 'problem', 'apparent', 'monolithic', 'distributed', 'enterprise', 'solution', 'also', 'considers', 'challenge', 'related', 'recent', 'architectural', 'push', 'towards', 'along', 'prototype', 'challenge', 'manuscript', 'elaborates', 'code', 'analysis', 'direction', 'furthermore', 'suggests', 'one', 'possible', 'perspective', 'problem', 'area', 'using', 'programming']"
"Decision as a Service for Transaction Banking Using Service-Oriented Modeling Architecture Methodology In order to gain a competitive edge in the banking industry, direct face-to-face interactions between customers and banks are being gradually replaced by virtual interactions. Instead, they communicate using electronic devices such as smartphones, tablets, and web applications. Transaction banking, which provides commercial services for banking products to small, medium, and large corporations, is a highly typical work unit in banking. Shipping and international payments, risk management for international trade, and other services are provided. We use the Service Oriented Modelling Architecture (SOMA) methodology to solve the problem of the transaction banking unit by relocating it from a system with general dependencies to a system that is independent of the entire service and operates on a small function scale. The study found that a decision as a service (DAAS) model with an Enterprise Service Bus (ESB), Business Process Management (BPM), and Business Rule Management (BRM) solution can provide guidelines for the design of decision rules pertaining to integrated or separate business modeling, thereby aiding business unit delivery.",Decision as a Service for Transaction Banking Using Service-Oriented Modeling Architecture Methodology,"In order to gain a competitive edge in the banking industry, direct face-to-face interactions between customers and banks are being gradually replaced by virtual interactions. Instead, they communicate using electronic devices such as smartphones, tablets, and web applications. Transaction banking, which provides commercial services for banking products to small, medium, and large corporations, is a highly typical work unit in banking. Shipping and international payments, risk management for international trade, and other services are provided. We use the Service Oriented Modelling Architecture (SOMA) methodology to solve the problem of the transaction banking unit by relocating it from a system with general dependencies to a system that is independent of the entire service and operates on a small function scale. The study found that a decision as a service (DAAS) model with an Enterprise Service Bus (ESB), Business Process Management (BPM), and Business Rule Management (BRM) solution can provide guidelines for the design of decision rules pertaining to integrated or separate business modeling, thereby aiding business unit delivery.",IEEE journal,no,"['decision', 'transaction', 'banking', 'using', 'modeling', 'methodology', 'order', 'gain', 'competitive', 'edge', 'banking', 'industry', 'direct', 'interaction', 'customer', 'bank', 'gradually', 'replaced', 'virtual', 'interaction', 'instead', 'communicate', 'using', 'electronic', 'device', 'web', 'transaction', 'banking', 'provides', 'commercial', 'banking', 'product', 'small', 'medium', 'large', 'corporation', 'highly', 'typical', 'work', 'unit', 'banking', 'international', 'payment', 'risk', 'management', 'international', 'provided', 'use', 'oriented', 'modelling', 'methodology', 'solve', 'problem', 'transaction', 'banking', 'unit', 'general', 'dependency', 'independent', 'entire', 'operates', 'small', 'function', 'scale', 'study', 'found', 'decision', 'model', 'enterprise', 'bus', 'business', 'process', 'management', 'business', 'rule', 'management', 'solution', 'provide', 'guideline', 'design', 'decision', 'rule', 'integrated', 'separate', 'business', 'modeling', 'thereby', 'business', 'unit', 'delivery']"
"Enhancing Performance of Distributed Transactions in Microservices via Buffered Serialization Although the Microservices Architecture comes with a number of benefits, it is a challenge to design an efficient transaction management for multi-agent transactions that span across multiple services. Since microservices design require a loose coupling between service logic and resources, data used by a distributed transaction is spread across different nodes, there is need to an effective way to ensure data portability, speed consistency for transaction in microservices. Therefore this research addresses both the issue of improving transaction performance and maintaining data portability for distributed transactions in microservices. A novel approach to transaction management termed ‘buffered serialization’ is proposed in this research as a way to improve transaction management by the use serialization libraries. This work has a three-part objective which are (1) to highlight the challenges of distributed transaction management in microservices, (2) to propose an enhanced approach to transaction management through the use of buffered serialization between services (3) to provide a proof of concept for this novel approach. Obtained result indicate a 60% improvement in transaction failure recovery time, 10% higher success rate for load tests but an insignificantly higher resource utilization values.",Enhancing Performance of Distributed Transactions in Microservices via Buffered Serialization,"Although the Microservices Architecture comes with a number of benefits, it is a challenge to design an efficient transaction management for multi-agent transactions that span across multiple services. Since microservices design require a loose coupling between service logic and resources, data used by a distributed transaction is spread across different nodes, there is need to an effective way to ensure data portability, speed consistency for transaction in microservices. Therefore this research addresses both the issue of improving transaction performance and maintaining data portability for distributed transactions in microservices. A novel approach to transaction management termed ‘buffered serialization’ is proposed in this research as a way to improve transaction management by the use serialization libraries. This work has a three-part objective which are (1) to highlight the challenges of distributed transaction management in microservices, (2) to propose an enhanced approach to transaction management through the use of buffered serialization between services (3) to provide a proof of concept for this novel approach. Obtained result indicate a 60% improvement in transaction failure recovery time, 10% higher success rate for load tests but an insignificantly higher resource utilization values.",IEEE journal,no,"['enhancing', 'performance', 'distributed', 'transaction', 'via', 'buffered', 'serialization', 'although', 'come', 'number', 'benefit', 'challenge', 'design', 'efficient', 'transaction', 'management', 'transaction', 'span', 'across', 'multiple', 'since', 'design', 'require', 'coupling', 'logic', 'resource', 'used', 'distributed', 'transaction', 'spread', 'across', 'different', 'node', 'need', 'effective', 'way', 'ensure', 'portability', 'speed', 'consistency', 'transaction', 'therefore', 'research', 'address', 'issue', 'improving', 'transaction', 'performance', 'maintaining', 'portability', 'distributed', 'transaction', 'novel', 'transaction', 'management', 'buffered', 'serialization', 'proposed', 'research', 'way', 'improve', 'transaction', 'management', 'use', 'serialization', 'library', 'work', 'objective', 'highlight', 'challenge', 'distributed', 'transaction', 'management', 'propose', 'enhanced', 'transaction', 'management', 'use', 'buffered', 'serialization', 'provide', 'proof', 'concept', 'novel', 'obtained', 'result', 'indicate', 'improvement', 'transaction', 'failure', 'recovery', 'time', 'higher', 'success', 'rate', 'load', 'test', 'higher', 'resource', 'utilization', 'value']"
"A Choreography Analysis Approach for Microservice Composition in Cyber-Physical-Social Systems Choreography-driven microservice composition has provided a better way to integrate components in the Cyber-physical-Social System (CPSS). Choreography is a global contract that specifies interactions among microservices participating in a composite service. After modeling a choreography, a problem arises here is whether the choreography specification at design time can be implemented correctly by generated microservices that interact with each other via exchanging messages. In this paper, we propose a novel approach for choreography analysis. Specifically, a choreography is specified using a Labeled Transition Systems (LTSs); then, the microservices participating in a composite service can be generated from the given choreography via projection and  $\varepsilon $ -remove; finally, the analysis of the choreography can be checked for both synchronous and asynchronous compositions using refinement checking. Our approach is completely automated under the support of our developed tool and the Process Analysis Toolkit (PAT) tool.",A Choreography Analysis Approach for Microservice Composition in Cyber-Physical-Social Systems,"Choreography-driven microservice composition has provided a better way to integrate components in the Cyber-physical-Social System (CPSS). Choreography is a global contract that specifies interactions among microservices participating in a composite service. After modeling a choreography, a problem arises here is whether the choreography specification at design time can be implemented correctly by generated microservices that interact with each other via exchanging messages. In this paper, we propose a novel approach for choreography analysis. Specifically, a choreography is specified using a Labeled Transition Systems (LTSs); then, the microservices participating in a composite service can be generated from the given choreography via projection and  $\varepsilon $ -remove; finally, the analysis of the choreography can be checked for both synchronous and asynchronous compositions using refinement checking. Our approach is completely automated under the support of our developed tool and the Process Analysis Toolkit (PAT) tool.",IEEE journal,no,"['choreography', 'analysis', 'composition', 'composition', 'provided', 'better', 'way', 'integrate', 'cps', 'choreography', 'global', 'interaction', 'among', 'participating', 'composite', 'modeling', 'choreography', 'problem', 'arises', 'whether', 'choreography', 'specification', 'design', 'time', 'implemented', 'correctly', 'generated', 'interact', 'via', 'message', 'paper', 'propose', 'novel', 'choreography', 'analysis', 'specifically', 'choreography', 'specified', 'using', 'transition', 'participating', 'composite', 'generated', 'given', 'choreography', 'via', 'finally', 'analysis', 'choreography', 'synchronous', 'asynchronous', 'composition', 'using', 'refinement', 'checking', 'completely', 'automated', 'support', 'developed', 'tool', 'process', 'analysis', 'toolkit', 'tool']"
"Building Microservices with Micronaut®: A quick-start guide to building high-performance reactive microservices for Java developers Explore different aspects of building modular microservices such as development, testing, maintenance, and deployment using the Micronaut frameworkKey FeaturesLearn how to build scalable, fast, and resilient microservices with this concise guideExplore the many advantages of using reflection-free, compile-time dependency injections and aspect-oriented programmingBuild cloud-native applications easily with the Micronaut frameworkBook DescriptionThe open source Micronaut® framework is a JVM-based toolkit designed to create microservices quickly and easily. This book will help full-stack and Java developers build modular, high-performing, and reactive microservice-based apps using the Micronaut framework. You'll start by building microservices and learning about the core components, such as ahead-of-time compilation, reflection-less dependency injection, and reactive baked-in HTTP clients and servers. Next, you will work on a real-time microservice application and learn how to integrate Micronaut projects with different kinds of relational and non-relational databases. You'll also learn how to employ different security mechanisms to safeguard your microservices and integrate microservices using event-driven architecture in the Apache Kafka ecosystem. As you advance, you'll get to grips with automated testing and popular testing tools. The book will help you understand how you can easily handle microservice concerns in Micronaut projects, such as service discovery, API documentation, distributed configuration management, fallbacks, and circuit breakers. Finally, you'll explore the deployment and maintenance aspects of microservices and get up to speed with the Internet of Things (IoT) using the Framework. By the end of this book, you'll be able to build, test, deploy, and maintain your own microservice apps using the framework.What you will learnUnderstand why the Micronaut framework is best suited for building microservicesBuild web endpoints and services in the Micronaut frameworkSafeguard microservices using Session, JWT, and OAuth in Micronaut projectsGet to grips with event-driven architecture in Micronaut applicationsDiscover how to automate testing at various levels using built-in tools and testing frameworksDeploy your microservices to containers and cloud platformsBecome well-versed with distributed logging, tracing, and monitoring in Micronaut projectsGet hands-on with the IoT using Alexa and the Micronaut frameworkWho this book is forThis book is for developers who have been building microservices on traditional frameworks such as Spring Boot and are looking for a faster alternative. Intermediate-level knowledge of Java programming and implementing web services development in Java is required.",Building Microservices with Micronaut®: A quick-start guide to building high-performance reactive microservices for Java developers,"Explore different aspects of building modular microservices such as development, testing, maintenance, and deployment using the Micronaut frameworkKey FeaturesLearn how to build scalable, fast, and resilient microservices with this concise guideExplore the many advantages of using reflection-free, compile-time dependency injections and aspect-oriented programmingBuild cloud-native applications easily with the Micronaut frameworkBook DescriptionThe open source Micronaut® framework is a JVM-based toolkit designed to create microservices quickly and easily. This book will help full-stack and Java developers build modular, high-performing, and reactive microservice-based apps using the Micronaut framework. You'll start by building microservices and learning about the core components, such as ahead-of-time compilation, reflection-less dependency injection, and reactive baked-in HTTP clients and servers. Next, you will work on a real-time microservice application and learn how to integrate Micronaut projects with different kinds of relational and non-relational databases. You'll also learn how to employ different security mechanisms to safeguard your microservices and integrate microservices using event-driven architecture in the Apache Kafka ecosystem. As you advance, you'll get to grips with automated testing and popular testing tools. The book will help you understand how you can easily handle microservice concerns in Micronaut projects, such as service discovery, API documentation, distributed configuration management, fallbacks, and circuit breakers. Finally, you'll explore the deployment and maintenance aspects of microservices and get up to speed with the Internet of Things (IoT) using the Framework. By the end of this book, you'll be able to build, test, deploy, and maintain your own microservice apps using the framework.What you will learnUnderstand why the Micronaut framework is best suited for building microservicesBuild web endpoints and services in the Micronaut frameworkSafeguard microservices using Session, JWT, and OAuth in Micronaut projectsGet to grips with event-driven architecture in Micronaut applicationsDiscover how to automate testing at various levels using built-in tools and testing frameworksDeploy your microservices to containers and cloud platformsBecome well-versed with distributed logging, tracing, and monitoring in Micronaut projectsGet hands-on with the IoT using Alexa and the Micronaut frameworkWho this book is forThis book is for developers who have been building microservices on traditional frameworks such as Spring Boot and are looking for a faster alternative. Intermediate-level knowledge of Java programming and implementing web services development in Java is required.",IEEE book,no,"['building', 'guide', 'building', 'reactive', 'java', 'developer', 'explore', 'different', 'aspect', 'building', 'modular', 'development', 'testing', 'maintenance', 'deployment', 'using', 'micronaut', 'featureslearn', 'build', 'scalable', 'fast', 'resilient', 'many', 'advantage', 'using', 'dependency', 'injection', 'easily', 'micronaut', 'open', 'source', 'framework', 'toolkit', 'designed', 'create', 'quickly', 'easily', 'book', 'help', 'java', 'developer', 'build', 'modular', 'reactive', 'apps', 'using', 'micronaut', 'framework', 'start', 'building', 'learning', 'core', 'dependency', 'injection', 'reactive', 'http', 'client', 'server', 'next', 'work', 'learn', 'integrate', 'micronaut', 'project', 'different', 'kind', 'relational', 'database', 'also', 'learn', 'employ', 'different', 'security', 'mechanism', 'integrate', 'using', 'apache', 'kafka', 'ecosystem', 'advance', 'get', 'grip', 'automated', 'testing', 'popular', 'testing', 'tool', 'book', 'help', 'understand', 'easily', 'handle', 'concern', 'micronaut', 'project', 'discovery', 'api', 'documentation', 'distributed', 'configuration', 'management', 'circuit', 'finally', 'explore', 'deployment', 'maintenance', 'aspect', 'get', 'speed', 'internet', 'thing', 'iot', 'using', 'framework', 'end', 'book', 'able', 'build', 'test', 'deploy', 'maintain', 'apps', 'using', 'learnunderstand', 'micronaut', 'framework', 'best', 'suited', 'building', 'web', 'endpoint', 'micronaut', 'using', 'session', 'micronaut', 'grip', 'micronaut', 'automate', 'testing', 'various', 'level', 'using', 'tool', 'testing', 'container', 'distributed', 'logging', 'tracing', 'monitoring', 'micronaut', 'iot', 'using', 'micronaut', 'book', 'forthis', 'book', 'developer', 'building', 'traditional', 'framework', 'spring', 'boot', 'looking', 'faster', 'alternative', 'knowledge', 'java', 'programming', 'implementing', 'web', 'development', 'java', 'required']"
"Pragmatic Microservices with C# and Azure: Build, deploy, and scale microservices efficiently to meet modern software demands Unlock efficiency in software development by learning microservices with C# and Azure Key FeaturesGain step-by-step project-based guidance on how to develop a full-fledged microservices applicationGain extensive knowledge of microservices by covering essential concepts, tools, and methodologiesAcquire skills to deploy and manage microservices on MS AzurePurchase of the print or Kindle book includes a free PDF eBookBook DescriptionThis book introduces .NET Aspire and its features for developing microservices. It delves into defining an app model for an application's services, using service discovery, and integrating components locally and via native cloud services with Azure. It offers practical insights and hands-on experience, exploring microservices concepts in ASP.NET Core. You’ll learn how to develop robust services using .NET features such as minimal APIs, gRPC, and SignalR for real-time communication. The book also covers essential aspects of DevOps, testing methodologies including unit, integration, and load testing, and logging and monitoring including OpenTelemetry using tools such as Azure Log Analytics, Application Insights, Prometheus, and Grafana. You'll understand how asynchronous communication leveraging queues and events is facilitated through Azure Event Hub and Apache. Throughout the book, you’ll not only discover the theoretical aspects but also gain practical skills by building and deploying a fully functional microservices-based application. By the end of this book, you’ll have a deep understanding of microservices architecture, hands-on experience with various .NET technologies and Azure services, and the ability to design, build, deploy, and manage microservices applications effectively in both on-premises and cloud environments.What you will learnUnderstand microservices architecture benefitsUtilize the cloud-ready .NET Aspire stack along with its associated tools and librariesDevelop REST APIs with ASP.NET Core minimal APIsImplement database integration with relational and NoSQL databasesContainerize microservices using DockerDeploy microservices to the Azure Container Apps environment and KubernetesConfigure logging, monitoring, and tracing for microservicesUse advanced communication patterns with SignalR, gRPC, queues, and eventsWho this book is forThis book is for software developers, architects, and engineers who are interested in adopting microservices architecture using the .NET framework and Microsoft Azure. Both intermediate and advanced developers who have a foundational understanding of C#, ASP.NET Core, and cloud computing concepts will find this book helpful. ","Pragmatic Microservices with C# and Azure: Build, deploy, and scale microservices efficiently to meet modern software demands","Unlock efficiency in software development by learning microservices with C# and Azure Key FeaturesGain step-by-step project-based guidance on how to develop a full-fledged microservices applicationGain extensive knowledge of microservices by covering essential concepts, tools, and methodologiesAcquire skills to deploy and manage microservices on MS AzurePurchase of the print or Kindle book includes a free PDF eBookBook DescriptionThis book introduces .NET Aspire and its features for developing microservices. It delves into defining an app model for an application's services, using service discovery, and integrating components locally and via native cloud services with Azure. It offers practical insights and hands-on experience, exploring microservices concepts in ASP.NET Core. You’ll learn how to develop robust services using .NET features such as minimal APIs, gRPC, and SignalR for real-time communication. The book also covers essential aspects of DevOps, testing methodologies including unit, integration, and load testing, and logging and monitoring including OpenTelemetry using tools such as Azure Log Analytics, Application Insights, Prometheus, and Grafana. You'll understand how asynchronous communication leveraging queues and events is facilitated through Azure Event Hub and Apache. Throughout the book, you’ll not only discover the theoretical aspects but also gain practical skills by building and deploying a fully functional microservices-based application. By the end of this book, you’ll have a deep understanding of microservices architecture, hands-on experience with various .NET technologies and Azure services, and the ability to design, build, deploy, and manage microservices applications effectively in both on-premises and cloud environments.What you will learnUnderstand microservices architecture benefitsUtilize the cloud-ready .NET Aspire stack along with its associated tools and librariesDevelop REST APIs with ASP.NET Core minimal APIsImplement database integration with relational and NoSQL databasesContainerize microservices using DockerDeploy microservices to the Azure Container Apps environment and KubernetesConfigure logging, monitoring, and tracing for microservicesUse advanced communication patterns with SignalR, gRPC, queues, and eventsWho this book is forThis book is for software developers, architects, and engineers who are interested in adopting microservices architecture using the .NET framework and Microsoft Azure. Both intermediate and advanced developers who have a foundational understanding of C#, ASP.NET Core, and cloud computing concepts will find this book helpful. ",IEEE book,no,"['pragmatic', 'c', 'azure', 'build', 'deploy', 'scale', 'efficiently', 'meet', 'modern', 'demand', 'efficiency', 'development', 'learning', 'c', 'azure', 'key', 'guidance', 'develop', 'extensive', 'knowledge', 'covering', 'essential', 'concept', 'tool', 'skill', 'deploy', 'manage', 'm', 'book', 'includes', 'free', 'book', 'introduces', 'feature', 'developing', 'delf', 'defining', 'app', 'model', 'using', 'discovery', 'integrating', 'locally', 'via', 'native', 'azure', 'offer', 'practical', 'insight', 'experience', 'exploring', 'concept', 'core', 'learn', 'develop', 'robust', 'using', 'feature', 'minimal', 'apis', 'grpc', 'communication', 'book', 'also', 'cover', 'essential', 'aspect', 'devops', 'testing', 'methodology', 'including', 'unit', 'integration', 'load', 'testing', 'logging', 'monitoring', 'including', 'using', 'tool', 'azure', 'log', 'analytics', 'insight', 'prometheus', 'grafana', 'understand', 'asynchronous', 'communication', 'leveraging', 'queue', 'event', 'facilitated', 'azure', 'event', 'hub', 'apache', 'throughout', 'book', 'discover', 'aspect', 'also', 'gain', 'practical', 'skill', 'building', 'deploying', 'fully', 'functional', 'end', 'book', 'deep', 'understanding', 'experience', 'various', 'technology', 'azure', 'ability', 'design', 'build', 'deploy', 'manage', 'effectively', 'learnunderstand', 'stack', 'along', 'associated', 'tool', 'rest', 'apis', 'core', 'minimal', 'database', 'integration', 'relational', 'nosql', 'using', 'azure', 'container', 'apps', 'environment', 'logging', 'monitoring', 'tracing', 'advanced', 'communication', 'pattern', 'grpc', 'queue', 'book', 'forthis', 'book', 'developer', 'architect', 'engineer', 'interested', 'adopting', 'using', 'framework', 'microsoft', 'azure', 'intermediate', 'advanced', 'developer', 'understanding', 'c', 'core', 'computing', 'concept', 'find', 'book', 'helpful']"
"Implementing Event-Driven Microservices Architecture in .NET 7: Develop event-based distributed apps that can scale with ever-changing business demands using C# 11 and .NET 7 Implement modern design patterns that leverage domain-driven data, to achieve resiliency and scalability for data-dependent applicationsKey FeaturesLearn the tenets of event-driven architecture, coupled with reliable design patterns to enhance your knowledge of distributed systems and build a foundation for professional growthUnderstand how to translate business goals and drivers into a domain model that can be used to develop an app that enables those goals and driversIdentify areas to enhance development and ensure operational support through the architectural design processBook DescriptionThis book will guide you through various hands-on practical examples for implementing event-driven microservices architecture using C# 11 and .NET 7. It has been divided into three distinct sections, each focusing on different aspects of this implementation. The first section will cover the new features of .NET 7 that will make developing applications using EDA patterns easier, the sample application that will be used throughout the book, and how the core tenets of domain-driven design (DDD) are implemented in .NET 7. The second section will review the various components of a local environment setup, the containerization of code, testing, deployment, and the observability of microservices using an EDA approach. The third section will guide you through the need for scalability and service resilience within the application, along with implementation details related to elastic and autoscale components. You’ll also cover how proper telemetry helps to automatically drive scaling events. In addition, the topic of observability is revisited using examples of service discovery and microservice inventories. By the end of this book, you’ll be able to identify and catalog domains, events, and bounded contexts to be used for the design and development of a resilient microservices architecture.What you will learnExplore .NET 7 and how it enables the development of applications using EDAUnderstand messaging protocols and producer/consumer patterns and how to implement them in .NET 7Test and deploy applications written in .NET 7 and designed using EDA principlesAccount for scaling and resiliency in microservicesCollect and learn from telemetry at the platform and application levelGet to grips with the testing and deployment of microservicesWho this book is forThis book will help .NET developers and architects looking to leverage or pivot to microservices while using a domain-driven event model.",Implementing Event-Driven Microservices Architecture in .NET 7: Develop event-based distributed apps that can scale with ever-changing business demands using C# 11 and .NET 7,"Implement modern design patterns that leverage domain-driven data, to achieve resiliency and scalability for data-dependent applicationsKey FeaturesLearn the tenets of event-driven architecture, coupled with reliable design patterns to enhance your knowledge of distributed systems and build a foundation for professional growthUnderstand how to translate business goals and drivers into a domain model that can be used to develop an app that enables those goals and driversIdentify areas to enhance development and ensure operational support through the architectural design processBook DescriptionThis book will guide you through various hands-on practical examples for implementing event-driven microservices architecture using C# 11 and .NET 7. It has been divided into three distinct sections, each focusing on different aspects of this implementation. The first section will cover the new features of .NET 7 that will make developing applications using EDA patterns easier, the sample application that will be used throughout the book, and how the core tenets of domain-driven design (DDD) are implemented in .NET 7. The second section will review the various components of a local environment setup, the containerization of code, testing, deployment, and the observability of microservices using an EDA approach. The third section will guide you through the need for scalability and service resilience within the application, along with implementation details related to elastic and autoscale components. You’ll also cover how proper telemetry helps to automatically drive scaling events. In addition, the topic of observability is revisited using examples of service discovery and microservice inventories. By the end of this book, you’ll be able to identify and catalog domains, events, and bounded contexts to be used for the design and development of a resilient microservices architecture.What you will learnExplore .NET 7 and how it enables the development of applications using EDAUnderstand messaging protocols and producer/consumer patterns and how to implement them in .NET 7Test and deploy applications written in .NET 7 and designed using EDA principlesAccount for scaling and resiliency in microservicesCollect and learn from telemetry at the platform and application levelGet to grips with the testing and deployment of microservicesWho this book is forThis book will help .NET developers and architects looking to leverage or pivot to microservices while using a domain-driven event model.",IEEE book,no,"['implementing', 'develop', 'distributed', 'apps', 'scale', 'business', 'demand', 'using', 'c', 'implement', 'modern', 'design', 'pattern', 'leverage', 'achieve', 'resiliency', 'scalability', 'featureslearn', 'tenet', 'coupled', 'reliable', 'design', 'pattern', 'enhance', 'knowledge', 'distributed', 'build', 'foundation', 'professional', 'business', 'goal', 'driver', 'domain', 'model', 'used', 'develop', 'app', 'enables', 'goal', 'area', 'enhance', 'development', 'ensure', 'operational', 'support', 'architectural', 'design', 'book', 'guide', 'various', 'practical', 'example', 'implementing', 'using', 'c', 'divided', 'three', 'distinct', 'section', 'focusing', 'different', 'aspect', 'implementation', 'first', 'section', 'cover', 'new', 'feature', 'make', 'developing', 'using', 'eda', 'pattern', 'easier', 'sample', 'used', 'throughout', 'book', 'core', 'tenet', 'design', 'implemented', 'second', 'section', 'review', 'various', 'local', 'environment', 'setup', 'containerization', 'code', 'testing', 'deployment', 'observability', 'using', 'eda', 'third', 'section', 'guide', 'need', 'scalability', 'resilience', 'within', 'along', 'implementation', 'detail', 'related', 'elastic', 'also', 'cover', 'proper', 'telemetry', 'help', 'automatically', 'drive', 'scaling', 'event', 'addition', 'topic', 'observability', 'using', 'example', 'discovery', 'end', 'book', 'able', 'identify', 'domain', 'event', 'bounded', 'context', 'used', 'design', 'development', 'resilient', 'enables', 'development', 'using', 'messaging', 'protocol', 'pattern', 'implement', 'deploy', 'written', 'designed', 'using', 'eda', 'scaling', 'resiliency', 'learn', 'telemetry', 'platform', 'grip', 'testing', 'deployment', 'book', 'forthis', 'book', 'help', 'developer', 'architect', 'looking', 'leverage', 'using', 'event', 'model']"
"Software Architecture with C++: Design modern systems using effective architecture concepts, design patterns, and techniques with C++20 Apply business requirements to IT infrastructure and deliver a high-quality product by understanding architectures such as microservices, DevOps, and cloud-native using modern C++ standards and featuresKey FeaturesDesign scalable large-scale applications with the C++ programming languageArchitect software solutions in a cloud-based environment with continuous integration and continuous delivery (CI/CD)Achieve architectural goals by leveraging design patterns, language features, and useful toolsBook DescriptionSoftware architecture refers to the high-level design of complex applications. It is evolving just like the languages we use, but there are architectural concepts and patterns that you can learn to write high-performance apps in a high-level language without sacrificing readability and maintainability. If you're working with modern C++, this practical guide will help you put your knowledge to work and design distributed, large-scale apps. You'll start by getting up to speed with architectural concepts, including established patterns and rising trends, then move on to understanding what software architecture actually is and start exploring its components. Next, you'll discover the design concepts involved in application architecture and the patterns in software development, before going on to learn how to build, package, integrate, and deploy your components. In the concluding chapters, you'll explore different architectural qualities, such as maintainability, reusability, testability, performance, scalability, and security. Finally, you will get an overview of distributed systems, such as service-oriented architecture, microservices, and cloud-native, and understand how to apply them in application development. By the end of this book, you'll be able to build distributed services using modern C++ and associated tools to deliver solutions as per your clients' requirements.What you will learnUnderstand how to apply the principles of software architectureApply design patterns and best practices to meet your architectural goalsWrite elegant, safe, and performant code using the latest C++ featuresBuild applications that are easy to maintain and deployExplore the different architectural approaches and learn to apply them as per your requirementSimplify development and operations using application containersDiscover various techniques to solve common problems in software design and developmentWho this book is forThis software architecture C++ programming book is for experienced C++ developers looking to become software architects or develop enterprise-grade applications. ","Software Architecture with C++: Design modern systems using effective architecture concepts, design patterns, and techniques with C++20","Apply business requirements to IT infrastructure and deliver a high-quality product by understanding architectures such as microservices, DevOps, and cloud-native using modern C++ standards and featuresKey FeaturesDesign scalable large-scale applications with the C++ programming languageArchitect software solutions in a cloud-based environment with continuous integration and continuous delivery (CI/CD)Achieve architectural goals by leveraging design patterns, language features, and useful toolsBook DescriptionSoftware architecture refers to the high-level design of complex applications. It is evolving just like the languages we use, but there are architectural concepts and patterns that you can learn to write high-performance apps in a high-level language without sacrificing readability and maintainability. If you're working with modern C++, this practical guide will help you put your knowledge to work and design distributed, large-scale apps. You'll start by getting up to speed with architectural concepts, including established patterns and rising trends, then move on to understanding what software architecture actually is and start exploring its components. Next, you'll discover the design concepts involved in application architecture and the patterns in software development, before going on to learn how to build, package, integrate, and deploy your components. In the concluding chapters, you'll explore different architectural qualities, such as maintainability, reusability, testability, performance, scalability, and security. Finally, you will get an overview of distributed systems, such as service-oriented architecture, microservices, and cloud-native, and understand how to apply them in application development. By the end of this book, you'll be able to build distributed services using modern C++ and associated tools to deliver solutions as per your clients' requirements.What you will learnUnderstand how to apply the principles of software architectureApply design patterns and best practices to meet your architectural goalsWrite elegant, safe, and performant code using the latest C++ featuresBuild applications that are easy to maintain and deployExplore the different architectural approaches and learn to apply them as per your requirementSimplify development and operations using application containersDiscover various techniques to solve common problems in software design and developmentWho this book is forThis software architecture C++ programming book is for experienced C++ developers looking to become software architects or develop enterprise-grade applications. ",IEEE book,no,"['design', 'modern', 'using', 'effective', 'concept', 'design', 'pattern', 'technique', 'apply', 'business', 'requirement', 'infrastructure', 'deliver', 'product', 'understanding', 'devops', 'using', 'modern', 'standard', 'scalable', 'programming', 'solution', 'environment', 'continuous', 'integration', 'continuous', 'delivery', 'achieve', 'architectural', 'goal', 'leveraging', 'design', 'pattern', 'language', 'feature', 'useful', 'refers', 'design', 'complex', 'evolving', 'like', 'language', 'use', 'architectural', 'concept', 'pattern', 'learn', 'write', 'apps', 'language', 'without', 'maintainability', 'working', 'modern', 'practical', 'guide', 'help', 'put', 'knowledge', 'work', 'design', 'distributed', 'apps', 'start', 'getting', 'speed', 'architectural', 'concept', 'including', 'established', 'pattern', 'trend', 'move', 'understanding', 'actually', 'start', 'exploring', 'next', 'discover', 'design', 'concept', 'involved', 'pattern', 'development', 'going', 'learn', 'build', 'integrate', 'deploy', 'chapter', 'explore', 'different', 'architectural', 'quality', 'maintainability', 'reusability', 'performance', 'scalability', 'security', 'finally', 'get', 'overview', 'distributed', 'understand', 'apply', 'development', 'end', 'book', 'able', 'build', 'distributed', 'using', 'modern', 'associated', 'tool', 'deliver', 'solution', 'per', 'client', 'learnunderstand', 'apply', 'principle', 'design', 'pattern', 'best', 'practice', 'meet', 'architectural', 'safe', 'code', 'using', 'latest', 'easy', 'maintain', 'different', 'architectural', 'learn', 'apply', 'per', 'development', 'operation', 'using', 'various', 'technique', 'solve', 'common', 'problem', 'design', 'book', 'forthis', 'programming', 'book', 'experienced', 'developer', 'looking', 'become', 'architect', 'develop']"
"Event-Driven Architecture in Golang: Building complex systems with asynchronicity and eventual consistency Begin building event-driven microservices, including patterns to handle data consistency and resiliencyKey FeaturesExplore the benefits and tradeoffs of event-driven architectures with practical examples and use casesUnderstand synergy with event sourcing, CQRS, and domain-driven development in software architectureBuild an end-to-end robust application architecture by the end of the bookBook DescriptionEvent-driven architecture in Golang is an approach used to develop applications that shares state changes asynchronously, internally, and externally using messages. EDA applications are better suited at handling situations that need to scale up quickly and the chances of individual component failures are less likely to bring your system crashing down. This is why EDA is a great thing to learn and this book is designed to get you started with the help of step-by-step explanations of essential concepts, practical examples, and more. You’ll begin building event-driven microservices, including patterns to handle data consistency and resiliency. Not only will you learn the patterns behind event-driven microservices but also how to communicate using asynchronous messaging with event streams. You’ll then build an application made of several microservices that communicates using both choreographed and orchestrated messaging. By the end of this book, you’ll be able to build and deploy your own event-driven microservices using asynchronous communication.What you will learnUnderstand different event-driven patterns and best practicesPlan and design your software architecture with easeTrack changes and updates effectively using event sourcingTest and deploy your sample software application with easeMonitor and improve the performance of your software architectureWho this book is forThis hands-on book is for intermediate-level software architects, or senior software engineers working with Golang and interested in building asynchronous microservices using event sourcing, CQRS, and DDD. Intermediate-level knowledge of the Go syntax and concurrency features is necessary.",Event-Driven Architecture in Golang: Building complex systems with asynchronicity and eventual consistency,"Begin building event-driven microservices, including patterns to handle data consistency and resiliencyKey FeaturesExplore the benefits and tradeoffs of event-driven architectures with practical examples and use casesUnderstand synergy with event sourcing, CQRS, and domain-driven development in software architectureBuild an end-to-end robust application architecture by the end of the bookBook DescriptionEvent-driven architecture in Golang is an approach used to develop applications that shares state changes asynchronously, internally, and externally using messages. EDA applications are better suited at handling situations that need to scale up quickly and the chances of individual component failures are less likely to bring your system crashing down. This is why EDA is a great thing to learn and this book is designed to get you started with the help of step-by-step explanations of essential concepts, practical examples, and more. You’ll begin building event-driven microservices, including patterns to handle data consistency and resiliency. Not only will you learn the patterns behind event-driven microservices but also how to communicate using asynchronous messaging with event streams. You’ll then build an application made of several microservices that communicates using both choreographed and orchestrated messaging. By the end of this book, you’ll be able to build and deploy your own event-driven microservices using asynchronous communication.What you will learnUnderstand different event-driven patterns and best practicesPlan and design your software architecture with easeTrack changes and updates effectively using event sourcingTest and deploy your sample software application with easeMonitor and improve the performance of your software architectureWho this book is forThis hands-on book is for intermediate-level software architects, or senior software engineers working with Golang and interested in building asynchronous microservices using event sourcing, CQRS, and DDD. Intermediate-level knowledge of the Go syntax and concurrency features is necessary.",IEEE book,no,"['golang', 'building', 'complex', 'consistency', 'begin', 'building', 'including', 'pattern', 'handle', 'consistency', 'benefit', 'tradeoff', 'practical', 'example', 'use', 'event', 'sourcing', 'cqrs', 'development', 'robust', 'end', 'golang', 'used', 'develop', 'share', 'state', 'change', 'using', 'message', 'eda', 'better', 'suited', 'handling', 'situation', 'need', 'scale', 'quickly', 'chance', 'individual', 'failure', 'less', 'likely', 'bring', 'eda', 'great', 'thing', 'learn', 'book', 'designed', 'get', 'started', 'help', 'essential', 'concept', 'practical', 'example', 'begin', 'building', 'including', 'pattern', 'handle', 'consistency', 'resiliency', 'learn', 'pattern', 'behind', 'also', 'communicate', 'using', 'asynchronous', 'messaging', 'event', 'stream', 'build', 'made', 'several', 'using', 'orchestrated', 'messaging', 'end', 'book', 'able', 'build', 'deploy', 'using', 'asynchronous', 'learnunderstand', 'different', 'pattern', 'best', 'design', 'change', 'update', 'effectively', 'using', 'event', 'deploy', 'sample', 'improve', 'performance', 'book', 'forthis', 'book', 'architect', 'engineer', 'working', 'golang', 'interested', 'building', 'asynchronous', 'using', 'event', 'sourcing', 'cqrs', 'knowledge', 'go', 'concurrency', 'feature', 'necessary']"
"Content Management System Architecture This chapter looks at architecture elements of a content management system (CMS). It discusses the various CMS components and their roles in content strategy and defines various phases of CMS implementation approach. The chapter describes modern CMS architecture patterns including model view controller (MVC), service‐oriented architecture (SOA), n‐tier, and microservices architectures. It focuses on CMS value articulation framework and the key CMS solution design principles and explores design aspects of CMS solution components such as multi‐site management, localization, content folders, content URLs, CMS infrastructure, and CMS maintenance. The chapter also discusses various CMS reference architecture by looking at customer experience management (CXP) architecture, knowledge management architecture, digital marketing platforms based on CMS, and Apache Jackrabbit architecture. Digital marketing content should be personalized based on user segments, target device, and other context parameters. Web analytics should be tagged along with content to track user behavior to gain vital insights.",Content Management System Architecture,"This chapter looks at architecture elements of a content management system (CMS). It discusses the various CMS components and their roles in content strategy and defines various phases of CMS implementation approach. The chapter describes modern CMS architecture patterns including model view controller (MVC), service‐oriented architecture (SOA), n‐tier, and microservices architectures. It focuses on CMS value articulation framework and the key CMS solution design principles and explores design aspects of CMS solution components such as multi‐site management, localization, content folders, content URLs, CMS infrastructure, and CMS maintenance. The chapter also discusses various CMS reference architecture by looking at customer experience management (CXP) architecture, knowledge management architecture, digital marketing platforms based on CMS, and Apache Jackrabbit architecture. Digital marketing content should be personalized based on user segments, target device, and other context parameters. Web analytics should be tagged along with content to track user behavior to gain vital insights.",IEEE book,no,"['content', 'management', 'chapter', 'look', 'element', 'content', 'management', 'cm', 'discusses', 'various', 'cm', 'role', 'content', 'strategy', 'defines', 'various', 'phase', 'cm', 'implementation', 'chapter', 'describes', 'modern', 'cm', 'pattern', 'including', 'model', 'view', 'controller', 'soa', 'focus', 'cm', 'value', 'framework', 'key', 'cm', 'solution', 'design', 'principle', 'explores', 'design', 'aspect', 'cm', 'solution', 'management', 'localization', 'content', 'content', 'cm', 'infrastructure', 'cm', 'maintenance', 'chapter', 'also', 'discusses', 'various', 'cm', 'reference', 'looking', 'customer', 'experience', 'management', 'knowledge', 'management', 'digital', 'marketing', 'platform', 'based', 'cm', 'apache', 'digital', 'marketing', 'content', 'personalized', 'based', 'user', 'segment', 'target', 'device', 'context', 'parameter', 'web', 'analytics', 'along', 'content', 'track', 'user', 'behavior', 'gain', 'vital', 'insight']"
"An Atypical ASP.NET Core 6 Design Patterns Guide: A SOLID adventure into architectural principles and design patterns using .NET 6 and C# 10 The professional developer’s essential guide to building robust, maintainable, and flexible web apps by leveraging C# 10 and .NET 6 features and component- and application-scale design patternsKey FeaturesApply the SOLID architectural principles and software design patterns effectively with a focus on dependency injectionDiscover modern application architectures such as vertical slice, clean architecture, and event-driven microservicesExplore full-stack ASP.NET Core with an overview of BlazorBook DescriptionAn Atypical ASP.NET Core 6 Design Patterns Guide, Second Edition approaches programming like playing with LEGO®: snapping small pieces together to create something beautiful. Thoroughly updated for ASP.NET Core 6, with further coverage of microservices patterns, data contracts, and event-driven architecture, this book gives you the tools to build and glue reliable components together to improve your programmatic masterpieces. The chapters are organized based on scale and topic, allowing you to start small and build on a strong base, the same way that you would develop a program. You will begin by exploring basic design patterns, SOLID architectural principles, dependency injection, and other ASP.NET Core 6 mechanisms. You will explore component-scale patterns, and then move to higher level application-scale patterns and techniques to better structure your applications. Finally, you'll advance to the client side to connect the dots with tools like Blazor and make ASP.NET Core a viable full-stack web development framework. You will supplement your learning with practical use cases and best practices, exploring a range of significant Gang of Four (GoF) design patterns along the way. By the end of the book, you will be comfortable combining and implementing patterns in different ways, and crafting software solutions of any scale.What you will learnApply the SOLID principles for building flexible and maintainable softwareGet to grips with .NET dependency injectionWork with GoF design patterns such as strategy, decorator, façade, and compositeExplore the MVC patterns for designing web APIs and web applications using RazorDiscover layering techniques and tenets of clean architectureBecome familiar with CQRS and vertical slice architecture as an alternative to layeringUnderstand microservices patterns and when they can benefit your applicationsBuild ASP.NET user interfaces from server-side to client-side BlazorWho this book is forThe book is intended for intermediate software and web developers with an understanding of .NET who want to write flexible, maintainable, and robust code for building scalable web applications. Knowledge of C# programming and an understanding of web concepts like HTTP is necessary.",An Atypical ASP.NET Core 6 Design Patterns Guide: A SOLID adventure into architectural principles and design patterns using .NET 6 and C# 10,"The professional developer’s essential guide to building robust, maintainable, and flexible web apps by leveraging C# 10 and .NET 6 features and component- and application-scale design patternsKey FeaturesApply the SOLID architectural principles and software design patterns effectively with a focus on dependency injectionDiscover modern application architectures such as vertical slice, clean architecture, and event-driven microservicesExplore full-stack ASP.NET Core with an overview of BlazorBook DescriptionAn Atypical ASP.NET Core 6 Design Patterns Guide, Second Edition approaches programming like playing with LEGO®: snapping small pieces together to create something beautiful. Thoroughly updated for ASP.NET Core 6, with further coverage of microservices patterns, data contracts, and event-driven architecture, this book gives you the tools to build and glue reliable components together to improve your programmatic masterpieces. The chapters are organized based on scale and topic, allowing you to start small and build on a strong base, the same way that you would develop a program. You will begin by exploring basic design patterns, SOLID architectural principles, dependency injection, and other ASP.NET Core 6 mechanisms. You will explore component-scale patterns, and then move to higher level application-scale patterns and techniques to better structure your applications. Finally, you'll advance to the client side to connect the dots with tools like Blazor and make ASP.NET Core a viable full-stack web development framework. You will supplement your learning with practical use cases and best practices, exploring a range of significant Gang of Four (GoF) design patterns along the way. By the end of the book, you will be comfortable combining and implementing patterns in different ways, and crafting software solutions of any scale.What you will learnApply the SOLID principles for building flexible and maintainable softwareGet to grips with .NET dependency injectionWork with GoF design patterns such as strategy, decorator, façade, and compositeExplore the MVC patterns for designing web APIs and web applications using RazorDiscover layering techniques and tenets of clean architectureBecome familiar with CQRS and vertical slice architecture as an alternative to layeringUnderstand microservices patterns and when they can benefit your applicationsBuild ASP.NET user interfaces from server-side to client-side BlazorWho this book is forThe book is intended for intermediate software and web developers with an understanding of .NET who want to write flexible, maintainable, and robust code for building scalable web applications. Knowledge of C# programming and an understanding of web concepts like HTTP is necessary.",IEEE book,no,"['core', 'design', 'pattern', 'guide', 'solid', 'architectural', 'principle', 'design', 'pattern', 'using', 'c', 'professional', 'developer', 'essential', 'guide', 'building', 'robust', 'maintainable', 'flexible', 'web', 'apps', 'leveraging', 'c', 'feature', 'design', 'solid', 'architectural', 'principle', 'design', 'pattern', 'effectively', 'focus', 'dependency', 'modern', 'vertical', 'slice', 'clean', 'core', 'overview', 'core', 'design', 'pattern', 'guide', 'second', 'programming', 'like', 'small', 'piece', 'together', 'create', 'updated', 'core', 'coverage', 'pattern', 'book', 'give', 'tool', 'build', 'reliable', 'together', 'improve', 'chapter', 'organized', 'based', 'scale', 'topic', 'allowing', 'start', 'small', 'build', 'strong', 'base', 'way', 'would', 'develop', 'program', 'begin', 'exploring', 'basic', 'design', 'pattern', 'solid', 'architectural', 'principle', 'dependency', 'injection', 'core', 'mechanism', 'explore', 'pattern', 'move', 'higher', 'level', 'pattern', 'technique', 'better', 'structure', 'finally', 'advance', 'client', 'side', 'connect', 'tool', 'like', 'make', 'core', 'viable', 'web', 'development', 'framework', 'learning', 'practical', 'use', 'case', 'best', 'practice', 'exploring', 'range', 'significant', 'four', 'design', 'pattern', 'along', 'way', 'end', 'book', 'combining', 'implementing', 'pattern', 'different', 'way', 'solution', 'solid', 'principle', 'building', 'flexible', 'maintainable', 'grip', 'dependency', 'design', 'pattern', 'strategy', 'pattern', 'designing', 'web', 'apis', 'web', 'using', 'technique', 'tenet', 'clean', 'cqrs', 'vertical', 'slice', 'alternative', 'pattern', 'benefit', 'user', 'interface', 'book', 'book', 'intended', 'intermediate', 'web', 'developer', 'understanding', 'write', 'flexible', 'maintainable', 'robust', 'code', 'building', 'scalable', 'web', 'knowledge', 'c', 'programming', 'understanding', 'web', 'concept', 'like', 'http', 'necessary']"
